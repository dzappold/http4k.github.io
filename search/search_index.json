{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"http4k is a lightweight but fully-featured HTTP toolkit written in pure Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way. http4k applications are just Kotlin functions which can be mounted into a running backend. For example, here's a simple echo server: val app : HttpHandler = { request : Request - Response ( OK ). body ( request . body ) } val server = app . asServer ( SunHttp ( 8000 )). start () http4k consists of a core library, http4k-core , providing a base HTTP implementation + a number of capability abstractions (such as servers, clients, templating, websockets etc). These capabilities are then implemented in add-on modules. The principles of http4k are: Application as a Function: Based on the Twitter paper \"Your Server as a Function\" , all HTTP services can be composed of 2 types of simple function: HttpHandler: (Request) - Response - provides a remote call for processing a Request. Filter: (HttpHandler) - HttpHandler - adds Request/Response pre/post processing. These filters are composed to make stacks of reusable behaviour that can then be applied to an HttpHandler . Immutability: All entities in the library are immutable unless their function explicitly disallows this. Symmetric: The HttpHandler interface is identical for both HTTP services and clients. This allows for simple offline testability of applications, as well as plugging together of services without HTTP container being required. Dependency-lite: Apart the from Kotlin StdLib, http4k-core module has ZERO dependencies and weighs in at ~700kb. Add-on modules only have dependencies required for specific implementation. Testability Built by TDD enthusiasts, so supports super-easy mechanisms for both In and Out of Container testing of: individual endpoints applications websockets full suites of microservices Modularity: Common behaviours are abstracted into the http4k-core module. Current add-on modules provide: Pluggable HTTP client adapters for Apache, Jetty, OkHttp and Websockets Pluggable Server backends: Single LOC Server spinup for Jetty, Netty, Undertow, Apache (Httpcore), Ktor CIO and SunHttp. Serverless backends: Test your application locally and then deploy it to AWS Lambda. Templating support: Caching and Hot-Reload engine support for Handlebars, Pebble, Dust and Thymeleaf HTTP message adapters for Argo JSON, Gson JSON, Jackson JSON, Moshi JSON and XML - includes auto-marshalling capabilities to convert directly to Kotlin data classes. Typesafe, auto-validating, self-documenting (via OpenApi/Swagger) contracts for HTTP services AWS request signing: super-simple interactions with AWS services. Metrics gathering for performance analysis. Multipart form handling, including stream processing for uploaded files. Resilience features: Circuits, retrying, rate limiting, bulkheading - via Resilience4J integration. Security: Simple, pluggable support for OAuth Auth Code Grant flow and ready made configurations to integrate with popular OAuth providers. Cloud-native tooling: support for 12-factor-based style apps. Testing: Selenium WebDriver implementation for lightning fast, browserless testing of http4k apps Testing: Hamkrest Matchers for http4k objects. Testing: Chaos Injection mechanism, allowing simple, dynamic injection of failure modes into http4k applications. Module feature overview Core: Base HTTP handler and immutable HTTP message objects, cookie handling. Commonly used HTTP functionalities provided as reusable Filters (caching, debugging, Zipkin request tracing ) Path-based routing , including nestable contexts Typesafe HTTP message construction/desconstruction and Request Contexts using Lenses Static file-serving capability with Caching and Hot-Reload Servlet implementation to allow plugin to any Servlet container Launch applications in 1LOC with an embedded SunHttp server backend (recommended for development use only) Path-based websockets including typesafe message marshalling using Lenses APIs to record and replay HTTP traffic to disk or memory Core abstraction APIs implemented by the other modules Client: 1LOC client adapters Apache sync + async HTTP Jetty HTTP (supports sync and async HTTP) OkHttp HTTP (supports sync and async HTTP) Java (bundled with http4k-core ) 1LOC WebSocket client, with blocking and non-blocking modes Server: 1LOC server backend spinup for: Jetty (including websocket support) Undertow Apache (from httpcore) Netty Ktor CIO SunHttp (bundled with http4k-core ) API design allows for plugging into configurable instances of each Serverless: Implement a single Factory method, then upload your http4k applications to AWS Lambda to be called from API Gateway. Contracts: Define Typesafe HTTP contracts, with required and optional path/query/header/bodies Typesafe path matching Auto-validation of incoming requests == zero boilerplate validation code Self-documenting for all routes - eg. Built in support for live OpenApi/Swagger description endpoints including JSON Schema model breakdown. Templating: Pluggable templating system support for: Dust Handlebars Pebble Thymeleaf Caching and Hot-Reload template support Message formats: Consistent API provides first class support for marshalling JSON to/from HTTP messages for: Jackson - includes support for fully automatic marshalling of Data classes ) Gson - includes support for fully automatic marshalling of Data classes ) Moshi - includes support for fully automatic marshalling of Data classes ) Argo - lightweight Java JSON API with zero dependencies. Xml - includes support for one way automatic marshalling of Data classes ) Resilience: Support for Circuits, Retrying, Rate-Limiting, Bulkheading via Resilience4J integration. Metrics: Support for plugging http4k apps into micrometer Multipart: Support for Multipart HTML forms, including Lens extensions for type-safe marshalling of fields. AWS: Client filter to allow super-simple interaction with AWS services (via request signing) OAuth Security Implement OAuth Authorisation Code Grant flow with a single Interface Pre-configured OAuth for following providers: Auth0 Dropbox Google Soundcloud Cloud Native: Tooling to support operating http4k applications in orchestrated cloud environments such as Kubernetes and CloudFoundry. 12-factor configuration, dual-port servers and health checks such as liveness and readiness checking. WebDriver: Ultra-lightweight Selenium WebDriver implementation for http4k application. Hamkrest: A set of Hamkrest matchers for testing http4k Request and Response messages. Chaos: API for declaring and injecting failure modes into http4k applications, allowing modelling and hence answering of \"what if\" style questions to help understand how code fares under failure conditions such as latency and dying processes. Example This quick example is designed to convey the simplicity features of http4k . See also the quickstart for the simplest possible starting point. To install, add these dependencies to your Gradle file: dependencies { compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-server-jetty , version: 3.113.0 compile group: org.http4k , name: http4k-client-okhttp , version: 3.113.0 } This \"Hello World\" style example ( ) demonstrates how to serve and consume HTTP services with dynamic routing: package cookbook import org.http4k.client.OkHttp import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.CachingFilters import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { // we can bind HttpHandlers (which are just functions from Request - Response) to paths/methods to create a Route, // then combine many Routes together to make another HttpHandler val app : HttpHandler = routes ( /ping bind GET to { _ : Request - Response ( OK ). body ( pong! ) }, /greet/{name} bind GET to { req : Request - val path : String ? = req . path ( name ) Response ( OK ). body ( hello ${path ?: anon ! } ) } ) // call the handler in-memory without spinning up a server val inMemoryResponse : Response = app ( Request ( GET , /greet/Bob )) println ( inMemoryResponse ) // Produces: // HTTP/1.1 200 OK // // // hello Bob // this is a Filter - it performs pre/post processing on a request or response val timingFilter = Filter { next : HttpHandler - { request : Request - val start = System . currentTimeMillis () val response = next ( request ) val latency = System . currentTimeMillis () - start println ( Request to ${request.uri} took ${latency}ms ) response } } // we can stack filters to create reusable units, and then apply them to an HttpHandler val compositeFilter = CachingFilters . Response . NoCache (). then ( timingFilter ) val filteredApp : HttpHandler = compositeFilter . then ( app ) // only 1 LOC to mount an app and start it in a container filteredApp . asServer ( Jetty ( 9000 )). start () // HTTP clients are also HttpHandlers! val client : HttpHandler = OkHttp () val networkResponse : Response = client ( Request ( GET , http://localhost:9000/greet/Bob )) println ( networkResponse ) // Produces: // Request to /api/greet/Bob took 1ms // HTTP/1.1 200 // cache-control: private, must-revalidate // content-length: 9 // date: Thu, 08 Jun 2017 13:01:13 GMT // expires: 0 // server: Jetty(9.3.16.v20170120) // // hello Bob } Acknowledgments Dan Bodart 's utterlyidle Ivan Moore for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\" Contributors This project exists thanks to all the people who contribute . Backers Sponsors If you use http4k in your project or enterprise and would like to support ongoing development, please consider becoming a backer or a sponsor. Sponsor logos will show up here with a link to your website.","title":"Introduction"},{"location":"#module-feature-overview","text":"Core: Base HTTP handler and immutable HTTP message objects, cookie handling. Commonly used HTTP functionalities provided as reusable Filters (caching, debugging, Zipkin request tracing ) Path-based routing , including nestable contexts Typesafe HTTP message construction/desconstruction and Request Contexts using Lenses Static file-serving capability with Caching and Hot-Reload Servlet implementation to allow plugin to any Servlet container Launch applications in 1LOC with an embedded SunHttp server backend (recommended for development use only) Path-based websockets including typesafe message marshalling using Lenses APIs to record and replay HTTP traffic to disk or memory Core abstraction APIs implemented by the other modules Client: 1LOC client adapters Apache sync + async HTTP Jetty HTTP (supports sync and async HTTP) OkHttp HTTP (supports sync and async HTTP) Java (bundled with http4k-core ) 1LOC WebSocket client, with blocking and non-blocking modes Server: 1LOC server backend spinup for: Jetty (including websocket support) Undertow Apache (from httpcore) Netty Ktor CIO SunHttp (bundled with http4k-core ) API design allows for plugging into configurable instances of each Serverless: Implement a single Factory method, then upload your http4k applications to AWS Lambda to be called from API Gateway. Contracts: Define Typesafe HTTP contracts, with required and optional path/query/header/bodies Typesafe path matching Auto-validation of incoming requests == zero boilerplate validation code Self-documenting for all routes - eg. Built in support for live OpenApi/Swagger description endpoints including JSON Schema model breakdown. Templating: Pluggable templating system support for: Dust Handlebars Pebble Thymeleaf Caching and Hot-Reload template support Message formats: Consistent API provides first class support for marshalling JSON to/from HTTP messages for: Jackson - includes support for fully automatic marshalling of Data classes ) Gson - includes support for fully automatic marshalling of Data classes ) Moshi - includes support for fully automatic marshalling of Data classes ) Argo - lightweight Java JSON API with zero dependencies. Xml - includes support for one way automatic marshalling of Data classes ) Resilience: Support for Circuits, Retrying, Rate-Limiting, Bulkheading via Resilience4J integration. Metrics: Support for plugging http4k apps into micrometer Multipart: Support for Multipart HTML forms, including Lens extensions for type-safe marshalling of fields. AWS: Client filter to allow super-simple interaction with AWS services (via request signing) OAuth Security Implement OAuth Authorisation Code Grant flow with a single Interface Pre-configured OAuth for following providers: Auth0 Dropbox Google Soundcloud Cloud Native: Tooling to support operating http4k applications in orchestrated cloud environments such as Kubernetes and CloudFoundry. 12-factor configuration, dual-port servers and health checks such as liveness and readiness checking. WebDriver: Ultra-lightweight Selenium WebDriver implementation for http4k application. Hamkrest: A set of Hamkrest matchers for testing http4k Request and Response messages. Chaos: API for declaring and injecting failure modes into http4k applications, allowing modelling and hence answering of \"what if\" style questions to help understand how code fares under failure conditions such as latency and dying processes.","title":"Module feature overview"},{"location":"#example","text":"This quick example is designed to convey the simplicity features of http4k . See also the quickstart for the simplest possible starting point. To install, add these dependencies to your Gradle file: dependencies { compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-server-jetty , version: 3.113.0 compile group: org.http4k , name: http4k-client-okhttp , version: 3.113.0 } This \"Hello World\" style example ( ) demonstrates how to serve and consume HTTP services with dynamic routing: package cookbook import org.http4k.client.OkHttp import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.CachingFilters import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { // we can bind HttpHandlers (which are just functions from Request - Response) to paths/methods to create a Route, // then combine many Routes together to make another HttpHandler val app : HttpHandler = routes ( /ping bind GET to { _ : Request - Response ( OK ). body ( pong! ) }, /greet/{name} bind GET to { req : Request - val path : String ? = req . path ( name ) Response ( OK ). body ( hello ${path ?: anon ! } ) } ) // call the handler in-memory without spinning up a server val inMemoryResponse : Response = app ( Request ( GET , /greet/Bob )) println ( inMemoryResponse ) // Produces: // HTTP/1.1 200 OK // // // hello Bob // this is a Filter - it performs pre/post processing on a request or response val timingFilter = Filter { next : HttpHandler - { request : Request - val start = System . currentTimeMillis () val response = next ( request ) val latency = System . currentTimeMillis () - start println ( Request to ${request.uri} took ${latency}ms ) response } } // we can stack filters to create reusable units, and then apply them to an HttpHandler val compositeFilter = CachingFilters . Response . NoCache (). then ( timingFilter ) val filteredApp : HttpHandler = compositeFilter . then ( app ) // only 1 LOC to mount an app and start it in a container filteredApp . asServer ( Jetty ( 9000 )). start () // HTTP clients are also HttpHandlers! val client : HttpHandler = OkHttp () val networkResponse : Response = client ( Request ( GET , http://localhost:9000/greet/Bob )) println ( networkResponse ) // Produces: // Request to /api/greet/Bob took 1ms // HTTP/1.1 200 // cache-control: private, must-revalidate // content-length: 9 // date: Thu, 08 Jun 2017 13:01:13 GMT // expires: 0 // server: Jetty(9.3.16.v20170120) // // hello Bob }","title":"Example"},{"location":"#acknowledgments","text":"Dan Bodart 's utterlyidle Ivan Moore for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\"","title":"Acknowledgments"},{"location":"#contributors","text":"This project exists thanks to all the people who contribute .","title":"Contributors"},{"location":"#backers-sponsors","text":"If you use http4k in your project or enterprise and would like to support ongoing development, please consider becoming a backer or a sponsor. Sponsor logos will show up here with a link to your website.","title":"Backers &amp; Sponsors"},{"location":"api/","text":"","title":"API docs"},{"location":"blog/meet_http4k/","text":"Server as a Function. In Kotlin. Typesafe. Without the Server. @daviddenton Meet http4k http4k is an HTTP toolkit written in Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way. Whenever (yet another) new JVM HTTP framework is released, the inevitable question that rightly get asked is \"How it this different to X?\" . In this post, I'm going to briefly cover what http4k is, how we think it's different, and address some of those bold claims from the title of this post. Here's a quick rundown of what we think those differences are: http4k is small. Written in pure, functional Kotlin, with zero dependencies. http4k is simple. Like, really simple. No static API magic, no annotations, no reflection. http4k is immutable. It relies on an immutable HTTP model, which makes it a snap to test and debug. http4k is symmetric. It supports remote calls as a first-class concern, and the remote HTTP model is identical to the incoming HTTP model. http4k is typesafe. Say goodbye to all your validation and marshalling boilerplate and hello to automatic request validation and data class-based contracts for HTTP bodies using the Lens API. http4k is serverless. Or rather - server independent. Test an app out of container and then deploy it into any supported local container with 1 LOC - or as a function into AWS Lambda. Oh god, not another framework! Why does this even exist?!? Firstly - we don't consider http4k to be a framework - it's a set of libraries providing a functional toolkit to serve and consume HTTP services, focusing on simple, consistent, and testable APIs. Hence, whilst it does provide support for various APIs relevant to serving and consuming HTTP , it does not provide every integration under the sun - merely simple points to allow those integrations to be hooked in. Another thing to say is that (not very much) of http4k is new - it's rather the distillation of 15 years worth of experience of using various server-side libraries and hence most of the good ideas are stolen. For instance - the routing module is inspired by UtterlyIdle , the basic \"Server as a function\" model is stolen from Finagle , and the contract module OpenApi/Swagger generator is ported from Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the functional features of the language and it felt like a good time to start something from scratch, whilst avoiding the magic that plagues other frameworks. Hence, http4k is primarily designed to be a Kotlin-first library. Claim A: Small, simple, immutable. Based on the awesome \"Your Server as a Function\" paper from Twitter, http4k apps are modelled by composing 2 types of simple, independent function. Function 1: HttpHandler An HttpHandler represents an HTTP endpoint. It's not even an Interface, modelled merely as a Typealias : typealias HttpHandler = ( Request ) - Response Below is a entire http4k application that echoes the request body back in the response. It only relies on the http4k-core module, which itself has zero dependencies: val app = { request : Request - Response ( OK ). body ( request . body ) } val server = app . asServer ( SunHttp ( 8000 )). start () The Request and Response objects in there are immutable data classes/POKOs, so testing the app requires absolutely no extra infrastructure - just call the function, it's as easy as: class AppTest { @Test fun ` echoes request body ` () { assertThat ( app ( Request ( POST , / ). body ( hello )), equalTo ( Response ( OK ). body ( hello ))) } } To plug it into a different Server-backend, just depend on the relevant module (Jetty, Undertow, Netty, Apache (httpcore), Ktor CIO, and SunHttp are available) and change the call to asServer() . Function 2: Filter Filters provides pre and post Request processing and are simply: interface Filter : ( HttpHandler ) - HttpHandler For API conciseness and discoverability reasons this is modelled as an Interface and not a Typealias - it also has a couple of Kotlin extension methods to allow you to compose Filters with HttpHandlers and other Filters : val setContentType = Filter { next - { request - next ( request ). header ( Content-Type , text/plain ) } } val repeatBody = Filter { next - { request - next ( request . body ( request . bodyString () + request . bodyString () } } val composedFilter : Filter = repeatBody . then ( setContentType ) val decoratedApp : HttpHandler = composedFilter . then ( app ) Filters are also trivial to test independently, because they are generally just stateless functions. Routing http4k 's nestable routing looks a lot like every other Sinatra-style framework these days, and allows for infinitely nesting HttpHandlers - this just exposes another HttpHandler so you can easily extract, test and reuse sets of routes as easily as you could with one: val app : HttpHandler = routes ( /app bind GET to decoratedApp , /other bind routes ( /delete bind DELETE to { _ : Request - Response ( OK ) }, /post/{name} bind POST to { request : Request - Response ( OK ). body ( you POSTed to ${request.path( name )} ) } ) ) And that it - those functions are everything you need to know to write a simple http4k application. The http4k-core module rocks in at about 700kb, and has zero dependencies (other than the Kotlin language itself). Additionally, everything in the core is functional and predictable - there is no static API magic going on under the covers (making it difficult to have multiple apps in the same JVM), no annotations, no compiler-plugins, and no reflection. Claim B. Symmetric HTTP Out of the multitude of JVM http frameworks out there, not many actually consider how you app talks to other services, yet in this Microservice\u2122 world that's an absolutely massive part of what many apps do! As per a core principle behind \"Server as a Function\", http4k provides a symmetric API for HTTP clients - ie. it's exactly the same API as is exposed in http4k server applications - the HttpHandler . Here's that entire API again, just in case you've forgotten: typealias HttpHandler = ( Request ) - Response What does that mean in practice? Well - for one thing, it's less for your brain to learn because you already know the API: val client : HttpHandler = ApacheClient () val response : Response = client ( Request ( GET , http://server/path )) For another, it means that since clients are just function s you can easily stub them for testing, and since applications and clients are interchangeable, they can be plugged together in memory without putting them on the network - which makes testing insanely fast: fun MyApp1 (): HttpHandler = { Response ( OK ) } fun MyApp2 ( app1 : HttpHandler ): HttpHandler = { app1 ( it ) } val app1 : HttpHandler = MyApp1 () val app2 : HttpHandler = MyApp2 ( app1 ) http4k provides a HTTP client adapters for both Apache and OkHttp , all with streaming support. Claim C. Typesafe HTTP with Lenses The immutable http4k model for HTTP objects contains all the usual suspect methods for getting values from the messages. For instance, if we are expecting a search parameter with a query containing a page number: val request = Request ( GET , http://server/search?page=123 ) val page : Int = request . query ( page ) !! . toInt ...but we also want to ensure that the expected values are both present and valid, since the above example will fail if either of those things is not true. For this purpose, we can use a Lens to enforce the expected HTTP contract. The use of Lenses in http4k applications can remove the need for writing any parsing or validation code for all incoming data (including Forms), as validations are taken care of by the library. Lens basics A Lens is a bi-directional entity which can be used to either get or set a particular value from/onto an HTTP message. http4k provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional) and the type. For the above example, we could use the Query Lens builder and then invoke() the Lens on the message to extract the target value: val pageLens = Query . int (). required ( page ) val page : Int = pageLens ( Request ( GET , http://server/search?page=123 )) If the query parameter is missing or not an Int, the lens extraction operation will fail. There are similar Lens builder functions for all parts of the HTTP message ( Header , Path , Body , FormField etc..), and functions for all common JVM primitive types. They are all completely typesafe - there is no reflection or magic going on - just marshalling of the various entities (in this case String to Int conversion). In the case of failure, we need to apply a Filter to detect the errors and convert them to a BAD_REQUEST response: val queryName = Query . string (). required ( name ) val app : HttpHandler = routes ( /post bind POST to { request : Request - Response ( OK ). body ( queryName ( request )) } ) val app = ServerFilters . CatchLensFailure . then ( handler )( Request ( GET , /hello/2000-01-01?myCustomType=someValue )) Lenses can also be applied with a correctly typed value (via invoke() ) to set it onto a target object - and as HTTP messages in http4k are immutable, this results in a copy of the modified message: val pageSizeLens = Header . int (). required ( page ) val page : Response = pageLens ( Response ( OK ), 123 ) // or apply multiple lenses using with() val updated : Request = Request ( GET , /foo ). with ( pageLens of 123 , pageSizeLens of 10 ) Securely extracting JDK primitives from HTTP messages is great, but we really want to avoid primitives entirely and go straight to domain types. During construction of Lens, the builders allow mapping to occur so we can leverage Kotlin data classes. This works for both get and set operations: data class MyDate ( val value : LocalDate ) val dateQuery = Query . localDate (). map ( :: MyDate , MyDate :: value ). required ( date ) val myDate : MyDate = dateQuery ( Request ( GET , http://server/search?date=2000-01-01 )) Lensing HTTP bodies with Data classes Some of the supported message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection (oops - looks like we broke our reflection promise - but technically we're not doing it ;) !). This behaviour is supported in http4k Lenses through the use of the auto() method, which will marshall objects to/from HTTP messages: data class Email ( val value : String ) data class Message ( val subject : String , val from : Email , val to : Email ) val messageLens = Body . auto Message (). toLens () val body = { subject : hello , from :{ value : bob@git . com }, to :{ value : sue@git . com }} val message : Message = messageLens ( Request ( GET , / ). body ( body )) This mechanism works for all incoming and outgoing JSON and XML Requests and Responses. To assist with developing whilst using this type of auto-marshalling, we have created a tool to automatically generate a set of data classes for a given messages. Claim D. Serverless Ah yes - Serverless - the latest in the Cool Kids Club and killer fodder for the resume. Well, since http4k is server independent, it turns out to be fairly trivial to deploy full applications to AWS Lambda , and then call them by setting up the API Gateway to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. In order to achieve this, only a single interface AppLoader needs to be implemented - this is responsible for creating the HttpHandler which is adapted to the API of the ApiGatewayProxyRequest/ApiGatewayProxyResponse used by AWS. As this is AWS, there is a fair amount of configuration required to make this possible, but the only http4k specific config is to: Set the function execution to call org.http4k.serverless.lambda.LambdaFunction::handle Set an environment variable for the Lambda HTTP4K_BOOTSTRAP_CLASS to the class of your AppLoader class. Here's a simple example: object TweetEcho : AppLoader { override fun invoke ( env : Map String , String ): HttpHandler = { Response ( OK ). body ( it . bodyString (). take ( 140 )) } } Since http4k is very dependency-light, full binary uploads of these AWS Lambdas tend to be very small - and by utilising Proguard we've seen the size of a Lambda UberJar go as small as 150kb. Introduced in v3.0.0, this support is available in the http4k-serverless-lambda module. The final word(s)! As pointed out above, http4k-core module has zero dependencies. It is also small, even though it also provides: Support for static file-serving with HotReload. A bunch of useful Filters for stuff like Zipkin Request Tracing. Support for Request Contexts. Facilities to record and replay HTTP traffic. There are also a bunch of other modules available, all presented with the same concentration on Testability, API simplicity and consistency: ViewModel driven templating engine support (Handlerbars etc) with HotReload. Popular JSON/XML (Gson, Jackson, Moshi, etc) library support for HTTP bodies. Typesafe HTML Form and Multipart Forms processing, with support for Streaming uploads to a storage service. Forms can also be configured to collect errors instead of just rejecting outright. Typesafe contract module, providing live OpenApi/Swagger documentation. AWS request signing. Resilience4j integration, including Circuit Breakers Rate Limiting. Testing support via Hamkrest matchers and an in-memory WebDriver implementation. Finally, http4k is proven in production , it has been adopted in at least 2 global investment banks and is serving the vast majority of traffic for a major publishing website (in the top 1000 sites globally according to alexa.com - ie. easily serving 10s of million hits per day on a few nodes) since March 2017. You can see a few example applications here , including a bootstrap project for creating a Github - Travis - Heroku CD pipeline in a single command. Well, that's it for this whirlwind tour - we hope you found it worth reading this far! We'd love you to try out http4k and feedback why you love/hate/are indifferent to it :) . And if you want to get involved or chat to the authors, we hang out in the friendly #http4k channel @ slack.kotlinlang,org . Footnotes \"But... but... but... asynchronous! And Webscale!\" , I heard them froth . Yes, you are correct - \"Server as a Function\" is based on asynchronous functions and http4k exposes a synchronous API. However, our experience suggests that for the vast majority of apps, this actually makes API integration harder unless you've got async all the way down - and that is assuming that async clients are actually available for all your various remote dependencies. We found that this plainly didn't matter for our use-cases so went for Simple API\u2122 instead... it's possible however that Kotlin co-routines will allow us to revisit this decision. (UPDATE) Websockets? Yep - simple, testable, and now available in v3.2.1! See the introductory blog post for details!","title":"Meet http4k"},{"location":"blog/meet_http4k/#server-as-a-function-in-kotlin-typesafe-without-the-server","text":"","title":"Server as a Function. In Kotlin. Typesafe. Without the Server."},{"location":"blog/meet_http4k/#daviddenton","text":"","title":"@daviddenton"},{"location":"blog/meet_http4k/#meet-http4k","text":"http4k is an HTTP toolkit written in Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way. Whenever (yet another) new JVM HTTP framework is released, the inevitable question that rightly get asked is \"How it this different to X?\" . In this post, I'm going to briefly cover what http4k is, how we think it's different, and address some of those bold claims from the title of this post. Here's a quick rundown of what we think those differences are: http4k is small. Written in pure, functional Kotlin, with zero dependencies. http4k is simple. Like, really simple. No static API magic, no annotations, no reflection. http4k is immutable. It relies on an immutable HTTP model, which makes it a snap to test and debug. http4k is symmetric. It supports remote calls as a first-class concern, and the remote HTTP model is identical to the incoming HTTP model. http4k is typesafe. Say goodbye to all your validation and marshalling boilerplate and hello to automatic request validation and data class-based contracts for HTTP bodies using the Lens API. http4k is serverless. Or rather - server independent. Test an app out of container and then deploy it into any supported local container with 1 LOC - or as a function into AWS Lambda.","title":"Meet http4k"},{"location":"blog/meet_http4k/#oh-god-not-another-framework-why-does-this-even-exist","text":"Firstly - we don't consider http4k to be a framework - it's a set of libraries providing a functional toolkit to serve and consume HTTP services, focusing on simple, consistent, and testable APIs. Hence, whilst it does provide support for various APIs relevant to serving and consuming HTTP , it does not provide every integration under the sun - merely simple points to allow those integrations to be hooked in. Another thing to say is that (not very much) of http4k is new - it's rather the distillation of 15 years worth of experience of using various server-side libraries and hence most of the good ideas are stolen. For instance - the routing module is inspired by UtterlyIdle , the basic \"Server as a function\" model is stolen from Finagle , and the contract module OpenApi/Swagger generator is ported from Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the functional features of the language and it felt like a good time to start something from scratch, whilst avoiding the magic that plagues other frameworks. Hence, http4k is primarily designed to be a Kotlin-first library.","title":"Oh god, not another framework! Why does this even exist?!?"},{"location":"blog/meet_http4k/#claim-a-small-simple-immutable","text":"Based on the awesome \"Your Server as a Function\" paper from Twitter, http4k apps are modelled by composing 2 types of simple, independent function.","title":"Claim A: Small, simple, immutable."},{"location":"blog/meet_http4k/#function-1-httphandler","text":"An HttpHandler represents an HTTP endpoint. It's not even an Interface, modelled merely as a Typealias : typealias HttpHandler = ( Request ) - Response Below is a entire http4k application that echoes the request body back in the response. It only relies on the http4k-core module, which itself has zero dependencies: val app = { request : Request - Response ( OK ). body ( request . body ) } val server = app . asServer ( SunHttp ( 8000 )). start () The Request and Response objects in there are immutable data classes/POKOs, so testing the app requires absolutely no extra infrastructure - just call the function, it's as easy as: class AppTest { @Test fun ` echoes request body ` () { assertThat ( app ( Request ( POST , / ). body ( hello )), equalTo ( Response ( OK ). body ( hello ))) } } To plug it into a different Server-backend, just depend on the relevant module (Jetty, Undertow, Netty, Apache (httpcore), Ktor CIO, and SunHttp are available) and change the call to asServer() .","title":"Function 1: HttpHandler"},{"location":"blog/meet_http4k/#function-2-filter","text":"Filters provides pre and post Request processing and are simply: interface Filter : ( HttpHandler ) - HttpHandler For API conciseness and discoverability reasons this is modelled as an Interface and not a Typealias - it also has a couple of Kotlin extension methods to allow you to compose Filters with HttpHandlers and other Filters : val setContentType = Filter { next - { request - next ( request ). header ( Content-Type , text/plain ) } } val repeatBody = Filter { next - { request - next ( request . body ( request . bodyString () + request . bodyString () } } val composedFilter : Filter = repeatBody . then ( setContentType ) val decoratedApp : HttpHandler = composedFilter . then ( app ) Filters are also trivial to test independently, because they are generally just stateless functions.","title":"Function 2: Filter"},{"location":"blog/meet_http4k/#routing","text":"http4k 's nestable routing looks a lot like every other Sinatra-style framework these days, and allows for infinitely nesting HttpHandlers - this just exposes another HttpHandler so you can easily extract, test and reuse sets of routes as easily as you could with one: val app : HttpHandler = routes ( /app bind GET to decoratedApp , /other bind routes ( /delete bind DELETE to { _ : Request - Response ( OK ) }, /post/{name} bind POST to { request : Request - Response ( OK ). body ( you POSTed to ${request.path( name )} ) } ) ) And that it - those functions are everything you need to know to write a simple http4k application. The http4k-core module rocks in at about 700kb, and has zero dependencies (other than the Kotlin language itself). Additionally, everything in the core is functional and predictable - there is no static API magic going on under the covers (making it difficult to have multiple apps in the same JVM), no annotations, no compiler-plugins, and no reflection.","title":"Routing"},{"location":"blog/meet_http4k/#claim-b-symmetric-http","text":"Out of the multitude of JVM http frameworks out there, not many actually consider how you app talks to other services, yet in this Microservice\u2122 world that's an absolutely massive part of what many apps do! As per a core principle behind \"Server as a Function\", http4k provides a symmetric API for HTTP clients - ie. it's exactly the same API as is exposed in http4k server applications - the HttpHandler . Here's that entire API again, just in case you've forgotten: typealias HttpHandler = ( Request ) - Response What does that mean in practice? Well - for one thing, it's less for your brain to learn because you already know the API: val client : HttpHandler = ApacheClient () val response : Response = client ( Request ( GET , http://server/path )) For another, it means that since clients are just function s you can easily stub them for testing, and since applications and clients are interchangeable, they can be plugged together in memory without putting them on the network - which makes testing insanely fast: fun MyApp1 (): HttpHandler = { Response ( OK ) } fun MyApp2 ( app1 : HttpHandler ): HttpHandler = { app1 ( it ) } val app1 : HttpHandler = MyApp1 () val app2 : HttpHandler = MyApp2 ( app1 ) http4k provides a HTTP client adapters for both Apache and OkHttp , all with streaming support.","title":"Claim B. Symmetric HTTP"},{"location":"blog/meet_http4k/#claim-c-typesafe-http-with-lenses","text":"The immutable http4k model for HTTP objects contains all the usual suspect methods for getting values from the messages. For instance, if we are expecting a search parameter with a query containing a page number: val request = Request ( GET , http://server/search?page=123 ) val page : Int = request . query ( page ) !! . toInt ...but we also want to ensure that the expected values are both present and valid, since the above example will fail if either of those things is not true. For this purpose, we can use a Lens to enforce the expected HTTP contract. The use of Lenses in http4k applications can remove the need for writing any parsing or validation code for all incoming data (including Forms), as validations are taken care of by the library.","title":"Claim C. Typesafe HTTP with Lenses"},{"location":"blog/meet_http4k/#lens-basics","text":"A Lens is a bi-directional entity which can be used to either get or set a particular value from/onto an HTTP message. http4k provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional) and the type. For the above example, we could use the Query Lens builder and then invoke() the Lens on the message to extract the target value: val pageLens = Query . int (). required ( page ) val page : Int = pageLens ( Request ( GET , http://server/search?page=123 )) If the query parameter is missing or not an Int, the lens extraction operation will fail. There are similar Lens builder functions for all parts of the HTTP message ( Header , Path , Body , FormField etc..), and functions for all common JVM primitive types. They are all completely typesafe - there is no reflection or magic going on - just marshalling of the various entities (in this case String to Int conversion). In the case of failure, we need to apply a Filter to detect the errors and convert them to a BAD_REQUEST response: val queryName = Query . string (). required ( name ) val app : HttpHandler = routes ( /post bind POST to { request : Request - Response ( OK ). body ( queryName ( request )) } ) val app = ServerFilters . CatchLensFailure . then ( handler )( Request ( GET , /hello/2000-01-01?myCustomType=someValue )) Lenses can also be applied with a correctly typed value (via invoke() ) to set it onto a target object - and as HTTP messages in http4k are immutable, this results in a copy of the modified message: val pageSizeLens = Header . int (). required ( page ) val page : Response = pageLens ( Response ( OK ), 123 ) // or apply multiple lenses using with() val updated : Request = Request ( GET , /foo ). with ( pageLens of 123 , pageSizeLens of 10 ) Securely extracting JDK primitives from HTTP messages is great, but we really want to avoid primitives entirely and go straight to domain types. During construction of Lens, the builders allow mapping to occur so we can leverage Kotlin data classes. This works for both get and set operations: data class MyDate ( val value : LocalDate ) val dateQuery = Query . localDate (). map ( :: MyDate , MyDate :: value ). required ( date ) val myDate : MyDate = dateQuery ( Request ( GET , http://server/search?date=2000-01-01 ))","title":"Lens basics"},{"location":"blog/meet_http4k/#lensing-http-bodies-with-data-classes","text":"Some of the supported message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection (oops - looks like we broke our reflection promise - but technically we're not doing it ;) !). This behaviour is supported in http4k Lenses through the use of the auto() method, which will marshall objects to/from HTTP messages: data class Email ( val value : String ) data class Message ( val subject : String , val from : Email , val to : Email ) val messageLens = Body . auto Message (). toLens () val body = { subject : hello , from :{ value : bob@git . com }, to :{ value : sue@git . com }} val message : Message = messageLens ( Request ( GET , / ). body ( body )) This mechanism works for all incoming and outgoing JSON and XML Requests and Responses. To assist with developing whilst using this type of auto-marshalling, we have created a tool to automatically generate a set of data classes for a given messages.","title":"Lensing HTTP bodies with Data classes"},{"location":"blog/meet_http4k/#claim-d-serverless","text":"Ah yes - Serverless - the latest in the Cool Kids Club and killer fodder for the resume. Well, since http4k is server independent, it turns out to be fairly trivial to deploy full applications to AWS Lambda , and then call them by setting up the API Gateway to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. In order to achieve this, only a single interface AppLoader needs to be implemented - this is responsible for creating the HttpHandler which is adapted to the API of the ApiGatewayProxyRequest/ApiGatewayProxyResponse used by AWS. As this is AWS, there is a fair amount of configuration required to make this possible, but the only http4k specific config is to: Set the function execution to call org.http4k.serverless.lambda.LambdaFunction::handle Set an environment variable for the Lambda HTTP4K_BOOTSTRAP_CLASS to the class of your AppLoader class. Here's a simple example: object TweetEcho : AppLoader { override fun invoke ( env : Map String , String ): HttpHandler = { Response ( OK ). body ( it . bodyString (). take ( 140 )) } } Since http4k is very dependency-light, full binary uploads of these AWS Lambdas tend to be very small - and by utilising Proguard we've seen the size of a Lambda UberJar go as small as 150kb. Introduced in v3.0.0, this support is available in the http4k-serverless-lambda module.","title":"Claim D. Serverless"},{"location":"blog/meet_http4k/#the-final-words","text":"As pointed out above, http4k-core module has zero dependencies. It is also small, even though it also provides: Support for static file-serving with HotReload. A bunch of useful Filters for stuff like Zipkin Request Tracing. Support for Request Contexts. Facilities to record and replay HTTP traffic. There are also a bunch of other modules available, all presented with the same concentration on Testability, API simplicity and consistency: ViewModel driven templating engine support (Handlerbars etc) with HotReload. Popular JSON/XML (Gson, Jackson, Moshi, etc) library support for HTTP bodies. Typesafe HTML Form and Multipart Forms processing, with support for Streaming uploads to a storage service. Forms can also be configured to collect errors instead of just rejecting outright. Typesafe contract module, providing live OpenApi/Swagger documentation. AWS request signing. Resilience4j integration, including Circuit Breakers Rate Limiting. Testing support via Hamkrest matchers and an in-memory WebDriver implementation. Finally, http4k is proven in production , it has been adopted in at least 2 global investment banks and is serving the vast majority of traffic for a major publishing website (in the top 1000 sites globally according to alexa.com - ie. easily serving 10s of million hits per day on a few nodes) since March 2017. You can see a few example applications here , including a bootstrap project for creating a Github - Travis - Heroku CD pipeline in a single command. Well, that's it for this whirlwind tour - we hope you found it worth reading this far! We'd love you to try out http4k and feedback why you love/hate/are indifferent to it :) . And if you want to get involved or chat to the authors, we hang out in the friendly #http4k channel @ slack.kotlinlang,org .","title":"The final word(s)!"},{"location":"blog/meet_http4k/#footnotes","text":"\"But... but... but... asynchronous! And Webscale!\" , I heard them froth . Yes, you are correct - \"Server as a Function\" is based on asynchronous functions and http4k exposes a synchronous API. However, our experience suggests that for the vast majority of apps, this actually makes API integration harder unless you've got async all the way down - and that is assuming that async clients are actually available for all your various remote dependencies. We found that this plainly didn't matter for our use-cases so went for Simple API\u2122 instead... it's possible however that Kotlin co-routines will allow us to revisit this decision. (UPDATE) Websockets? Yep - simple, testable, and now available in v3.2.1! See the introductory blog post for details!","title":"Footnotes"},{"location":"blog/typesafe_configuration/","text":"Add typesafe 12-factor configuration to http4k apps with Environments. @daviddenton Intro This post covers the various concerns around configuring HTTP apps, and introduces the http4k approach for addressing these when deploying applications into cloud-native environments, which leverages the Kotlin type system for maximum safely and code reuse. Concerns when configuring applications One of the tenets of operating applications according to the principles of 12factor , and especially in containerised cloud-native apps, is to inject all app configuration through the use of environmental variables. Additionally, when using more restrictive settings (such as utilising JVM security manager policies or through the use of container images which don't provide an OS baseline) it may not be possible to read files (such as YAML, JSON etc) from disk, which reinforces this approach. There are several particular relevant concerns that we need to address, but overall the effect that we are looking for is that any misconfiguration of the application will result in it failing to startup. For this reason we want to reify all values to check them as soon as possible in the application bootstrap phase. 1. Optionality Kotlin's type system guards us against missing values being injected - for instance the following code will throw a IllegalStateException due to a typo in the parameter name: However not all configuration values will be required. We can define that there are 3 distinct modes of optionality available for each parameter: Required: These values must be injected for each environment, with no default value defined. Most configurations such as hostnames should always use this form to maximise operational safety. Optional: These values can be supplied, but there is no default value. This category fits well with dynamic properties which could be data-driven (ie. not known at compile-time). Defaulted: These values can be supplied, but a fallback value (or chain of other config values) will be used if they are not. Missing values should produce a reasonable error and stop the app from starting. 2. Type coercion Most applications will require a variety of configuration primitive types, which may or may not map to the Java/Kotlin standard types, including: strings such as service URLs, log levels, or AWS role names numeric values such as ports or retry counts booleans such as debug switch or feature flags duration values for timeouts, backoff times But handling these raw types alone is not enough to guarantee safety - it is best to marshall the values into a suitable operational/domain type that can validate the input and avoid confusion. Kotlin gives us a simple way to do this using require as a guard: Additionally to the above, it is important to represent those values in a form that cannot be misinterpreted. A good example of this is the passing of temporal values as integers - timeouts defined this way could be easily be parsed into the wrong time unit (seconds instead of milliseconds). Using a higher level primitive such as Duration will help us here: Obviously, the above is still not very safe - and what's more, a coercion could now fail with one of 3 different exceptions depending on if the value was missing ( IllegalStateException ), unparsable ( DateTimeParseException ) or invalid ( IllegalArgumentException ). The conversion code from String - Duration must also be repeated (or extracted) for each value that we wish to parse. 3. Multiplicity Configuration parameters may have one or many values and need to be converted safely from the injected string representation (usually comma-separated) and into their internally represented types at application startup: Once again, the splitting code will need to be repeated for each config value, or extracted to a library function. 4. Security The configuration of a standard app will generally contain both sensitive and non-sensitive values. Sensitive such as application secrets, DB passwords or API keys should be handled in a way that avoid storing directly in memory in a readable format or long lived fashion, where they may be inadvertently inspected or outputted into a log file. Dangling code situations such as in the code below are common, and are asking for trouble... 5. Configuration Context Overriding We also want to avoid defining all values for all possible scenarios - for example in test cases, so the ability to overlay configuration sets on top of each other is useful. Although it is against the rules of 12-factor, it is sometimes convenient to source parameter values from a variety of contexts when running applications in non-cloud environments: System Environment variables Properties files JAR resources Local files Source code defined environmental configuration Implementing this kind of fallback logic manually, you'd end up with code like the below: The http4k approach... There are already many options for configurational libraries written in Kotlin, but http4k also provides an option in the http4k-cloudnative add-on module which leverages the power of the Lens system already built into the core library to provide a consistent experience to API users. In case you're new to Lenses, here's a recap... Lenses - a recap In http4k , Lenses are typically used to provide typesafe conversion of typed values into and out of HTTP messages, although this concept has been extended within the http4k ecosystem to support that of a form handling and request contexts. A Lens is an stateless object responsible for either the one-way (or Bidirectional) transformation of It defines type parameters representing input IN and output OUT types and implements one (for a Lens ) or both (for a BiDiLens ) of the following interfaces: LensExtractor - takes a value of type IN and extracts a value of type OUT LensInjector - takes a value of type IN and a value of type OUT and returns a modified value of type IN with the value injected into it. The creation of a Lens consists of 4 main concerns: targeting determines where the Lens expects to extract and inject the values from/to, which can consist of both an overall target and a name within that target. multiplicity handling which defines how many of a particular value we are attempting to handle. the transformation chain of function composition which forms a specification for converting one type to another. This is done in code using the map() method defined on the Lens. the optionality of a Lens denotes the behaviour if/when a value cannot be found in the target. To define a Lens instance through the http4k Lens API, we take an initial target specification, decide it's multiplicity , provide any transformations with map() , and finally reify the specification into a Lens instance by deciding it's optionality. It sounds involved, but it is consistent and the fluent API has been designed to make it simpler. By way of an example, here we define a bi-directional Lens for custom type Page , extracted from a querystring value and defaulting to Page 1. In http4k , Lenses are typically used to provide typesafe conversion of typed values into and out of HTTP messages, although this concept has been extended within the http4k ecosystem to support that of a form handling and request contexts. http4k Environments in http4k , an Environment object is a context which holds configuration values. It effectively behaves like a Map , in that it can be composed with other Environment objects to provide a consolidated view of all of it's component values. If you're using any of the other Kotlin-based configuration libraries, the above should look pretty familiar. The difference starts to become apparent when attempting to retrieve values from the Environment instance. This is done using EnviromentKey Lenses, which are an extension of the http4k Lens system that specifically targets Environment objects. Handling failure When using the http4k Environment to define config, missing or values which cannot be deserialised all now cause a LensFailure to be thrown with a descriptive error message. As before, this results in the application failing to start, but as the exception if both consistent and explicit, diagnosing the problem becomes much simpler. Extra primitives Timeout, Host, Port Single-shot Secrets In order to avoid the accidental exposure of secrets into the application runtime, a new type Secret has been introduced, which tries as much as possible to avoid exposing it's internal value as a readable String . The Secret class is designed to only have it's value read once, and only within a specific use() block, after which the underlying value is internally overwritten. As with other primitives, Secret is available by default.","title":"http4k blog: Add typesafe 12-factor configuration to http4k apps with Environments."},{"location":"blog/typesafe_configuration/#add-typesafe-12-factor-configuration-to-http4k-apps-with-environments","text":"","title":"Add typesafe 12-factor configuration to http4k apps with Environments."},{"location":"blog/typesafe_configuration/#daviddenton","text":"","title":"@daviddenton"},{"location":"blog/typesafe_configuration/#intro","text":"This post covers the various concerns around configuring HTTP apps, and introduces the http4k approach for addressing these when deploying applications into cloud-native environments, which leverages the Kotlin type system for maximum safely and code reuse.","title":"Intro"},{"location":"blog/typesafe_configuration/#concerns-when-configuring-applications","text":"One of the tenets of operating applications according to the principles of 12factor , and especially in containerised cloud-native apps, is to inject all app configuration through the use of environmental variables. Additionally, when using more restrictive settings (such as utilising JVM security manager policies or through the use of container images which don't provide an OS baseline) it may not be possible to read files (such as YAML, JSON etc) from disk, which reinforces this approach. There are several particular relevant concerns that we need to address, but overall the effect that we are looking for is that any misconfiguration of the application will result in it failing to startup. For this reason we want to reify all values to check them as soon as possible in the application bootstrap phase.","title":"Concerns when configuring applications"},{"location":"blog/typesafe_configuration/#1-optionality","text":"Kotlin's type system guards us against missing values being injected - for instance the following code will throw a IllegalStateException due to a typo in the parameter name: However not all configuration values will be required. We can define that there are 3 distinct modes of optionality available for each parameter: Required: These values must be injected for each environment, with no default value defined. Most configurations such as hostnames should always use this form to maximise operational safety. Optional: These values can be supplied, but there is no default value. This category fits well with dynamic properties which could be data-driven (ie. not known at compile-time). Defaulted: These values can be supplied, but a fallback value (or chain of other config values) will be used if they are not. Missing values should produce a reasonable error and stop the app from starting.","title":"1. Optionality"},{"location":"blog/typesafe_configuration/#2-type-coercion","text":"Most applications will require a variety of configuration primitive types, which may or may not map to the Java/Kotlin standard types, including: strings such as service URLs, log levels, or AWS role names numeric values such as ports or retry counts booleans such as debug switch or feature flags duration values for timeouts, backoff times But handling these raw types alone is not enough to guarantee safety - it is best to marshall the values into a suitable operational/domain type that can validate the input and avoid confusion. Kotlin gives us a simple way to do this using require as a guard: Additionally to the above, it is important to represent those values in a form that cannot be misinterpreted. A good example of this is the passing of temporal values as integers - timeouts defined this way could be easily be parsed into the wrong time unit (seconds instead of milliseconds). Using a higher level primitive such as Duration will help us here: Obviously, the above is still not very safe - and what's more, a coercion could now fail with one of 3 different exceptions depending on if the value was missing ( IllegalStateException ), unparsable ( DateTimeParseException ) or invalid ( IllegalArgumentException ). The conversion code from String - Duration must also be repeated (or extracted) for each value that we wish to parse.","title":"2. Type coercion"},{"location":"blog/typesafe_configuration/#3-multiplicity","text":"Configuration parameters may have one or many values and need to be converted safely from the injected string representation (usually comma-separated) and into their internally represented types at application startup: Once again, the splitting code will need to be repeated for each config value, or extracted to a library function.","title":"3. Multiplicity"},{"location":"blog/typesafe_configuration/#4-security","text":"The configuration of a standard app will generally contain both sensitive and non-sensitive values. Sensitive such as application secrets, DB passwords or API keys should be handled in a way that avoid storing directly in memory in a readable format or long lived fashion, where they may be inadvertently inspected or outputted into a log file. Dangling code situations such as in the code below are common, and are asking for trouble...","title":"4. Security"},{"location":"blog/typesafe_configuration/#5-configuration-context-overriding","text":"We also want to avoid defining all values for all possible scenarios - for example in test cases, so the ability to overlay configuration sets on top of each other is useful. Although it is against the rules of 12-factor, it is sometimes convenient to source parameter values from a variety of contexts when running applications in non-cloud environments: System Environment variables Properties files JAR resources Local files Source code defined environmental configuration Implementing this kind of fallback logic manually, you'd end up with code like the below:","title":"5. Configuration Context &amp; Overriding"},{"location":"blog/typesafe_configuration/#the-http4k-approach","text":"There are already many options for configurational libraries written in Kotlin, but http4k also provides an option in the http4k-cloudnative add-on module which leverages the power of the Lens system already built into the core library to provide a consistent experience to API users. In case you're new to Lenses, here's a recap...","title":"The http4k approach..."},{"location":"blog/typesafe_configuration/#lenses-a-recap","text":"In http4k , Lenses are typically used to provide typesafe conversion of typed values into and out of HTTP messages, although this concept has been extended within the http4k ecosystem to support that of a form handling and request contexts. A Lens is an stateless object responsible for either the one-way (or Bidirectional) transformation of It defines type parameters representing input IN and output OUT types and implements one (for a Lens ) or both (for a BiDiLens ) of the following interfaces: LensExtractor - takes a value of type IN and extracts a value of type OUT LensInjector - takes a value of type IN and a value of type OUT and returns a modified value of type IN with the value injected into it. The creation of a Lens consists of 4 main concerns: targeting determines where the Lens expects to extract and inject the values from/to, which can consist of both an overall target and a name within that target. multiplicity handling which defines how many of a particular value we are attempting to handle. the transformation chain of function composition which forms a specification for converting one type to another. This is done in code using the map() method defined on the Lens. the optionality of a Lens denotes the behaviour if/when a value cannot be found in the target. To define a Lens instance through the http4k Lens API, we take an initial target specification, decide it's multiplicity , provide any transformations with map() , and finally reify the specification into a Lens instance by deciding it's optionality. It sounds involved, but it is consistent and the fluent API has been designed to make it simpler. By way of an example, here we define a bi-directional Lens for custom type Page , extracted from a querystring value and defaulting to Page 1. In http4k , Lenses are typically used to provide typesafe conversion of typed values into and out of HTTP messages, although this concept has been extended within the http4k ecosystem to support that of a form handling and request contexts.","title":"Lenses - a recap"},{"location":"blog/typesafe_configuration/#http4k-environments","text":"in http4k , an Environment object is a context which holds configuration values. It effectively behaves like a Map , in that it can be composed with other Environment objects to provide a consolidated view of all of it's component values. If you're using any of the other Kotlin-based configuration libraries, the above should look pretty familiar. The difference starts to become apparent when attempting to retrieve values from the Environment instance. This is done using EnviromentKey Lenses, which are an extension of the http4k Lens system that specifically targets Environment objects.","title":"http4k Environments"},{"location":"blog/typesafe_configuration/#handling-failure","text":"When using the http4k Environment to define config, missing or values which cannot be deserialised all now cause a LensFailure to be thrown with a descriptive error message. As before, this results in the application failing to start, but as the exception if both consistent and explicit, diagnosing the problem becomes much simpler.","title":"Handling failure"},{"location":"blog/typesafe_configuration/#extra-primitives","text":"Timeout, Host, Port","title":"Extra primitives"},{"location":"blog/typesafe_configuration/#single-shot-secrets","text":"In order to avoid the accidental exposure of secrets into the application runtime, a new type Secret has been introduced, which tries as much as possible to avoid exposing it's internal value as a readable String . The Secret class is designed to only have it's value read once, and only within a specific use() block, after which the underlying value is internally overwritten. As with other primitives, Secret is available by default.","title":"Single-shot Secrets"},{"location":"blog/typesafe_websockets/","text":"Websockets. But typesafe. And testable. Without the Server. @daviddenton Reaction to the last post introducing http4k was pretty good, and one of the most popular questions was: \"But what about Websockets\" ? The answer to that question at the time was an emphatic \"Not yet\" - because they didn't fit the \"Server as a Function\" model, and the team hadn't worked out a way to deliver them in a simple, offline testable way. Well, a month is a long time, and we've been beavering away, so now we're thrilled to release Websockets for http4k , which are: Simple : using the same style of API as the rest of http4k , allowing the same dynamic path-based routing as is available for standard HttpHandlers . Typesafe : Marshall and unmarshall typed objects from Websocket Messages using the established Lens API. Testable : This is something that is massively important to us - and just like standard HttpHandlers, http4k Websockets are completely testable in a synchronous online or offline environment. No. Server. Required. Details schmeetails... Just as with HttpHandlers, the here are 2 basic function types which make up the core of the Websocket routing API: A WsHandler - represented as a typealias: (Request) - WsConsumer? . This is responsible for matching an incoming HTTP upgrade request to a websocket. WsConsumer - represented as a typealias: (WebSocket) - Unit . This function is called on connection and allow the API user to react to events coming from the connected Websocket by attaching listeners. Additionally, WsMessage objects are used for actual communication - ie. a message which is sent or received on a Websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. And just like the http4k HTTP message model, WsMessages are immutable data classes . An example server The example below shows how: Websockets can be dynamically routed Lens-based marshalling of Websocket message objects using Jackson. WsHandler can be combined with an HttpHandler to make a PolyHandler - an application which can serve many protocols. Conversion of the PolyHandler to a supporting Server can be done via the standard asServer() mechanism, or it can be kept offline for ultra-fast in-memory testing: Alternatively, you can check out the Websocket enabled http4k demo: IRC clone in 30 lines of Kotlin . Testability As well as API simplicity, the http4k team are very passionate about testing, and it was very important that this could be done in an out-of-container fashion - ie. in memory and with no server being started. As such, it is possible to call testWsClient() on an WsHandler to provide a synchronous API for testing. Messages and other events can be \"sent\" to a connected websocket and responses will be received back in a completely predictable way from the application under test. In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. http4k provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic: Fin Websocket support is now available for the Jetty server backend in http4k v3.2.0 . We plan to roll out support for other server-backends in due course. Have a play a let us know what you think... Footnotes We had a bit of a search for \"unit testing websockets\", half through curiosity and half because we wanted to swipe other people's ideas for implementing it. But we came up with nothing - it seems like all the existing JVM HTTP libraries rely on running servers for testing websockets. We hope we're wrong - because the alternative makes us a little insert sadface emoji/ . If we are, then please let us know! \ud83d\ude1d","title":"Typesafe Websockets"},{"location":"blog/typesafe_websockets/#websockets-but-typesafe-and-testable-without-the-server","text":"","title":"Websockets. But typesafe. And testable. Without the Server."},{"location":"blog/typesafe_websockets/#daviddenton","text":"Reaction to the last post introducing http4k was pretty good, and one of the most popular questions was: \"But what about Websockets\" ? The answer to that question at the time was an emphatic \"Not yet\" - because they didn't fit the \"Server as a Function\" model, and the team hadn't worked out a way to deliver them in a simple, offline testable way. Well, a month is a long time, and we've been beavering away, so now we're thrilled to release Websockets for http4k , which are: Simple : using the same style of API as the rest of http4k , allowing the same dynamic path-based routing as is available for standard HttpHandlers . Typesafe : Marshall and unmarshall typed objects from Websocket Messages using the established Lens API. Testable : This is something that is massively important to us - and just like standard HttpHandlers, http4k Websockets are completely testable in a synchronous online or offline environment. No. Server. Required.","title":"@daviddenton"},{"location":"blog/typesafe_websockets/#details-schmeetails","text":"Just as with HttpHandlers, the here are 2 basic function types which make up the core of the Websocket routing API: A WsHandler - represented as a typealias: (Request) - WsConsumer? . This is responsible for matching an incoming HTTP upgrade request to a websocket. WsConsumer - represented as a typealias: (WebSocket) - Unit . This function is called on connection and allow the API user to react to events coming from the connected Websocket by attaching listeners. Additionally, WsMessage objects are used for actual communication - ie. a message which is sent or received on a Websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. And just like the http4k HTTP message model, WsMessages are immutable data classes .","title":"Details schmeetails..."},{"location":"blog/typesafe_websockets/#an-example-server","text":"The example below shows how: Websockets can be dynamically routed Lens-based marshalling of Websocket message objects using Jackson. WsHandler can be combined with an HttpHandler to make a PolyHandler - an application which can serve many protocols. Conversion of the PolyHandler to a supporting Server can be done via the standard asServer() mechanism, or it can be kept offline for ultra-fast in-memory testing: Alternatively, you can check out the Websocket enabled http4k demo: IRC clone in 30 lines of Kotlin .","title":"An example server "},{"location":"blog/typesafe_websockets/#testability","text":"As well as API simplicity, the http4k team are very passionate about testing, and it was very important that this could be done in an out-of-container fashion - ie. in memory and with no server being started. As such, it is possible to call testWsClient() on an WsHandler to provide a synchronous API for testing. Messages and other events can be \"sent\" to a connected websocket and responses will be received back in a completely predictable way from the application under test. In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. http4k provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic:","title":"Testability "},{"location":"blog/typesafe_websockets/#fin","text":"Websocket support is now available for the Jetty server backend in http4k v3.2.0 . We plan to roll out support for other server-backends in due course. Have a play a let us know what you think...","title":"Fin"},{"location":"blog/typesafe_websockets/#footnotes","text":"We had a bit of a search for \"unit testing websockets\", half through curiosity and half because we wanted to swipe other people's ideas for implementing it. But we came up with nothing - it seems like all the existing JVM HTTP libraries rely on running servers for testing websockets. We hope we're wrong - because the alternative makes us a little insert sadface emoji/ . If we are, then please let us know! \ud83d\ude1d","title":"Footnotes"},{"location":"changelog/","text":"Changelog This list is not currently intended to be all-encompassing - it will document major and breaking API changes with their rationale when appropriate: v3.114.0 (uncut) (Possible Break): Fix #215 - LensFailure does not always include target object. Only change to the API is that IN generic in Lenses is now bounded by IN : Any . This fix is a actually internally consistent as we could not always include the target otherwise (which is an Any? ). Trim leading and trailing whitespace from extracted EnvironmentKey values. Secret value is now only usable once via the use() function. Removed deprecations v3.113.0 Added some common types for Environmental setup, and equivalent BiDiLens mappings Handle null response in Java Http client. H/T @FredNordin v3.112.2 Fix #212 - allow null values in HTTP contract definitions. This does mean we lose the type definition for that field, but we don't blow up silently (which was the previous behaviour). H/T @xhanin v3.112.1 Re-add Path.nonEmptyString() which was accidentally removed. v3.112.0 Add support for prohibiting String unmarshalling in JSON auto-marshalling configuration. HTTP Contracts now use the underlying ContractRenderer to produce the BadRequest and NotFound responses. Made OpenAPI open so that these responses can be customised. v3.111.0 Add support for JSON views in Jackson module. H/T @xhanin for the donkey work. v3.110.0 Breaking: slight rearrangement of RouteMeta receiving/returning methods to provide consistency when defining route contracts. v3.109.0 Moved the set of predefined String BiDiMapping instances to their own class. Bulked out the auto-mapping configuration options. v3.108.0 Upgrade to various deps. Extracted out new BiDiMapping type, which encapsulates string - type conversions and removes a boatload of duplications. These conversions are now used consistently across all the various places (Lenses, auto-mapping). Improved configurability of AutoMarshallingJson instances. v3.107.0 Upgrade to various deps. Fix #208 - Xml auto deserialisation incorrectly converting strings to numbers v3.106.1 Fix #207 - repeating prefixes in static routes are not handled correctly. H/T @ruXlab for the PR to fix. v3.106.0 Add http4k-server-ktorcio server backend. Note that whilst this module does allow http4k apps to plug into the Ktor-CIO engine, it does not provide fully front-to-back coroutine support. v3.105.0 Preventing FallbackCacheControl from duplicating existing headers. H/T @leandronunes85 Breaking: Make Body.length nullable instead of throwing exception when value is not available. H/T @zvozin v3.104.0 Upgrade to various deps. Add session token support to AWS filter, and \"credentials provider\" to allow for rotating AWS sessions. H/T @dhobbs. Breaking: Moved WsClient from org.http4k.testing to org.http4k.websocket . v3.103.2 Fix access-control-allow-origin returned when server supports multiple origins H/T @johnnorris v3.103.1 (Properly) Fix #198 - Rewrote OpenApi contract to ensure it stays fixed. H/T @reik-wargaming for the help in tracking this down. v3.103.0 \"Fix\" #198 - Breaking change made in http4k-contracts to clarify/deconfuse API. Hid body parameter in contract route meta DSL - it is now receiving() . Upgraded some dependencies, including Gradle to v5.0. Breaking: Resilience4j dependency upgrade causes a break when providing custom config. Simply insert the Config type generic to fix: e.g. RetryConfig.custom() - RetryConfig.custom RetryConfig () v3.102.1 Fix #197 - Swagger spec for form fields had incorrect description. v3.102.0 Introduce interface for Environment v3.101.0 Upgrades to dependencies Improved Client-side HTTP status descriptions Lenses now support Durations out of the box Environments now support multi-value keys (comma separated) v3.100.0 Make Undertow API friendlier Fix to JsonReadinessCheckResultRenderer to actually implement the correct interface v3.99.0 Enhancement of http4k-cloudnative - now supports extra-health check routes, and provide way to load app configuration via Properties files. v3.98.0 Add filter allowing Gzipping based on an allowed set of content types. H/T @jshiell Change HttpHandler extending HttpClients to use object invoke() mechanism, as the individual clients have no visible API surface of their own. Introduced DualSyncAsyncHttpHandler interface. v3.97.0 Webdriver checkbox handling improved. H/T @gypsydave5 upgrade to various versions v3.96.0 upgrade to Kotlin 1.3.0 v3.95.1 Tweak to K8S port variables. v3.95.0 (Unlikely break): Change Http4kServer interface to return Unit from stop() . This affects all server implementations. Added DSL function for working with JSON objects (scopes JSON as this ). fun T Json NODE .invoke(Json NODE .() - T) New module http4k-cloudnative contains classes to help run http4k services inside cloud-native environments, including K8S. Upgrade some dependencies Deprecation: Moved Header.Common fields to main Header object. Extension properties should go there now. v3.94.1 Use UTC when checking cookie expiry v3.94.0 Deprecate String.toBody() Fix checkbox behaviour in webdriver ~v3.39.4~ v3.93.4 Use Jetty latest release version (rather than RC one) v3.39.3 Fix #189 - Uri toString now omits leading slash if the authority of a Uri is blank. This could be a potential break, but is actually more consistent as a Uri can currently be relative or absolute. v3.39.2 Extend SetBaseUriFrom to support query parameters v3.39.1 Added SetBaseUriFrom filter v3.39.0 (Possible breaking change): Json is now only generified by a single type parameter instead of 2. For most usages, this type would have been identical anyway, but the upgrade of Argo has finally allowed the removal of this dead generic. Simply replace Json Node, Node with Json Node . Added Offset datetime types to all JSON auto-marshalling libraries Build logic for versioning is now in Kotlin. H/T @jmfayard for the PR Upgrade Kotlin, and various other dependencies v3.38.1 Fix withChaosControls URL pattern so that it matches sub-routes ok on original handler v3.38.0 Added BearerAuth and BasicAuth implementations which populate RequestContexts . Plus cookbook example :) v3.37.1 Fix #177 - Make RequestContexts thread-safe. v3.37.0 Upgrades to http4k-testing-webdriver . H/T @dickon for the PRs Added ProxyHost request filter which is useful for writing proxy-type apps. v3.36.1 Fix #168 - Fix rest of hamkrest matchers caused by generics mishap. Upgrade HTTP client dependency versions. v3.36.0 Added http4k-testing-chaos module, designed to enhance failure-mode testing for http4k apps. Massive H/T to @IgorPerikov for the PR which drove this module's creation. Added http4k-incubator module, for hosting developing projects and other code which might be promoted to top-level modules in the future. v3.35.2 Fix #167 - Reintroduce hasBody compatibility with common matchers such as containsString() Remove deprecations. v3.35.1 Fix #165 - AWS auth filter does not replace headers - it sets them (which breaks for request signing) Fix #164 - Webdriver internal state breaks when navigating to a full URL Fix #162 - SetHostFrom doesn't set 'Host' header correctly (missing port). H/T @elifarley v3.35.0 Added some regex matchers to http4k-testing-hamkrest . Added BearerAuth authentication Server and Client Filters - these work similarly to BasicAuth . Added option for defaulted() lenses to fall back to another supplied lens in the case of missing value. Thanks to @dmcg for the inspiration. :) v3.34.3 Fix #160 - JavaHttpClient does not copy body stream correctly onto URL connection. v3.34.2 Fix #159 - Contracts should not have Security applied to the description route by default. v3.34.1 Fix #158 - Static and contract routes filters are applied in the wrong order. v3.34.0 Add default SamplingDecision param to ZipkinTraces - defaults to always sample. Fix #150 - StaticRoutingHandler filters being called twice. Fix #151 - POTENTIAL BREAK: Rework of Status objects to fix equality against the Status constant vals when a description has been overridden. This involves the following potential breaking change: The Status class is no longer a data class to tighten up encapsulation - user calls to copy() will have to be replaced. v3.33.2 Raise SO_BACKLOG in Apache and Netty server implementations. Add PERMANENT_REDIRECT and UNPROCESSABLE_ENTITY Status object. v3.33.1 No change from 3.33.0. Previous version couldn't be made available to maven central. v3.33.0 Add convenient way to extract from as a Map from http message. H/T to @dmcg (this version is available in jcenter only) v3.32.1 Fix #142 - Pebble templates don't load from JAR files. v3.32.0 Add support for propagation of the Zipkin x-b3-sampled header v3.31.0 Changes to the Netty factory to enable running http4k on GraalVM. H/T @RichyHBM v3.30.0 Allow all server implementations to start on port 0 (ie. find a free port) and then report it back as a part of the Http4kServer interface v3.29.0 Make HTTP clients resilient to unknown host and connectionrefused exceptions Implememted #134 - Added default (de)serialization for common JDK primitives to all Auto-marshalling JSON modules - eg. datetimes and UUIDs v3.28.0 Fix #131 - Uri's created with paths that don't contain leading slashes. Added etag parser filter. H/T @dgliosca for the PR Fix #132 - Ensured that disableDefaultTyping is called in default Jackson implementation. This should be the default anyway, but has been added to ensure that we don't fall foul of CVE-2017-7525 and to surface awareness of this issue. v3.27.0 OpenAPI now provides example values in the generated schema. H/T @skewwhiffy for the PR. v3.26.6 Fix #126 - ResourceLoadingHandler can expose mapped resources into the root. -- We think this is an important update, so please upgrade! v3.26.5 Fix #125 - ApacheServer implementation now sets content length if present. v3.26.4 Fix #123 - Multipart Body objects blow up when parsed after being debugged. As with all streams, care should be taken to not blow heap when internalising them for debugging purposes. v3.26.3 Debugging filter now supports ignoring Multipart streams. v3.26.2 Tweak: OpenAPI now doesn't return null values in the schema. v3.26.1 Fix #124 - headers in WebSocket upgrade request are incorrectly joined. v3.26.0 Removed supportedContentTypes field from OpenApi contract JSON, since this is a legacy field. v3.25.0 Added option to Undertow to enable HTTP2 from main ServerConfig v3.24.0 Upgrade various dependencies for Java 10 compatibility. H/T @tom Fix bug with repeated params in Websocket upgrade request. H/T @tom v3.23.1 Composite LensFailures now capture (at least) the first failing cause (probably the body parameter in the case of an http4k-contract module. v3.23.0 Fix #116 - Can provide a custom Response creation method for CatchLensFailure . H/T @elifarley for the inspiration! v3.22.4 Added singleton method for Json.array, since if you pass in a single JsonNode (Jackson), it accidentally iterates over the fields in the node instead of using the object as an entry in the array. Fix #115 - Only add content-length for methods that allow content in AwsAuth filter v3.22.3 Preserve routing information on request/response manipulation v3.22.2 http4k-security-oauth module added - with support for OAuth2 Authorization Grant flow Replaced classes reliant on javax.activation package, which allows Java 9+ to not require any external dependencies. \\o/ Fix #112 - ApacheClient incorrectly sets headers on GET requests (this breaks F5 load balancers). H/T @simojenki PR #110 - Websocket client timeouts are incorrectly translated as seconds instead of millis. HT @anorth Core JavaHttpClient does not support streaming due to limitations with HttpURLConnection v3.21.1 Fix #109 - Jackson treats integer values inconsistently, leading to matching errors when using hamkrest. v3.21.0 Fix #107 - Killed the x-uri-template header and fixed the ReportHttpTransaction to have access to the routingGroup . Altered ordering of filters in http4k-contract so that the route is identified before pre-filters and security are applied. This allows knowledge of the path to be accessible at the time of application of those filters. v3.20.0 Introduce JavaHttpClient to http4k-core . It provides a very basic http client without any other 3rd party dependencies. v3.19.0 PR #104 - Add optional time/date formatters to LensSpecs so you can choose you serialisation format. H/T @elifarley Fix #105 - Swagger API json file: duplicate key in \"definitions\". v3.18.1 Fixed PR #100 - URI template regex required extra escaping. This only affects Android deployments as IDE shows the regex escaping is redundant. H/T @privatwolke v3.18.0 Breaking: converted contract pre-security filter to be a post-security filter. This means that all standard filters are applied before the security later, which allows for logging and monitoring and context setup. The previous filter mechanic applied security first, which didn't allow for this. In the unlikely event that post-security filters still need to be applied, use the withPostSecurityFilter() function when building the contract. Docs for contract RouteMeta function parameters, and deprecated some unused functions (missed when we introduced the DSL). PR #99 - Contract routes now support up to 10 path segments. Thanks to @scap1784 for the PR! :) v3.17.1 Fix #97. Moshi does not fail when deserialise non-nullable fields correctly. Note that GSON still suffers from this problem v3.17.0 Added a pre-security filter option to contract creation, so that you can explicitly specify behaviour to occur before security kicks in. v3.16.0 Convert Security (from sealed class) and ApiKey to be interfaces. This allows users to implement their own security models. v3.15.0 Introduce HttpTransaction and new ReportHttpTransaction filter provide better generic API for reporting, along with the ability to label transactions for this purpose. Breaking: Rework the metrics request counter and timer Filter API. There is now a HttpTransactionLabeller for you to add as many labels as required to the transaction. Each of these labels will be used to tag the metric. v3.14.1 Fix #95 - Filters are now applied to \"route not found\" responses v3.14.0 Fix #93 - Apache server doesn't like content-length or transfer-encoding headers present in http4k response. Add ability to \"name\" input and output contract body definitions in an OpenAPI JSON doc. This applies to only the top level entity. If no override is passed, the objects are named according to their hashcode. 3.13.4 Fix #92 - cookie date should always use US locale v3.13.3 Further tweak to Netty. H/T @FredDeschenes v3.13.2 Fix #91 - large message handli ng in Netty v3.13.1 Upgrade to Kotlin 1.2.20 v3.13.0 Support for operationId in OpenApi route metadata. H/T @danschultz for the PR. Removed previously deprecated methods. v3.12.0 New client module http4k-client-jetty , which supports both sync and async models. v3.11.1 Fix #84. OPTIONS requests are not detected by contract routes. Added option to NOT authorise OPTIONS requests in ApiKey security filter. Added support for Async HTTP clients and added new AsyncHttpClient interface, which is obviously used for HTTP clients only**, and not server-side calls. :) New client module http4k-client-apache-async . New metrics gathering module http4k-metrics-micrometer . Big H/T to @kirderf for the PR. Added support for async to OkHttp client module. v3.10.0 P/R 81 - adding headers and timeout to websocket client. v3.9.0 Added compactify and prettify to Json implementations Added Json.hasBody Hamkrest matchers for comparing bodies. Note these are extension methods and need to be referenced/imported as such. v3.8.0 Added facility for non-blocking websocket client to react to onConnect event. This API is the same as the inbound, server-side API - ie. there are no explicit connection event handlers. H/T @tom for the idea. v3.7.0 P/R #13 Create extension methods for Response to add caching headers. H/T @k0zakinio. v3.6.1 Fix #78. Serialisation of raw lists using Moshi fails in the same way as the Jackson auto-conversions do. Added convenience methods to get around this. v3.6.0 Added http4k-format-moshi to support the Square auto-marshalling library. v3.5.1 Fix #76 - encoding of path segments to use URI encoding instead of URL form encoding. v3.5.0 Added support for multiple HotReload template directories in HandlebarsTemplates . H/T @TomShacham Fix #74 - Request tracing span/parentSpan set too early so was shared between outgoing requests. v3.4.0 New server backend http4k-server-apache . H/T @kirderf for the PR :) We now set the length of the incoming request body when it is available in the incoming request. v3.3.1 Handlebars now uses combination of Class and Template name to cache templates. v3.3.0 Facility to compose TemplateRenderers with then() to provide fallback behaviour. v3.2.3 PR #70: Header order equality for Request/Response - H/T @gypsydave5. v3.2.2 Switched out Status for WsStatus (with proper RFC code set) in Websockets. v3.2.1 Typesafe Websockets! Jetty now supports websockets, using the same style of API in the main http4k routing. (Possible) Breaking change: Because WsHandler (typealias) implements the same inbound interface as HttpHandler , you now cannot declare HttpHandlers without specifying the input type, so any \"anonymous\" handlers will not compile as a result. The required fix is very simple, but manual: `{ Response(OK) } should become { _:Request - Response(OK) } v3.1.3 Fix Request.form() for streaming requests v3.1.2 Remove possibility of empty message for Path Lens failure. v3.1.1 New (better!) API for http4k-contract module. Old meta DSL has been deprecated. v3.0.1 Fix #63 - Apache Client Connect. timeout exception handling. v3.0.0 Added http4k-serverless-lambda module, allowing http4k applications to be deployed into AWS Lambda and then called from API Gateway. Effectively, the combination of these two services become just another Server back-end supported by the library. \\o/ v2.38.1 RequestContextKey now follow the standardised Lens structure of required, optional, defaulted, and can now be removed (set to null). Replace calls to RequestContextKey.of() with RequestContextKey.required() Removed previously deprecated values. See below for details on replacements. v2.37.0 Added http4k-resilience4j module, which adds Circuits, RateLimiters, Retrying and Bulkheading. Fix #60 (H/T @michaelhixson for the spot). v2.36.0 Added a couple of useful ServerFilters . Upgrade various dependency versions. Tidying of Multipart code. v2.35.1 Fix #57. Static handlers behave oddly when combined with an HTTP verb in the routing tree. v2.35.0 Fix #56. Altered behaviour of CatchLensFailure to NOT catch errors from unmarshalling Response objects. This was causing BAD_REQUEST to be incorrectly generated. Simplification of generics around LensSpecs. This should not be a breaking change, (there were 3 generics, now the MID has been removed so there are just 2) but could break if signatures are used explicitly. v2.34.0 Reordered generics in LensInjector to make sense. This should have no effect on most code-bases, but could break if signatures are used explicitly. Just flip the generic types to switch. v2.33.1 Added support for unsigned AWS requests, which enables streaming content to S3. v2.33.0 Added BodyMode.Request to configure streaming for clients. ResponseBodyMode is now BodyMode.Response (Breaking change. Fixable with simple find/replace). v2.32.0 Added ServerFilter.ProcessFiles filter to stream Multipart Files, convert them into references and replace inline in the Form. v2.31.4 Avoid realising StreamBody unless necessary, which could break common usages of streaming. v2.31.3 Tweaks to Server backends to improve efficiency. v2.31.2 Webdriver will keep only the final URI after redirects. v2.31.1 Increased granularity of Replay.DiskStream and ensure that traffic is returned in exact order on all OSes. Add support for redirects to Webdriver. v2.31.0 Multipart module tweaked to provide a more consistent API. Fix FollowRedirects for POST/PUT request. v2.30.0 Multipart form support through new module http4k-multipart . Deprecation: Replaced Swagger with OpenApi and deprecated the former (via typealias). Deprecation: Replaced FormValidator with Validator and deprecated the former (via typealias). v2.29.4 Refactor release. v2.29.3 Fix #50 - Webdriver does not normalise relative links correctly. v2.29.2 Http client modules now catch and convert Socket Timeout exceptions to HTTP 504s (with a custom message) v2.29.1 Tweaks to how recorded traffic is stored on disk. Thanks to @dkandalov for the PR around this. v2.29.0 Added TrafficFilters for recording and replaying HTTP traffic. See org.http4k.traffic package for details. v2.28.0 Added http4k-template-dust for Dust template engine support. Thanks to @npryce for the PR to add this. v2.27.2 Fix #44 - Use quotes around cookie values v2.27.1 Raise proper Exception (instead of LensFailure) when RequestContexts are not set up correctly, so we don't accidentally classify developer errors as BadRequests v2.27.0 Added facility to assign values into a RequestContext which is passed down the Filter chain. v2.26.3 Fix #44 - Request cookies should not be wrapped in quotes. v2.26.2 Fix #43 - AWS does not sign binary requests correctly. v2.26.1 Fix #41 - Sending binary body alters the size of the payload. v2.26.0 Added \"catch all\" routing option, which matches all methods to a handler. v2.25.4 Fix #40 - GZip filters now use content-encoding headers instead of transfer-encoding. v2.25.3 Fix #39 - ResponseBodyMode.Memory properly closes streams (breaks jetty + gzip). v2.25.2 Ensure that streams are closed properly when consuming from an upstream client. v2.25.1 Remove Apache client request streaming because it may not release connections properly. v2.25.0 Add streaming support to HTTP Server and Client modules. Remove CatchLensFailure ClientFilter as it will never be used. v2.24.0 Added CatchLensFailure for ClientFilters - which catches un-deserializable invalid responses from clients and generates a BAD_GATEWAY error. v2.23.4 Switch XML generation to Gson over Jackson because Jackson doesn't handle uppercase field names well. Switch native XML parsed type to Document over Node. v2.23.3 New algorithm for XML data class deserialisation, so un-deprecated XML methods. v2.23.2 Deprecated methods in XML support due to limitation with underlying Jackson implementation. v2.23.1 Fixed bug with GenerateXmlDataClasses filter v2.23.0 Renamed http4k-format-jackson-xml module to http4k-format-xml . Improved XML unmarshalling support. v2.22.1 Fixed 36: Form entry is too strict with content encoding. v2.22.0 Added http4k-format-jackson-xml module, with XML parsing support. Upgrade several dependencies v2.21.2 Fixed Hamkrest matchers to be on HttpMessage and not Http Request. v2.21.1 Default body Content Negotiation strategy changed to None v2.21.0 Converted Content-Negotiation strategy from an Enum to an interface, so that users can define their own strategies. We also now check encoding so there are 4-built in strategies to choose from: Strict, StrictNoDirective, NonStrict and None. v2.20.1 Fixed #31 - Matching of segments in URIs is done after URLs are decoded, which results in not capturing encoded slashes in the path segments. v2.20.0 Fixed #30 - CachingClasspath template ResourceLoader not working with non-root packages. v2.19.0 Fixed #29 - webdriver submission of text area. Http clients now use a new instance of the default for each instantiation. Previously there was a shared instance. Add regex body type for parsing values out of bodies, and \"None\" option for content negotiation. v2.18.3 Fix AWS request signing for requests containing empty path v2.18.2 Fix AWS request signing for requests containing path with special characters v2.18.1 Added support for newRequest() in new RouteBinder mechanic. v2.18.0 Add support for unlimited nesting for routes() blocks. Removed the raw Route object, which can be replaced with Router or RoutingHttpHandler where appropriate. As part of above, rejigged route setup logic. Deprecated old routing structure, so now \"/path\" to GET bind is \"/path\" bind GET to . To fix deprecation, simply switch the calls to \"to\" and \"bind\" in routing setup. Rename of bind() in http4k-contract to be bindContract() v2.17.2 Added missing eclectic HTTP method. :) v2.17.1 Added GZip filters to http4k-core to zip request and response bodies. v2.16.1 Improved messages for http4k-testing-hamkrest matchers. v2.16.0 Added http4k-testing-hamkrest which contains a set of Hamkrest matchers for Http4k objects. v2.15.0 More features for http4k-testing-webdriver . Cookie support added. v2.14.0 More features for http4k-testing-webdriver . We now support Form entry and submission. v2.13.0 More features for http4k-testing-webdriver . v2.12.0 Added http4k-testing-webdriver module, an ultralight Selenium WebDriver for http4k apps v2.11.3 Fix #26 - GenerateDataClasses does not recurse into nested object trees v2.11.2 Fix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with then(RoutingHttpHandler() v2.11.1 Fix static routes not defaulting to index.html when in root context v2.11.0 Added SunHttp server implementation (for development use only) v2.10.1 Fix cookie parsing when value contains '=' v2.10.0 Add method to set form values in the request v2.9.0 Added PURGE HTTP method as it's used commonly by various caches. v2.8.1 Repackage AWS classes for consistency with rest of project v2.7.1 Alter AWS Auth filter creation. Now use ClientFilters.AwsAuth v2.7.0 Add AWS module v2.6.0 Newly created Zipkin traces are now populated onto incoming request in ServerFilters. v2.5.1 Slight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling v2.5.0 Add Thymeleaf templating support v2.4.0 Add Pebble templating support v2.3.0 Make Route a Router so we can nest them together. v2.2.1 Remove excess \"charset\" from headers in Undertow. v2.2.0 Rename by() to bind() in routing for clarity. v2.1.2 Fix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex. v2.1.0 Added GSON full-auto functions to convert arbitary objects to/from JSON. v2.0.5 Fix #23. Contract now supports multi-part URL params (for hardcoded parts) v2.0.4 Fix #22. Uri template does not parse out correct path params when URL starts with a path part. v2.0.3 toString() implementations to aid debugging v2.0.1 Readded missing default parameter for newRequest() on RouteSpec v2.0.0 Breaking: Inversion of routing API. GET to \"/someUri\" is now \"/someUri\" to GET for consistency across the entire API. v1.33.1 Reimplementation of http4k-contract API to match main routing API. Contracts are now nestable. v1.32.2 Fix Filters being applied twice in ContractRoutingHttpHandler v1.32.1 More work on http4k-contract contract API v1.31.0 Rework http4k-contract routing to be mounted in the same way as other RoutingHttpHandlers v1.30.0 Filters are now applied consistently to all Routers v1.29.0 Tweak to DSL for defining StaticRouters v1.28.1 Fix for #18: FollowRedirect will now work if location header includes charset information. v1.28.0 New DSL for defining StaticRouters v1.27.0 Merged StaticContent and StaticRouter and repackage of contract API into other packages v1.26.2 Extend fix for #17 to request Cookie header. v1.26.1 Fix for #17. Cookie can now parse a cookie without attributes and ending in semicolon. v1.26.0 Added nestable Routers. Merging of Modules and Routers. Router is the new Module ! RouteModule is now ContractRouter , so rename in code will be required. v1.25.1 Fix for #15. OkHttp client handling of POSTs with no body. v1.25.0 Can add custom mime types to Static Content GenerateDataClasses is capable of more complex object graphs v1.24.0 Remove HttpHandler.asServer in favour of HttpHandler.startServer to avoid confusion. Introduce Status.description() . v1.23.0 Netty sets content-length header. v1.22.2 Fix for #12. Undertow not constructing response correctly. v1.22.0 New module with Undertow.io support http4k-server-undertow Jackson implementation now ignores unknown properties in incoming messages Netty implementation tidied up v1.21.1 Fix for #11. Netty implementation returns incorrect status codes. v1.21.0 Add synonym methods for Lenses to aid readability. We now have invoke(IN)/extract(IN) and `invoke(IN, TARGET)/inject(IN, TARGET) v1.20.0 http4k-contracts : Add option to change the route of the module description route v1.19.1 http4k-contracts : Fix for contract module description routes not being authenticated via security filter v1.19.0 http4k-contracts : Add Swagger module rendering with JSON schema models for messages. v1.18.0 Add nonEmptyString() lens type to all request parts. v1.17.0 General rework v1.16.0 Further work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios. v1.15.0 Path lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc. Routes can now create shell Requests for themselves, using route.newRequest() v1.14.0 Body is now non-nullable (use Body.EMPTY instead) Rename methods BodyLens API for consistency and clarity. required() is now toLens() . to()' binding method is now of(). v1.13.0 New client module: http4k-client-okhttp v1.12.0 Tidying v1.11.0 Added option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :) v1.10.0 Moved Credentials to org.http4k.core package. Add various filters, including SetHostFrom and CatchAll . v1.9.0 Added GenerateDataClasses so you can generate Kotlin data classes from JSON messages. v1.8.0 Added CORs support v1.7.0 Added auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses v1.6.0 Added CachingFilters v1.5.0 Removed static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions. Merge org.http4k.core.Body and org.http4k.lens.Body . Add Request/Response message parsers. v1.4.0 Turn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected. v1.3.0 Removed non-mandatory parameters from Request and Response constructors. This is aid API clarity. and force users to use the API methods for properly constructing the objects. Regex Lens added. v1.0.0 Initial major release.","title":"Changelog"},{"location":"changelog/#v31140-uncut","text":"(Possible Break): Fix #215 - LensFailure does not always include target object. Only change to the API is that IN generic in Lenses is now bounded by IN : Any . This fix is a actually internally consistent as we could not always include the target otherwise (which is an Any? ). Trim leading and trailing whitespace from extracted EnvironmentKey values. Secret value is now only usable once via the use() function. Removed deprecations","title":"v3.114.0 (uncut)"},{"location":"changelog/#v31130","text":"Added some common types for Environmental setup, and equivalent BiDiLens mappings Handle null response in Java Http client. H/T @FredNordin","title":"v3.113.0"},{"location":"changelog/#v31122","text":"Fix #212 - allow null values in HTTP contract definitions. This does mean we lose the type definition for that field, but we don't blow up silently (which was the previous behaviour). H/T @xhanin","title":"v3.112.2"},{"location":"changelog/#v31121","text":"Re-add Path.nonEmptyString() which was accidentally removed.","title":"v3.112.1"},{"location":"changelog/#v31120","text":"Add support for prohibiting String unmarshalling in JSON auto-marshalling configuration. HTTP Contracts now use the underlying ContractRenderer to produce the BadRequest and NotFound responses. Made OpenAPI open so that these responses can be customised.","title":"v3.112.0"},{"location":"changelog/#v31110","text":"Add support for JSON views in Jackson module. H/T @xhanin for the donkey work.","title":"v3.111.0"},{"location":"changelog/#v31100","text":"Breaking: slight rearrangement of RouteMeta receiving/returning methods to provide consistency when defining route contracts.","title":"v3.110.0"},{"location":"changelog/#v31090","text":"Moved the set of predefined String BiDiMapping instances to their own class. Bulked out the auto-mapping configuration options.","title":"v3.109.0"},{"location":"changelog/#v31080","text":"Upgrade to various deps. Extracted out new BiDiMapping type, which encapsulates string - type conversions and removes a boatload of duplications. These conversions are now used consistently across all the various places (Lenses, auto-mapping). Improved configurability of AutoMarshallingJson instances.","title":"v3.108.0"},{"location":"changelog/#v31070","text":"Upgrade to various deps. Fix #208 - Xml auto deserialisation incorrectly converting strings to numbers","title":"v3.107.0"},{"location":"changelog/#v31061","text":"Fix #207 - repeating prefixes in static routes are not handled correctly. H/T @ruXlab for the PR to fix.","title":"v3.106.1"},{"location":"changelog/#v31060","text":"Add http4k-server-ktorcio server backend. Note that whilst this module does allow http4k apps to plug into the Ktor-CIO engine, it does not provide fully front-to-back coroutine support.","title":"v3.106.0"},{"location":"changelog/#v31050","text":"Preventing FallbackCacheControl from duplicating existing headers. H/T @leandronunes85 Breaking: Make Body.length nullable instead of throwing exception when value is not available. H/T @zvozin","title":"v3.105.0"},{"location":"changelog/#v31040","text":"Upgrade to various deps. Add session token support to AWS filter, and \"credentials provider\" to allow for rotating AWS sessions. H/T @dhobbs. Breaking: Moved WsClient from org.http4k.testing to org.http4k.websocket .","title":"v3.104.0"},{"location":"changelog/#v31032","text":"Fix access-control-allow-origin returned when server supports multiple origins H/T @johnnorris","title":"v3.103.2"},{"location":"changelog/#v31031","text":"(Properly) Fix #198 - Rewrote OpenApi contract to ensure it stays fixed. H/T @reik-wargaming for the help in tracking this down.","title":"v3.103.1"},{"location":"changelog/#v31030","text":"\"Fix\" #198 - Breaking change made in http4k-contracts to clarify/deconfuse API. Hid body parameter in contract route meta DSL - it is now receiving() . Upgraded some dependencies, including Gradle to v5.0. Breaking: Resilience4j dependency upgrade causes a break when providing custom config. Simply insert the Config type generic to fix: e.g. RetryConfig.custom() - RetryConfig.custom RetryConfig ()","title":"v3.103.0"},{"location":"changelog/#v31021","text":"Fix #197 - Swagger spec for form fields had incorrect description.","title":"v3.102.1"},{"location":"changelog/#v31020","text":"Introduce interface for Environment","title":"v3.102.0"},{"location":"changelog/#v31010","text":"Upgrades to dependencies Improved Client-side HTTP status descriptions Lenses now support Durations out of the box Environments now support multi-value keys (comma separated)","title":"v3.101.0"},{"location":"changelog/#v31000","text":"Make Undertow API friendlier Fix to JsonReadinessCheckResultRenderer to actually implement the correct interface","title":"v3.100.0"},{"location":"changelog/#v3990","text":"Enhancement of http4k-cloudnative - now supports extra-health check routes, and provide way to load app configuration via Properties files.","title":"v3.99.0"},{"location":"changelog/#v3980","text":"Add filter allowing Gzipping based on an allowed set of content types. H/T @jshiell Change HttpHandler extending HttpClients to use object invoke() mechanism, as the individual clients have no visible API surface of their own. Introduced DualSyncAsyncHttpHandler interface.","title":"v3.98.0"},{"location":"changelog/#v3970","text":"Webdriver checkbox handling improved. H/T @gypsydave5 upgrade to various versions","title":"v3.97.0"},{"location":"changelog/#v3960","text":"upgrade to Kotlin 1.3.0","title":"v3.96.0"},{"location":"changelog/#v3951","text":"Tweak to K8S port variables.","title":"v3.95.1"},{"location":"changelog/#v3950","text":"(Unlikely break): Change Http4kServer interface to return Unit from stop() . This affects all server implementations. Added DSL function for working with JSON objects (scopes JSON as this ). fun T Json NODE .invoke(Json NODE .() - T) New module http4k-cloudnative contains classes to help run http4k services inside cloud-native environments, including K8S. Upgrade some dependencies Deprecation: Moved Header.Common fields to main Header object. Extension properties should go there now.","title":"v3.95.0"},{"location":"changelog/#v3941","text":"Use UTC when checking cookie expiry","title":"v3.94.1"},{"location":"changelog/#v3940","text":"Deprecate String.toBody() Fix checkbox behaviour in webdriver","title":"v3.94.0"},{"location":"changelog/#v3394-v3934","text":"Use Jetty latest release version (rather than RC one)","title":"~v3.39.4~ v3.93.4"},{"location":"changelog/#v3393","text":"Fix #189 - Uri toString now omits leading slash if the authority of a Uri is blank. This could be a potential break, but is actually more consistent as a Uri can currently be relative or absolute.","title":"v3.39.3"},{"location":"changelog/#v3392","text":"Extend SetBaseUriFrom to support query parameters","title":"v3.39.2"},{"location":"changelog/#v3391","text":"Added SetBaseUriFrom filter","title":"v3.39.1"},{"location":"changelog/#v3390","text":"(Possible breaking change): Json is now only generified by a single type parameter instead of 2. For most usages, this type would have been identical anyway, but the upgrade of Argo has finally allowed the removal of this dead generic. Simply replace Json Node, Node with Json Node . Added Offset datetime types to all JSON auto-marshalling libraries Build logic for versioning is now in Kotlin. H/T @jmfayard for the PR Upgrade Kotlin, and various other dependencies","title":"v3.39.0"},{"location":"changelog/#v3381","text":"Fix withChaosControls URL pattern so that it matches sub-routes ok on original handler","title":"v3.38.1"},{"location":"changelog/#v3380","text":"Added BearerAuth and BasicAuth implementations which populate RequestContexts . Plus cookbook example :)","title":"v3.38.0"},{"location":"changelog/#v3371","text":"Fix #177 - Make RequestContexts thread-safe.","title":"v3.37.1"},{"location":"changelog/#v3370","text":"Upgrades to http4k-testing-webdriver . H/T @dickon for the PRs Added ProxyHost request filter which is useful for writing proxy-type apps.","title":"v3.37.0"},{"location":"changelog/#v3361","text":"Fix #168 - Fix rest of hamkrest matchers caused by generics mishap. Upgrade HTTP client dependency versions.","title":"v3.36.1"},{"location":"changelog/#v3360","text":"Added http4k-testing-chaos module, designed to enhance failure-mode testing for http4k apps. Massive H/T to @IgorPerikov for the PR which drove this module's creation. Added http4k-incubator module, for hosting developing projects and other code which might be promoted to top-level modules in the future.","title":"v3.36.0"},{"location":"changelog/#v3352","text":"Fix #167 - Reintroduce hasBody compatibility with common matchers such as containsString() Remove deprecations.","title":"v3.35.2"},{"location":"changelog/#v3351","text":"Fix #165 - AWS auth filter does not replace headers - it sets them (which breaks for request signing) Fix #164 - Webdriver internal state breaks when navigating to a full URL Fix #162 - SetHostFrom doesn't set 'Host' header correctly (missing port). H/T @elifarley","title":"v3.35.1"},{"location":"changelog/#v3350","text":"Added some regex matchers to http4k-testing-hamkrest . Added BearerAuth authentication Server and Client Filters - these work similarly to BasicAuth . Added option for defaulted() lenses to fall back to another supplied lens in the case of missing value. Thanks to @dmcg for the inspiration. :)","title":"v3.35.0"},{"location":"changelog/#v3343","text":"Fix #160 - JavaHttpClient does not copy body stream correctly onto URL connection.","title":"v3.34.3"},{"location":"changelog/#v3342","text":"Fix #159 - Contracts should not have Security applied to the description route by default.","title":"v3.34.2"},{"location":"changelog/#v3341","text":"Fix #158 - Static and contract routes filters are applied in the wrong order.","title":"v3.34.1"},{"location":"changelog/#v3340","text":"Add default SamplingDecision param to ZipkinTraces - defaults to always sample. Fix #150 - StaticRoutingHandler filters being called twice. Fix #151 - POTENTIAL BREAK: Rework of Status objects to fix equality against the Status constant vals when a description has been overridden. This involves the following potential breaking change: The Status class is no longer a data class to tighten up encapsulation - user calls to copy() will have to be replaced.","title":"v3.34.0"},{"location":"changelog/#v3332","text":"Raise SO_BACKLOG in Apache and Netty server implementations. Add PERMANENT_REDIRECT and UNPROCESSABLE_ENTITY Status object.","title":"v3.33.2"},{"location":"changelog/#v3331","text":"No change from 3.33.0. Previous version couldn't be made available to maven central.","title":"v3.33.1"},{"location":"changelog/#v3330","text":"Add convenient way to extract from as a Map from http message. H/T to @dmcg (this version is available in jcenter only)","title":"v3.33.0"},{"location":"changelog/#v3321","text":"Fix #142 - Pebble templates don't load from JAR files.","title":"v3.32.1"},{"location":"changelog/#v3320","text":"Add support for propagation of the Zipkin x-b3-sampled header","title":"v3.32.0"},{"location":"changelog/#v3310","text":"Changes to the Netty factory to enable running http4k on GraalVM. H/T @RichyHBM","title":"v3.31.0"},{"location":"changelog/#v3300","text":"Allow all server implementations to start on port 0 (ie. find a free port) and then report it back as a part of the Http4kServer interface","title":"v3.30.0"},{"location":"changelog/#v3290","text":"Make HTTP clients resilient to unknown host and connectionrefused exceptions Implememted #134 - Added default (de)serialization for common JDK primitives to all Auto-marshalling JSON modules - eg. datetimes and UUIDs","title":"v3.29.0"},{"location":"changelog/#v3280","text":"Fix #131 - Uri's created with paths that don't contain leading slashes. Added etag parser filter. H/T @dgliosca for the PR Fix #132 - Ensured that disableDefaultTyping is called in default Jackson implementation. This should be the default anyway, but has been added to ensure that we don't fall foul of CVE-2017-7525 and to surface awareness of this issue.","title":"v3.28.0"},{"location":"changelog/#v3270","text":"OpenAPI now provides example values in the generated schema. H/T @skewwhiffy for the PR.","title":"v3.27.0"},{"location":"changelog/#v3266","text":"Fix #126 - ResourceLoadingHandler can expose mapped resources into the root. -- We think this is an important update, so please upgrade!","title":"v3.26.6"},{"location":"changelog/#v3265","text":"Fix #125 - ApacheServer implementation now sets content length if present.","title":"v3.26.5"},{"location":"changelog/#v3264","text":"Fix #123 - Multipart Body objects blow up when parsed after being debugged. As with all streams, care should be taken to not blow heap when internalising them for debugging purposes.","title":"v3.26.4"},{"location":"changelog/#v3263","text":"Debugging filter now supports ignoring Multipart streams.","title":"v3.26.3"},{"location":"changelog/#v3262","text":"Tweak: OpenAPI now doesn't return null values in the schema.","title":"v3.26.2"},{"location":"changelog/#v3261","text":"Fix #124 - headers in WebSocket upgrade request are incorrectly joined.","title":"v3.26.1"},{"location":"changelog/#v3260","text":"Removed supportedContentTypes field from OpenApi contract JSON, since this is a legacy field.","title":"v3.26.0"},{"location":"changelog/#v3250","text":"Added option to Undertow to enable HTTP2 from main ServerConfig","title":"v3.25.0"},{"location":"changelog/#v3240","text":"Upgrade various dependencies for Java 10 compatibility. H/T @tom Fix bug with repeated params in Websocket upgrade request. H/T @tom","title":"v3.24.0"},{"location":"changelog/#v3231","text":"Composite LensFailures now capture (at least) the first failing cause (probably the body parameter in the case of an http4k-contract module.","title":"v3.23.1"},{"location":"changelog/#v3230","text":"Fix #116 - Can provide a custom Response creation method for CatchLensFailure . H/T @elifarley for the inspiration!","title":"v3.23.0"},{"location":"changelog/#v3224","text":"Added singleton method for Json.array, since if you pass in a single JsonNode (Jackson), it accidentally iterates over the fields in the node instead of using the object as an entry in the array. Fix #115 - Only add content-length for methods that allow content in AwsAuth filter","title":"v3.22.4"},{"location":"changelog/#v3223","text":"Preserve routing information on request/response manipulation","title":"v3.22.3"},{"location":"changelog/#v3222","text":"http4k-security-oauth module added - with support for OAuth2 Authorization Grant flow Replaced classes reliant on javax.activation package, which allows Java 9+ to not require any external dependencies. \\o/ Fix #112 - ApacheClient incorrectly sets headers on GET requests (this breaks F5 load balancers). H/T @simojenki PR #110 - Websocket client timeouts are incorrectly translated as seconds instead of millis. HT @anorth Core JavaHttpClient does not support streaming due to limitations with HttpURLConnection","title":"v3.22.2"},{"location":"changelog/#v3211","text":"Fix #109 - Jackson treats integer values inconsistently, leading to matching errors when using hamkrest.","title":"v3.21.1"},{"location":"changelog/#v3210","text":"Fix #107 - Killed the x-uri-template header and fixed the ReportHttpTransaction to have access to the routingGroup . Altered ordering of filters in http4k-contract so that the route is identified before pre-filters and security are applied. This allows knowledge of the path to be accessible at the time of application of those filters.","title":"v3.21.0"},{"location":"changelog/#v3200","text":"Introduce JavaHttpClient to http4k-core . It provides a very basic http client without any other 3rd party dependencies.","title":"v3.20.0"},{"location":"changelog/#v3190","text":"PR #104 - Add optional time/date formatters to LensSpecs so you can choose you serialisation format. H/T @elifarley Fix #105 - Swagger API json file: duplicate key in \"definitions\".","title":"v3.19.0"},{"location":"changelog/#v3181","text":"Fixed PR #100 - URI template regex required extra escaping. This only affects Android deployments as IDE shows the regex escaping is redundant. H/T @privatwolke","title":"v3.18.1"},{"location":"changelog/#v3180","text":"Breaking: converted contract pre-security filter to be a post-security filter. This means that all standard filters are applied before the security later, which allows for logging and monitoring and context setup. The previous filter mechanic applied security first, which didn't allow for this. In the unlikely event that post-security filters still need to be applied, use the withPostSecurityFilter() function when building the contract. Docs for contract RouteMeta function parameters, and deprecated some unused functions (missed when we introduced the DSL). PR #99 - Contract routes now support up to 10 path segments. Thanks to @scap1784 for the PR! :)","title":"v3.18.0"},{"location":"changelog/#v3171","text":"Fix #97. Moshi does not fail when deserialise non-nullable fields correctly. Note that GSON still suffers from this problem","title":"v3.17.1"},{"location":"changelog/#v3170","text":"Added a pre-security filter option to contract creation, so that you can explicitly specify behaviour to occur before security kicks in.","title":"v3.17.0"},{"location":"changelog/#v3160","text":"Convert Security (from sealed class) and ApiKey to be interfaces. This allows users to implement their own security models.","title":"v3.16.0"},{"location":"changelog/#v3150","text":"Introduce HttpTransaction and new ReportHttpTransaction filter provide better generic API for reporting, along with the ability to label transactions for this purpose. Breaking: Rework the metrics request counter and timer Filter API. There is now a HttpTransactionLabeller for you to add as many labels as required to the transaction. Each of these labels will be used to tag the metric.","title":"v3.15.0"},{"location":"changelog/#v3141","text":"Fix #95 - Filters are now applied to \"route not found\" responses","title":"v3.14.1"},{"location":"changelog/#v3140","text":"Fix #93 - Apache server doesn't like content-length or transfer-encoding headers present in http4k response. Add ability to \"name\" input and output contract body definitions in an OpenAPI JSON doc. This applies to only the top level entity. If no override is passed, the objects are named according to their hashcode.","title":"v3.14.0"},{"location":"changelog/#3134","text":"Fix #92 - cookie date should always use US locale","title":"3.13.4"},{"location":"changelog/#v3133","text":"Further tweak to Netty. H/T @FredDeschenes","title":"v3.13.3"},{"location":"changelog/#v3132","text":"Fix #91 - large message handli ng in Netty","title":"v3.13.2"},{"location":"changelog/#v3131","text":"Upgrade to Kotlin 1.2.20","title":"v3.13.1"},{"location":"changelog/#v3130","text":"Support for operationId in OpenApi route metadata. H/T @danschultz for the PR. Removed previously deprecated methods.","title":"v3.13.0"},{"location":"changelog/#v3120","text":"New client module http4k-client-jetty , which supports both sync and async models.","title":"v3.12.0"},{"location":"changelog/#v3111","text":"Fix #84. OPTIONS requests are not detected by contract routes. Added option to NOT authorise OPTIONS requests in ApiKey security filter. Added support for Async HTTP clients and added new AsyncHttpClient interface, which is obviously used for HTTP clients only**, and not server-side calls. :) New client module http4k-client-apache-async . New metrics gathering module http4k-metrics-micrometer . Big H/T to @kirderf for the PR. Added support for async to OkHttp client module.","title":"v3.11.1"},{"location":"changelog/#v3100","text":"P/R 81 - adding headers and timeout to websocket client.","title":"v3.10.0"},{"location":"changelog/#v390","text":"Added compactify and prettify to Json implementations Added Json.hasBody Hamkrest matchers for comparing bodies. Note these are extension methods and need to be referenced/imported as such.","title":"v3.9.0"},{"location":"changelog/#v380","text":"Added facility for non-blocking websocket client to react to onConnect event. This API is the same as the inbound, server-side API - ie. there are no explicit connection event handlers. H/T @tom for the idea.","title":"v3.8.0"},{"location":"changelog/#v370","text":"P/R #13 Create extension methods for Response to add caching headers. H/T @k0zakinio.","title":"v3.7.0"},{"location":"changelog/#v361","text":"Fix #78. Serialisation of raw lists using Moshi fails in the same way as the Jackson auto-conversions do. Added convenience methods to get around this.","title":"v3.6.1"},{"location":"changelog/#v360","text":"Added http4k-format-moshi to support the Square auto-marshalling library.","title":"v3.6.0"},{"location":"changelog/#v351","text":"Fix #76 - encoding of path segments to use URI encoding instead of URL form encoding.","title":"v3.5.1"},{"location":"changelog/#v350","text":"Added support for multiple HotReload template directories in HandlebarsTemplates . H/T @TomShacham Fix #74 - Request tracing span/parentSpan set too early so was shared between outgoing requests.","title":"v3.5.0"},{"location":"changelog/#v340","text":"New server backend http4k-server-apache . H/T @kirderf for the PR :) We now set the length of the incoming request body when it is available in the incoming request.","title":"v3.4.0"},{"location":"changelog/#v331","text":"Handlebars now uses combination of Class and Template name to cache templates.","title":"v3.3.1"},{"location":"changelog/#v330","text":"Facility to compose TemplateRenderers with then() to provide fallback behaviour.","title":"v3.3.0"},{"location":"changelog/#v323","text":"PR #70: Header order equality for Request/Response - H/T @gypsydave5.","title":"v3.2.3"},{"location":"changelog/#v322","text":"Switched out Status for WsStatus (with proper RFC code set) in Websockets.","title":"v3.2.2"},{"location":"changelog/#v321","text":"Typesafe Websockets! Jetty now supports websockets, using the same style of API in the main http4k routing. (Possible) Breaking change: Because WsHandler (typealias) implements the same inbound interface as HttpHandler , you now cannot declare HttpHandlers without specifying the input type, so any \"anonymous\" handlers will not compile as a result. The required fix is very simple, but manual: `{ Response(OK) } should become { _:Request - Response(OK) }","title":"v3.2.1"},{"location":"changelog/#v313","text":"Fix Request.form() for streaming requests","title":"v3.1.3"},{"location":"changelog/#v312","text":"Remove possibility of empty message for Path Lens failure.","title":"v3.1.2"},{"location":"changelog/#v311","text":"New (better!) API for http4k-contract module. Old meta DSL has been deprecated.","title":"v3.1.1"},{"location":"changelog/#v301","text":"Fix #63 - Apache Client Connect. timeout exception handling.","title":"v3.0.1"},{"location":"changelog/#v300","text":"Added http4k-serverless-lambda module, allowing http4k applications to be deployed into AWS Lambda and then called from API Gateway. Effectively, the combination of these two services become just another Server back-end supported by the library. \\o/","title":"v3.0.0"},{"location":"changelog/#v2381","text":"RequestContextKey now follow the standardised Lens structure of required, optional, defaulted, and can now be removed (set to null). Replace calls to RequestContextKey.of() with RequestContextKey.required() Removed previously deprecated values. See below for details on replacements.","title":"v2.38.1"},{"location":"changelog/#v2370","text":"Added http4k-resilience4j module, which adds Circuits, RateLimiters, Retrying and Bulkheading. Fix #60 (H/T @michaelhixson for the spot).","title":"v2.37.0"},{"location":"changelog/#v2360","text":"Added a couple of useful ServerFilters . Upgrade various dependency versions. Tidying of Multipart code.","title":"v2.36.0"},{"location":"changelog/#v2351","text":"Fix #57. Static handlers behave oddly when combined with an HTTP verb in the routing tree.","title":"v2.35.1"},{"location":"changelog/#v2350","text":"Fix #56. Altered behaviour of CatchLensFailure to NOT catch errors from unmarshalling Response objects. This was causing BAD_REQUEST to be incorrectly generated. Simplification of generics around LensSpecs. This should not be a breaking change, (there were 3 generics, now the MID has been removed so there are just 2) but could break if signatures are used explicitly.","title":"v2.35.0"},{"location":"changelog/#v2340","text":"Reordered generics in LensInjector to make sense. This should have no effect on most code-bases, but could break if signatures are used explicitly. Just flip the generic types to switch.","title":"v2.34.0"},{"location":"changelog/#v2331","text":"Added support for unsigned AWS requests, which enables streaming content to S3.","title":"v2.33.1"},{"location":"changelog/#v2330","text":"Added BodyMode.Request to configure streaming for clients. ResponseBodyMode is now BodyMode.Response (Breaking change. Fixable with simple find/replace).","title":"v2.33.0"},{"location":"changelog/#v2320","text":"Added ServerFilter.ProcessFiles filter to stream Multipart Files, convert them into references and replace inline in the Form.","title":"v2.32.0"},{"location":"changelog/#v2314","text":"Avoid realising StreamBody unless necessary, which could break common usages of streaming.","title":"v2.31.4"},{"location":"changelog/#v2313","text":"Tweaks to Server backends to improve efficiency.","title":"v2.31.3"},{"location":"changelog/#v2312","text":"Webdriver will keep only the final URI after redirects.","title":"v2.31.2"},{"location":"changelog/#v2311","text":"Increased granularity of Replay.DiskStream and ensure that traffic is returned in exact order on all OSes. Add support for redirects to Webdriver.","title":"v2.31.1"},{"location":"changelog/#v2310","text":"Multipart module tweaked to provide a more consistent API. Fix FollowRedirects for POST/PUT request.","title":"v2.31.0"},{"location":"changelog/#v2300","text":"Multipart form support through new module http4k-multipart . Deprecation: Replaced Swagger with OpenApi and deprecated the former (via typealias). Deprecation: Replaced FormValidator with Validator and deprecated the former (via typealias).","title":"v2.30.0"},{"location":"changelog/#v2294","text":"Refactor release.","title":"v2.29.4"},{"location":"changelog/#v2293","text":"Fix #50 - Webdriver does not normalise relative links correctly.","title":"v2.29.3"},{"location":"changelog/#v2292","text":"Http client modules now catch and convert Socket Timeout exceptions to HTTP 504s (with a custom message)","title":"v2.29.2"},{"location":"changelog/#v2291","text":"Tweaks to how recorded traffic is stored on disk. Thanks to @dkandalov for the PR around this.","title":"v2.29.1"},{"location":"changelog/#v2290","text":"Added TrafficFilters for recording and replaying HTTP traffic. See org.http4k.traffic package for details.","title":"v2.29.0"},{"location":"changelog/#v2280","text":"Added http4k-template-dust for Dust template engine support. Thanks to @npryce for the PR to add this.","title":"v2.28.0"},{"location":"changelog/#v2272","text":"Fix #44 - Use quotes around cookie values","title":"v2.27.2"},{"location":"changelog/#v2271","text":"Raise proper Exception (instead of LensFailure) when RequestContexts are not set up correctly, so we don't accidentally classify developer errors as BadRequests","title":"v2.27.1"},{"location":"changelog/#v2270","text":"Added facility to assign values into a RequestContext which is passed down the Filter chain.","title":"v2.27.0"},{"location":"changelog/#v2263","text":"Fix #44 - Request cookies should not be wrapped in quotes.","title":"v2.26.3"},{"location":"changelog/#v2262","text":"Fix #43 - AWS does not sign binary requests correctly.","title":"v2.26.2"},{"location":"changelog/#v2261","text":"Fix #41 - Sending binary body alters the size of the payload.","title":"v2.26.1"},{"location":"changelog/#v2260","text":"Added \"catch all\" routing option, which matches all methods to a handler.","title":"v2.26.0"},{"location":"changelog/#v2254","text":"Fix #40 - GZip filters now use content-encoding headers instead of transfer-encoding.","title":"v2.25.4"},{"location":"changelog/#v2253","text":"Fix #39 - ResponseBodyMode.Memory properly closes streams (breaks jetty + gzip).","title":"v2.25.3"},{"location":"changelog/#v2252","text":"Ensure that streams are closed properly when consuming from an upstream client.","title":"v2.25.2"},{"location":"changelog/#v2251","text":"Remove Apache client request streaming because it may not release connections properly.","title":"v2.25.1"},{"location":"changelog/#v2250","text":"Add streaming support to HTTP Server and Client modules. Remove CatchLensFailure ClientFilter as it will never be used.","title":"v2.25.0"},{"location":"changelog/#v2240","text":"Added CatchLensFailure for ClientFilters - which catches un-deserializable invalid responses from clients and generates a BAD_GATEWAY error.","title":"v2.24.0"},{"location":"changelog/#v2234","text":"Switch XML generation to Gson over Jackson because Jackson doesn't handle uppercase field names well. Switch native XML parsed type to Document over Node.","title":"v2.23.4"},{"location":"changelog/#v2233","text":"New algorithm for XML data class deserialisation, so un-deprecated XML methods.","title":"v2.23.3"},{"location":"changelog/#v2232","text":"Deprecated methods in XML support due to limitation with underlying Jackson implementation.","title":"v2.23.2"},{"location":"changelog/#v2231","text":"Fixed bug with GenerateXmlDataClasses filter","title":"v2.23.1"},{"location":"changelog/#v2230","text":"Renamed http4k-format-jackson-xml module to http4k-format-xml . Improved XML unmarshalling support.","title":"v2.23.0"},{"location":"changelog/#v2221","text":"Fixed 36: Form entry is too strict with content encoding.","title":"v2.22.1"},{"location":"changelog/#v2220","text":"Added http4k-format-jackson-xml module, with XML parsing support. Upgrade several dependencies","title":"v2.22.0"},{"location":"changelog/#v2212","text":"Fixed Hamkrest matchers to be on HttpMessage and not Http Request.","title":"v2.21.2"},{"location":"changelog/#v2211","text":"Default body Content Negotiation strategy changed to None","title":"v2.21.1"},{"location":"changelog/#v2210","text":"Converted Content-Negotiation strategy from an Enum to an interface, so that users can define their own strategies. We also now check encoding so there are 4-built in strategies to choose from: Strict, StrictNoDirective, NonStrict and None.","title":"v2.21.0"},{"location":"changelog/#v2201","text":"Fixed #31 - Matching of segments in URIs is done after URLs are decoded, which results in not capturing encoded slashes in the path segments.","title":"v2.20.1"},{"location":"changelog/#v2200","text":"Fixed #30 - CachingClasspath template ResourceLoader not working with non-root packages.","title":"v2.20.0"},{"location":"changelog/#v2190","text":"Fixed #29 - webdriver submission of text area. Http clients now use a new instance of the default for each instantiation. Previously there was a shared instance. Add regex body type for parsing values out of bodies, and \"None\" option for content negotiation.","title":"v2.19.0"},{"location":"changelog/#v2183","text":"Fix AWS request signing for requests containing empty path","title":"v2.18.3"},{"location":"changelog/#v2182","text":"Fix AWS request signing for requests containing path with special characters","title":"v2.18.2"},{"location":"changelog/#v2181","text":"Added support for newRequest() in new RouteBinder mechanic.","title":"v2.18.1"},{"location":"changelog/#v2180","text":"Add support for unlimited nesting for routes() blocks. Removed the raw Route object, which can be replaced with Router or RoutingHttpHandler where appropriate. As part of above, rejigged route setup logic. Deprecated old routing structure, so now \"/path\" to GET bind is \"/path\" bind GET to . To fix deprecation, simply switch the calls to \"to\" and \"bind\" in routing setup. Rename of bind() in http4k-contract to be bindContract()","title":"v2.18.0"},{"location":"changelog/#v2172","text":"Added missing eclectic HTTP method. :)","title":"v2.17.2"},{"location":"changelog/#v2171","text":"Added GZip filters to http4k-core to zip request and response bodies.","title":"v2.17.1"},{"location":"changelog/#v2161","text":"Improved messages for http4k-testing-hamkrest matchers.","title":"v2.16.1"},{"location":"changelog/#v2160","text":"Added http4k-testing-hamkrest which contains a set of Hamkrest matchers for Http4k objects.","title":"v2.16.0"},{"location":"changelog/#v2150","text":"More features for http4k-testing-webdriver . Cookie support added.","title":"v2.15.0"},{"location":"changelog/#v2140","text":"More features for http4k-testing-webdriver . We now support Form entry and submission.","title":"v2.14.0"},{"location":"changelog/#v2130","text":"More features for http4k-testing-webdriver .","title":"v2.13.0"},{"location":"changelog/#v2120","text":"Added http4k-testing-webdriver module, an ultralight Selenium WebDriver for http4k apps","title":"v2.12.0"},{"location":"changelog/#v2113","text":"Fix #26 - GenerateDataClasses does not recurse into nested object trees","title":"v2.11.3"},{"location":"changelog/#v2112","text":"Fix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with then(RoutingHttpHandler()","title":"v2.11.2"},{"location":"changelog/#v2111","text":"Fix static routes not defaulting to index.html when in root context","title":"v2.11.1"},{"location":"changelog/#v2110","text":"Added SunHttp server implementation (for development use only)","title":"v2.11.0"},{"location":"changelog/#v2101","text":"Fix cookie parsing when value contains '='","title":"v2.10.1"},{"location":"changelog/#v2100","text":"Add method to set form values in the request","title":"v2.10.0"},{"location":"changelog/#v290","text":"Added PURGE HTTP method as it's used commonly by various caches.","title":"v2.9.0"},{"location":"changelog/#v281","text":"Repackage AWS classes for consistency with rest of project","title":"v2.8.1"},{"location":"changelog/#v271","text":"Alter AWS Auth filter creation. Now use ClientFilters.AwsAuth","title":"v2.7.1"},{"location":"changelog/#v270","text":"Add AWS module","title":"v2.7.0"},{"location":"changelog/#v260","text":"Newly created Zipkin traces are now populated onto incoming request in ServerFilters.","title":"v2.6.0"},{"location":"changelog/#v251","text":"Slight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling","title":"v2.5.1"},{"location":"changelog/#v250","text":"Add Thymeleaf templating support","title":"v2.5.0"},{"location":"changelog/#v240","text":"Add Pebble templating support","title":"v2.4.0"},{"location":"changelog/#v230","text":"Make Route a Router so we can nest them together.","title":"v2.3.0"},{"location":"changelog/#v221","text":"Remove excess \"charset\" from headers in Undertow.","title":"v2.2.1"},{"location":"changelog/#v220","text":"Rename by() to bind() in routing for clarity.","title":"v2.2.0"},{"location":"changelog/#v212","text":"Fix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex.","title":"v2.1.2"},{"location":"changelog/#v210","text":"Added GSON full-auto functions to convert arbitary objects to/from JSON.","title":"v2.1.0"},{"location":"changelog/#v205","text":"Fix #23. Contract now supports multi-part URL params (for hardcoded parts)","title":"v2.0.5"},{"location":"changelog/#v204","text":"Fix #22. Uri template does not parse out correct path params when URL starts with a path part.","title":"v2.0.4"},{"location":"changelog/#v203","text":"toString() implementations to aid debugging","title":"v2.0.3"},{"location":"changelog/#v201","text":"Readded missing default parameter for newRequest() on RouteSpec","title":"v2.0.1"},{"location":"changelog/#v200","text":"Breaking: Inversion of routing API. GET to \"/someUri\" is now \"/someUri\" to GET for consistency across the entire API.","title":"v2.0.0"},{"location":"changelog/#v1331","text":"Reimplementation of http4k-contract API to match main routing API. Contracts are now nestable.","title":"v1.33.1"},{"location":"changelog/#v1322","text":"Fix Filters being applied twice in ContractRoutingHttpHandler","title":"v1.32.2"},{"location":"changelog/#v1321","text":"More work on http4k-contract contract API","title":"v1.32.1"},{"location":"changelog/#v1310","text":"Rework http4k-contract routing to be mounted in the same way as other RoutingHttpHandlers","title":"v1.31.0"},{"location":"changelog/#v1300","text":"Filters are now applied consistently to all Routers","title":"v1.30.0"},{"location":"changelog/#v1290","text":"Tweak to DSL for defining StaticRouters","title":"v1.29.0"},{"location":"changelog/#v1281","text":"Fix for #18: FollowRedirect will now work if location header includes charset information.","title":"v1.28.1"},{"location":"changelog/#v1280","text":"New DSL for defining StaticRouters","title":"v1.28.0"},{"location":"changelog/#v1270","text":"Merged StaticContent and StaticRouter and repackage of contract API into other packages","title":"v1.27.0"},{"location":"changelog/#v1262","text":"Extend fix for #17 to request Cookie header.","title":"v1.26.2"},{"location":"changelog/#v1261","text":"Fix for #17. Cookie can now parse a cookie without attributes and ending in semicolon.","title":"v1.26.1"},{"location":"changelog/#v1260","text":"Added nestable Routers. Merging of Modules and Routers. Router is the new Module ! RouteModule is now ContractRouter , so rename in code will be required.","title":"v1.26.0"},{"location":"changelog/#v1251","text":"Fix for #15. OkHttp client handling of POSTs with no body.","title":"v1.25.1"},{"location":"changelog/#v1250","text":"Can add custom mime types to Static Content GenerateDataClasses is capable of more complex object graphs","title":"v1.25.0"},{"location":"changelog/#v1240","text":"Remove HttpHandler.asServer in favour of HttpHandler.startServer to avoid confusion. Introduce Status.description() .","title":"v1.24.0"},{"location":"changelog/#v1230","text":"Netty sets content-length header.","title":"v1.23.0"},{"location":"changelog/#v1222","text":"Fix for #12. Undertow not constructing response correctly.","title":"v1.22.2"},{"location":"changelog/#v1220","text":"New module with Undertow.io support http4k-server-undertow Jackson implementation now ignores unknown properties in incoming messages Netty implementation tidied up","title":"v1.22.0"},{"location":"changelog/#v1211","text":"Fix for #11. Netty implementation returns incorrect status codes.","title":"v1.21.1"},{"location":"changelog/#v1210","text":"Add synonym methods for Lenses to aid readability. We now have invoke(IN)/extract(IN) and `invoke(IN, TARGET)/inject(IN, TARGET)","title":"v1.21.0"},{"location":"changelog/#v1200","text":"http4k-contracts : Add option to change the route of the module description route","title":"v1.20.0"},{"location":"changelog/#v1191","text":"http4k-contracts : Fix for contract module description routes not being authenticated via security filter","title":"v1.19.1"},{"location":"changelog/#v1190","text":"http4k-contracts : Add Swagger module rendering with JSON schema models for messages.","title":"v1.19.0"},{"location":"changelog/#v1180","text":"Add nonEmptyString() lens type to all request parts.","title":"v1.18.0"},{"location":"changelog/#v1170","text":"General rework","title":"v1.17.0"},{"location":"changelog/#v1160","text":"Further work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios.","title":"v1.16.0"},{"location":"changelog/#v1150","text":"Path lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc. Routes can now create shell Requests for themselves, using route.newRequest()","title":"v1.15.0"},{"location":"changelog/#v1140","text":"Body is now non-nullable (use Body.EMPTY instead) Rename methods BodyLens API for consistency and clarity. required() is now toLens() . to()' binding method is now of().","title":"v1.14.0"},{"location":"changelog/#v1130","text":"New client module: http4k-client-okhttp","title":"v1.13.0"},{"location":"changelog/#v1120","text":"Tidying","title":"v1.12.0"},{"location":"changelog/#v1110","text":"Added option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :)","title":"v1.11.0"},{"location":"changelog/#v1100","text":"Moved Credentials to org.http4k.core package. Add various filters, including SetHostFrom and CatchAll .","title":"v1.10.0"},{"location":"changelog/#v190","text":"Added GenerateDataClasses so you can generate Kotlin data classes from JSON messages.","title":"v1.9.0"},{"location":"changelog/#v180","text":"Added CORs support","title":"v1.8.0"},{"location":"changelog/#v170","text":"Added auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses","title":"v1.7.0"},{"location":"changelog/#v160","text":"Added CachingFilters","title":"v1.6.0"},{"location":"changelog/#v150","text":"Removed static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions. Merge org.http4k.core.Body and org.http4k.lens.Body . Add Request/Response message parsers.","title":"v1.5.0"},{"location":"changelog/#v140","text":"Turn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected.","title":"v1.4.0"},{"location":"changelog/#v130","text":"Removed non-mandatory parameters from Request and Response constructors. This is aid API clarity. and force users to use the API methods for properly constructing the objects. Regex Lens added.","title":"v1.3.0"},{"location":"changelog/#v100","text":"Initial major release.","title":"v1.0.0"},{"location":"contributing/","text":"Contributers' Guide There are many ways in which you can contribute to the development of the library: Give us a Star on Github - you know you want to ;) Questions can be directed towards the Gitter channel, or on Twitter @http4k For issues, please describe giving as much detail as you can - including version and steps to recreate pull requests If there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR. JSON formats: create a new module with an implementation of Json by following the Argo example in the source. Templating engines: create a new module with a Templates implementation by following the HandlebarsTemplates example in the source general guidelines At the moment, PRs should be sent to the master branch - this might change in future so check back everytime! Source/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions PR changes should have test coverage. Note that we use Junit 5 as a test engine - which uses new @Test annotations. All the PRs must pass the Travis CI jobs before merging them https://travis-ci.org/http4k/http4k Testing with default settings is required when push changes: sh ./gradlew check Financial contributions We also welcome financial contributions in full transparency on our open collective . Anyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed. Credits Contributors Thank you to all the people who have already contributed to http4k! Backers Thank you to all our backers! [ Become a backer ] Sponsors Thank you to all our sponsors! (please ask your company to also support this open source project by becoming a sponsor )","title":"Contribute/Support http4k"},{"location":"contributing/#pull-requests","text":"If there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR. JSON formats: create a new module with an implementation of Json by following the Argo example in the source. Templating engines: create a new module with a Templates implementation by following the HandlebarsTemplates example in the source","title":"pull requests"},{"location":"contributing/#general-guidelines","text":"At the moment, PRs should be sent to the master branch - this might change in future so check back everytime! Source/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions PR changes should have test coverage. Note that we use Junit 5 as a test engine - which uses new @Test annotations. All the PRs must pass the Travis CI jobs before merging them https://travis-ci.org/http4k/http4k Testing with default settings is required when push changes: sh ./gradlew check","title":"general guidelines"},{"location":"contributing/#financial-contributions","text":"We also welcome financial contributions in full transparency on our open collective . Anyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.","title":"Financial contributions"},{"location":"contributing/#credits","text":"","title":"Credits"},{"location":"contributing/#contributors","text":"Thank you to all the people who have already contributed to http4k!","title":"Contributors"},{"location":"contributing/#backers","text":"Thank you to all our backers! [ Become a backer ]","title":"Backers"},{"location":"contributing/#sponsors","text":"Thank you to all our sponsors! (please ask your company to also support this open source project by becoming a sponsor )","title":"Sponsors"},{"location":"cookbook/client_as_a_function/","text":"This example demonstrates using http4k as a client, to consume HTTP services. A client is just another HttpHandler. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 Code","title":"Client as a function"},{"location":"cookbook/client_as_a_function/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/client_as_a_function/#code","text":"","title":"Code "},{"location":"cookbook/container_integration/","text":"This example shows how to both how to serve an application HttpHandler using an embedded an HTTP server and to query it using an HTTP client. All server-backend implementations are launched in an identical manner (in 1LOC) using implementations of the ServerConfig interface - and a base implementation of this interface is provided for each server backend. Alternatively, any http4k application can be mounted into any Servlet container using the asServlet() extension method. This is the mechanism used in the Jetty implementation. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-client-apache , version: 3.113.0 compile group: org.http4k , name: http4k-server-jetty , version: 3.113.0 Code","title":"Container integration"},{"location":"cookbook/container_integration/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-client-apache , version: 3.113.0 compile group: org.http4k , name: http4k-server-jetty , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/container_integration/#code","text":"","title":"Code "},{"location":"cookbook/custom_oauth/","text":"It is very easy to configure http4k to integrate with any OAuth2 provider who supports the Authorisation Code Grant. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-security-oauth , version: 3.113.0 For this example, simply reconfigure the OAuthProvider instance with the correct details, and provide custom logic for persisting and retrieving the CSRF and AccessToken. Code","title":"Custom OAuth configuration"},{"location":"cookbook/custom_oauth/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-security-oauth , version: 3.113.0 For this example, simply reconfigure the OAuthProvider instance with the correct details, and provide custom logic for persisting and retrieving the CSRF and AccessToken.","title":"Gradle setup"},{"location":"cookbook/custom_oauth/#code","text":"","title":"Code "},{"location":"cookbook/generating_data_classes/","text":"On the web... This Heroku app demonstrates how to use JSON and XML automarshalling to communicate using typesafe Body lenses. Or manually using a filter... This example show the usage of the GenerateDataClasses to generate Kotlin data class code for JSON messages from a remote endpoint. When used in conjunction with the \"auto body-marshalling\" functionality available with JSON libraries such as Jackson and GSON, this provides a super-fast way to integrate with upstream remote APIs in a typesafe way. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-format-gson , version: 3.113.0 Code","title":"Generating data classes for messages"},{"location":"cookbook/generating_data_classes/#on-the-web","text":"This Heroku app demonstrates how to use JSON and XML automarshalling to communicate using typesafe Body lenses.","title":"On the web..."},{"location":"cookbook/generating_data_classes/#or-manually-using-a-filter","text":"This example show the usage of the GenerateDataClasses to generate Kotlin data class code for JSON messages from a remote endpoint. When used in conjunction with the \"auto body-marshalling\" functionality available with JSON libraries such as Jackson and GSON, this provides a super-fast way to integrate with upstream remote APIs in a typesafe way.","title":"Or manually using a filter..."},{"location":"cookbook/generating_data_classes/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-format-gson , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/generating_data_classes/#code","text":"","title":"Code "},{"location":"cookbook/html_forms/","text":"HTML form support is provided on 2 levels: Through the use of form() extension methods on Request to get/set String values. Using the Lens system, which adds the facility to define form fields in a typesafe way, and to validate form contents (in either a strict (400) or \"feedback\" mode). Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 Standard (non-typesafe) API Lens (typesafe, validating) API","title":"HTML forms"},{"location":"cookbook/html_forms/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/html_forms/#standard-non-typesafe-api","text":"","title":"Standard (non-typesafe) API "},{"location":"cookbook/html_forms/#lens-typesafe-validating-api","text":"","title":"Lens (typesafe, validating) API "},{"location":"cookbook/monitoring/","text":"Measuring performance of application estate is crucial in today's microservice world - it is crucial that dev-ops enabled teams can monitor, react and scale dynamically to changes in the runtime environment. However, because of the plethora of monitoring tools on the market, and because http4k is a toolkit and not a complete \"batteries included\" framework, it provides a number of integration points to enable monitoring systems to be plugged in as required. Additionally, it is envisaged that users will probably want to provide their own implementations of the http4k ServerConfig classes ( Jetty , Undertow etc..) so that tweaking and tuning to their exact requirements is accessible, instead of http4k attempting to provide some generic configuration API to achieve it. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-metrics-micrometer , version: 3.113.0 Metrics (Micrometer) http4k provides module support for monitoring application endpoints using the micrometer metrics abstraction library, which currently enables support for libraries such as Graphite, StatsD, Prometheus and Netflix Atlas. This also provides drop-in classes to record stats such as JVM performance, GC and thread usage. Metrics (other APIs) Alternatively, it's very easy to use a standard Filter to report on stats: Logging This is trivial to achieve by using a Filter: Distributed tracing This allows a chain of application calls to be tied together and is generally done through the setting of HTTP headers on each call. http4k supports the OpenZipkin standard for achieving this and provides both Server-side and Client-side Filters for this purpose. This example shows a chain of two proxies and an endpoint - run it to observe the changes to the tracing headers as the request flows through the system: Debugging Easily wrap an HttpHandler in a debugging filter to check out what is going on under the covers:","title":"Monitoring http4k"},{"location":"cookbook/monitoring/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-metrics-micrometer , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/monitoring/#metrics-micrometer","text":"http4k provides module support for monitoring application endpoints using the micrometer metrics abstraction library, which currently enables support for libraries such as Graphite, StatsD, Prometheus and Netflix Atlas. This also provides drop-in classes to record stats such as JVM performance, GC and thread usage.","title":"Metrics (Micrometer) "},{"location":"cookbook/monitoring/#metrics-other-apis","text":"Alternatively, it's very easy to use a standard Filter to report on stats:","title":"Metrics (other APIs) "},{"location":"cookbook/monitoring/#logging","text":"This is trivial to achieve by using a Filter:","title":"Logging "},{"location":"cookbook/monitoring/#distributed-tracing","text":"This allows a chain of application calls to be tied together and is generally done through the setting of HTTP headers on each call. http4k supports the OpenZipkin standard for achieving this and provides both Server-side and Client-side Filters for this purpose. This example shows a chain of two proxies and an endpoint - run it to observe the changes to the tracing headers as the request flows through the system:","title":"Distributed tracing "},{"location":"cookbook/monitoring/#debugging","text":"Easily wrap an HttpHandler in a debugging filter to check out what is going on under the covers:","title":"Debugging "},{"location":"cookbook/multipart_forms/","text":"Multipart form support is provided on 2 levels: Through the creation of a MultipartFormBody which can be set on a Request . Using the Lens system, which adds the facility to define form fields in a typesafe way, and to validate form contents (in either a strict (400) or \"feedback\" mode). Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-multipart , version: 3.113.0 Standard (non-typesafe) API Lens (typesafe, validating) API - reads ALL contents onto disk/memory Streaming - iterate over Multiparts Processing Files with a Filter and convert to standard form","title":"Multipart forms"},{"location":"cookbook/multipart_forms/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-multipart , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/multipart_forms/#standard-non-typesafe-api","text":"","title":"Standard (non-typesafe) API "},{"location":"cookbook/multipart_forms/#lens-typesafe-validating-api-reads-all-contents-onto-diskmemory","text":"","title":"Lens (typesafe, validating) API - reads ALL contents onto disk/memory "},{"location":"cookbook/multipart_forms/#streaming-iterate-over-multiparts","text":"","title":"Streaming - iterate over Multiparts "},{"location":"cookbook/multipart_forms/#processing-files-with-a-filter-and-convert-to-standard-form","text":"","title":"Processing Files with a Filter and convert to standard form "},{"location":"cookbook/nanoservices/","text":"http4k is a small library with minimal dependencies, but what you can accomplish with just a single line of code is quite remarkable due to a combination of the available modules and the Server as a Function concept. The main code of the following http4k applications (in the appropriately named function) all fit in a tweet (140 characters)... exports excluded ;) Simple Proxy Requires: http4k-core This simple proxy converts HTTP requests to HTTPS. Because of the symmetrical server/client HttpHandler signature, we can simply mount an HTTP client onto a Server, then add a ProxyHost filter to do the protocol conversion. Latency Reporting Proxy Requires: http4k-core Building on the Simple Proxy example, we can simply layer on extra filters to add features to the proxy, in this case reporting the latency of each call. Wire-sniffing Proxy Requires: http4k-core Applying a DebuggingFilter to the HTTP calls in a proxy dumps the entire contents out to StdOut (or other stream). Traffic Recording Proxy Replayer Requires: http4k-core This example contains two apps. The first is a proxy which captures streams of traffic and records it to a directory on disk. The second app is configured to replay the requests from that disk store at the original server. This kind of traffic capture/replay is very useful for load testing or for tracking down hard-to-diagnose bugs - and it's easy to write other other stores such as an S3 bucket etc. Static file Server Requires: http4k-core Longer than the Python SimpleHttpServer , but still pretty small! Websocket Clock Requires: http4k-core , http4k-server-jetty Like Http handlers, Websockets in http4k can be modelled as simple functions that can be mounted onto a Server, or combined with path patterns if required. Chaos Proxy (random latency edition) Requires: http4k-core , http4k-testing-chaos As per the Principles of Chaos , this proxy adds Chaotic behaviour to a remote service, which is useful for modelling how a system might behave under various failure modes. Chaos can be dynamically injected via an OpenApi documented set of RPC endpoints.","title":"Nanoservices"},{"location":"cookbook/nanoservices/#simple-proxy","text":"Requires: http4k-core This simple proxy converts HTTP requests to HTTPS. Because of the symmetrical server/client HttpHandler signature, we can simply mount an HTTP client onto a Server, then add a ProxyHost filter to do the protocol conversion.","title":"Simple Proxy "},{"location":"cookbook/nanoservices/#latency-reporting-proxy","text":"Requires: http4k-core Building on the Simple Proxy example, we can simply layer on extra filters to add features to the proxy, in this case reporting the latency of each call.","title":"Latency Reporting Proxy "},{"location":"cookbook/nanoservices/#wire-sniffing-proxy","text":"Requires: http4k-core Applying a DebuggingFilter to the HTTP calls in a proxy dumps the entire contents out to StdOut (or other stream).","title":"Wire-sniffing Proxy "},{"location":"cookbook/nanoservices/#traffic-recording-proxy-replayer","text":"Requires: http4k-core This example contains two apps. The first is a proxy which captures streams of traffic and records it to a directory on disk. The second app is configured to replay the requests from that disk store at the original server. This kind of traffic capture/replay is very useful for load testing or for tracking down hard-to-diagnose bugs - and it's easy to write other other stores such as an S3 bucket etc.","title":"Traffic Recording Proxy &amp; Replayer "},{"location":"cookbook/nanoservices/#static-file-server","text":"Requires: http4k-core Longer than the Python SimpleHttpServer , but still pretty small!","title":"Static file Server "},{"location":"cookbook/nanoservices/#websocket-clock","text":"Requires: http4k-core , http4k-server-jetty Like Http handlers, Websockets in http4k can be modelled as simple functions that can be mounted onto a Server, or combined with path patterns if required.","title":"Websocket Clock "},{"location":"cookbook/nanoservices/#chaos-proxy-random-latency-edition","text":"Requires: http4k-core , http4k-testing-chaos As per the Principles of Chaos , this proxy adds Chaotic behaviour to a remote service, which is useful for modelling how a system might behave under various failure modes. Chaos can be dynamically injected via an OpenApi documented set of RPC endpoints.","title":"Chaos Proxy (random latency edition) "},{"location":"cookbook/nestable_routes/","text":"This is a fairly comprehensive example of the core-routing logic available: Individual HTTP endpoints are represented as HttpHandlers . Binding an HttpHandler to a path and HTTP verb yields a Route . Routes can be combined together into a RoutingHttpHandler , which is both an HttpHandler and a Router . A Router is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next Router in the list. Routers can be combined together to form another HttpHandler Usage of supplied core library Filters Serving of static content using a Classpath resource loader Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 Code","title":"Nestable routes"},{"location":"cookbook/nestable_routes/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/nestable_routes/#code","text":"","title":"Code "},{"location":"cookbook/principal_lookup/","text":"Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 When authorising requests, it is common to need to store some credentials or a user principal object to be accessible by a further Filter or the eventual HttpHandler. This can be easily achieved by combining the typesafe RequestContext functionality with one of the built-in authorisation Filters: Code","title":"Principal lookup"},{"location":"cookbook/principal_lookup/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 When authorising requests, it is common to need to store some credentials or a user principal object to be accessible by a further Filter or the eventual HttpHandler. This can be easily achieved by combining the typesafe RequestContext functionality with one of the built-in authorisation Filters:","title":"Gradle setup"},{"location":"cookbook/principal_lookup/#code","text":"","title":"Code "},{"location":"cookbook/record_and_replay/","text":"A set of classes to provide simple recording/replaying of HTTP traffic. This is perfect for testing purposes, or in short lived, low traffic environments where no proper caches are available. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 Caching HTTP Traffic Using Filters it's possible to record traffic and then return recorded content instead of making repeated calls. Note that the provided storage implementations DO NOT have any facility for Cache Control or eviction, or respect any response headers around caching. Requests are indexed in a way optimised for retrieval. Code Recording Streams of HTTP Traffic Using Filters it's possible to record a stream traffic and then replay recorded content instead. Requests are indexed in a way optimised for iteration. Code Concepts The org.http4k.traffic package contains the interfaces which make up the core concepts for traffic capture and replay. These interfaces are: A Sink consumes request/response pairs for storage. A Source provides lookup of pre-stored Response based on an HTTP Request. Replay instances provide streams of HTTP messages as they were received. A ReadWriteCache combines Sink and Source to provide cache-like storage. A ReadWriteStream combines Sink and Replay to provide a stream of traffic which can be replayed. The API has been designed to be modular so API users can provide their own implementations (store in S3 etc..).","title":"Recording/replaying HTTP traffic"},{"location":"cookbook/record_and_replay/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/record_and_replay/#caching-http-traffic","text":"Using Filters it's possible to record traffic and then return recorded content instead of making repeated calls. Note that the provided storage implementations DO NOT have any facility for Cache Control or eviction, or respect any response headers around caching. Requests are indexed in a way optimised for retrieval.","title":"Caching HTTP Traffic"},{"location":"cookbook/record_and_replay/#code","text":"","title":"Code "},{"location":"cookbook/record_and_replay/#recording-streams-of-http-traffic","text":"Using Filters it's possible to record a stream traffic and then replay recorded content instead. Requests are indexed in a way optimised for iteration.","title":"Recording Streams of HTTP Traffic"},{"location":"cookbook/record_and_replay/#code_1","text":"","title":"Code "},{"location":"cookbook/record_and_replay/#concepts","text":"The org.http4k.traffic package contains the interfaces which make up the core concepts for traffic capture and replay. These interfaces are: A Sink consumes request/response pairs for storage. A Source provides lookup of pre-stored Response based on an HTTP Request. Replay instances provide streams of HTTP messages as they were received. A ReadWriteCache combines Sink and Source to provide cache-like storage. A ReadWriteStream combines Sink and Replay to provide a stream of traffic which can be replayed. The API has been designed to be modular so API users can provide their own implementations (store in S3 etc..).","title":"Concepts"},{"location":"cookbook/request_context/","text":"A RequestContext makes it possible to attach objects to a request whilst it is being passed down through the layers of an application. The basic concept is that there is a global shared object which holds a bag of state (indexed by Request). This state can be modified in Filters and then that state accessed inside other Filters or the terminating HttpHandler. There are 2 available choices for manipulating this data: Using simple Strings to represent the keys. Using RequestContextKey s and the Lens mechanism from the http4k-core module. Whilst the first method looks technically simpler, the use of simple Strings does not provide the type-safety of the second, which uses unique shared Key objects to guarantee non-clashing of keys and type-safety of the state. Regardless of which of the above mechanisms are used, an instance of the ServerFilters.InitialiseRequestContext Filter must wrap the HttpHandler(s) to activate the shared bag of state for each request, and to remove the state after the request is complete. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 String-based keys Lens-based keys","title":"Typesafe RequestContexts"},{"location":"cookbook/request_context/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/request_context/#string-based-keys","text":"","title":"String-based keys "},{"location":"cookbook/request_context/#lens-based-keys","text":"","title":"Lens-based keys "},{"location":"cookbook/server_as_a_function/","text":"This example is the simplest possible \"server\" implementation. Note that we are not spinning up a server-backend here - but the entire application(!) is testable by firing HTTP requests at it as if it were. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 Code","title":"Server as a function"},{"location":"cookbook/server_as_a_function/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/server_as_a_function/#code","text":"","title":"Code "},{"location":"cookbook/simple_routing/","text":"This example shows how to use the simple routing functionality to bind several routes Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 Code","title":"Simple routing"},{"location":"cookbook/simple_routing/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/simple_routing/#code","text":"","title":"Code "},{"location":"cookbook/test_driven_apps/","text":"This example shows the various styles of testing endpoints, and requires both the http4k-core and http4k-testing-hamkrest modules: Code","title":"Test driven apps"},{"location":"cookbook/test_driven_apps/#code","text":"","title":"Code "},{"location":"cookbook/typesafe_http_contracts/","text":"This contract example shows: 2 endpoints with typesafe contracts (marshalling of path parameters and bodies) Custom filters (reporting latency) API key security via a typesafe Query parameter (this can be a header or a body parameter as well) OpenApi/Swagger API documentation - Run this example and point a browser here Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-contract , version: 3.113.0 compile group: org.http4k , name: http4k-format-argo , version: 3.113.0 Note: although we use Argo here as our JSON API, you could also switch in any of the http4k-format-xxx JSON modules. Code","title":"Typesafe HTTP contracts"},{"location":"cookbook/typesafe_http_contracts/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-contract , version: 3.113.0 compile group: org.http4k , name: http4k-format-argo , version: 3.113.0 Note: although we use Argo here as our JSON API, you could also switch in any of the http4k-format-xxx JSON modules.","title":"Gradle setup"},{"location":"cookbook/typesafe_http_contracts/#code","text":"","title":"Code "},{"location":"cookbook/typesafe_http_requests_with_lenses/","text":"Example showing how to create and apply lenses to requests and responses to both extract and inject typesafe values out of and into HTTP messages. Note that since the http4k Request/Response objects are immutable, all injection occurs via copy. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 Standard (exception based) approach Errors in extracting Lenses are propagated as exceptions which are caught and handled by the CatchLensFailure Filter. Using custom \"Result\" ADTs An alternative approach to using Exceptions to automatically produce BadRequests is to use an Either-type structure, and this would be easy to implement - but the lack of an in-built Result/Either type in the standard Kotlin library means that we don't have a single representation to use without shackling ourselves to another Either-containing library such as Arrow or Result4k. Additionally, the lack of Higher Kinded Types in Kotlin means that we are unable to provide a generic method for converting standard lenses. However, it is easy to implement an extension method to use in specific use cases. Below is an example which uses a custom Result ADT - this will work for all extraction Lenses that you define: Code","title":"Typesafe HTTP requests with lenses"},{"location":"cookbook/typesafe_http_requests_with_lenses/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/typesafe_http_requests_with_lenses/#standard-exception-based-approach","text":"Errors in extracting Lenses are propagated as exceptions which are caught and handled by the CatchLensFailure Filter.","title":"Standard (exception based) approach "},{"location":"cookbook/typesafe_http_requests_with_lenses/#using-custom-result-adts","text":"An alternative approach to using Exceptions to automatically produce BadRequests is to use an Either-type structure, and this would be easy to implement - but the lack of an in-built Result/Either type in the standard Kotlin library means that we don't have a single representation to use without shackling ourselves to another Either-containing library such as Arrow or Result4k. Additionally, the lack of Higher Kinded Types in Kotlin means that we are unable to provide a generic method for converting standard lenses. However, it is easy to implement an extension method to use in specific use cases. Below is an example which uses a custom Result ADT - this will work for all extraction Lenses that you define:","title":"Using custom \"Result\" ADTs"},{"location":"cookbook/typesafe_http_requests_with_lenses/#code","text":"","title":"Code "},{"location":"cookbook/using_json/","text":"Example of how to use the JSON library API wrappers, in this case the module used is Jackson. http4k provides an identical interface for all JSON implementations. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-format-jackson , version: 3.113.0 Code","title":"JSON messaging"},{"location":"cookbook/using_json/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-format-jackson , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/using_json/#code","text":"","title":"Code "},{"location":"cookbook/using_templates/","text":"Example showing how to use the Templating modules - in this case Handlebars, both by standard response manipulation and via a typesafe view lens. Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-template-handlebars , version: 3.113.0 Code","title":"Templating engines"},{"location":"cookbook/using_templates/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-template-handlebars , version: 3.113.0","title":"Gradle setup"},{"location":"cookbook/using_templates/#code","text":"","title":"Code "},{"location":"cookbook/websockets/","text":"Gradle setup compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-server-jetty , version: 3.113.0 compile group: org.http4k , name: http4k-client-websocket , version: 3.113.0 compile group: org.http4k , name: http4k-format-jackson , version: 3.113.0 http4k provides Websocket support using a simple, consistent, typesafe, and testable API on supported server backends (see above). Websocket communication consists of 3 main concepts: WsHandler - represented as a typealias: WsHandler = (Request) - WsConsumer? . This is responsible for matching an HTTP request to a websocket. WsConsumer - represented as a typealias: WsConsumer = (WebSocket) - Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket. WsMessage - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the http4k HTTP message model, WsMessages are immutable data classes. Websocket as a Function The simplest possible Websocket can be mounted as a WsConsumer function onto a server with: { ws : Websocket - ws . send ( WsMessage ( hello )) }. asServer ( Jetty ( 9000 )). start () Mixing HTTP and Websocket services Both Websockets and Http handlers in http4k are routed using a similar path-based API. We combine them into a single PolyHandler which can handle both http:// and ws:// , and then convert to a Server as usual: Automarshalling Websockets messages Using the standard Lens API, we can auto-convert Websocket messages on and off the wire. This example uses the Jackson for the marshalling: Testing Websockets http4k provides Websockets that are both typesafe (via the Lens API), and testable. Both WsHandlers and PolyHandlers are convertible to a WsClient which provides a synchronous API for testing reactions to Websocket events in an offline environment. In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. http4k provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic:","title":"Websockets"},{"location":"cookbook/websockets/#gradle-setup","text":"compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-server-jetty , version: 3.113.0 compile group: org.http4k , name: http4k-client-websocket , version: 3.113.0 compile group: org.http4k , name: http4k-format-jackson , version: 3.113.0 http4k provides Websocket support using a simple, consistent, typesafe, and testable API on supported server backends (see above). Websocket communication consists of 3 main concepts: WsHandler - represented as a typealias: WsHandler = (Request) - WsConsumer? . This is responsible for matching an HTTP request to a websocket. WsConsumer - represented as a typealias: WsConsumer = (WebSocket) - Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket. WsMessage - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the http4k HTTP message model, WsMessages are immutable data classes.","title":"Gradle setup"},{"location":"cookbook/websockets/#websocket-as-a-function","text":"The simplest possible Websocket can be mounted as a WsConsumer function onto a server with: { ws : Websocket - ws . send ( WsMessage ( hello )) }. asServer ( Jetty ( 9000 )). start ()","title":"Websocket as a Function"},{"location":"cookbook/websockets/#mixing-http-and-websocket-services","text":"Both Websockets and Http handlers in http4k are routed using a similar path-based API. We combine them into a single PolyHandler which can handle both http:// and ws:// , and then convert to a Server as usual:","title":"Mixing HTTP and Websocket services "},{"location":"cookbook/websockets/#automarshalling-websockets-messages","text":"Using the standard Lens API, we can auto-convert Websocket messages on and off the wire. This example uses the Jackson for the marshalling:","title":"Automarshalling Websockets messages "},{"location":"cookbook/websockets/#testing-websockets","text":"http4k provides Websockets that are both typesafe (via the Lens API), and testable. Both WsHandlers and PolyHandlers are convertible to a WsClient which provides a synchronous API for testing reactions to Websocket events in an offline environment. In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. http4k provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic:","title":"Testing Websockets "},{"location":"faq/","text":"Find here answers to the most common questions that we get asked about http4k General Q. Is http4k a library or a framework? A. Although it has many of the features of a framework, we consider http4k to be a library which adds a common HTTP routing layer. It is incredibly unopinionated and has been designed to not enforce design decisions on the API user. We use http4k for applications both large and small, using no DI framework. Q. Is http4k currently used in production? A. Absolutely! The library is currently in use serving the global traffic for a large academic publisher (easily serving 10s of millions of requests per day on a few nodes) and is also being used in production in at least 2 global Investment Banks (that we know of). If you're running http4k in production and would like to be listed on the site as an adopter, please get in touch. Q. Does http4k support an Async model? I need webscale! A. Not at the moment. Adding Async support is a decision that we are thinking about carefully so that we don't end up complicating the API. When we do add it, it'll probably use co-routines and they're still marked as experimental which is another reason we are holding off. As for the scaling arguments, see the above answer relating to production usage. API Q. I'm attempting to build HTTP messages using the API, but changes don't affect the object (e.g. calling request.body(\"hello\") )? A. http4k HTTP message objects are immutable , so you need to chain or reassign the value from the method call to get the updated version. Q. Where are all the useful Filters defined? A. Filters are all in the import org.http4k.filter package and are located as methods on a singleton object relevant to their use: org.http4k.filter.CachingFilters.Request org.http4k.filter.CachingFilters.Response org.http4k.filter.ClientFilters org.http4k.filter.DebuggingFilters org.http4k.filter.ServerFilters org.http4k.filter.TrafficFilters Lenses Auto-Marshalling Q. Where is the Body.auto method defined? A. Body.auto is an extension method which is declared on the parent singleton object for each of the message libraries that supports auto-marshalling - eg. Jackson , Gson , Moshi and Xml . All of these objects are declared in the same package, so you need to add an import similar to: import org.http4k.format.Jackson.auto Q. Declared with Body.auto List XXX ().toLens() , my auto-marshalled List doesn't extract properly! A. This occurs in Jackson and Moshi when serialising bare lists to/from JSON and is to do with the underlying library being lazy in deserialising objects (using LinkedHashTreeMap) ()). Use Body.auto Array MyIntWrapper ().toLens() instead. Yes, it's annoying but we haven't found a way to turn if off. Q. Using Jackson, the Data class auto-marshalling is not working correctly when my JSON fields start with capital letters A. Because of the way in which the Jackson library works, uppercase field names are NOT supported. Either switch out to use http4k-format-gson (which has the same API), or annotate your Data class fields with @JsonAlias to get the deserialisation to work correctly. Q. Using Gson, the data class auto-marshalling does not fail when a null is populated in a Kotlin non-nullable field A. This happens because http4k uses straight GSON demarshalling, of JVM objects with no-Kotlin library in the mix. The nullability generally gets checked at compile-type and the lack of a Kotlin sanity check library exposes this flaw. No current fix - apart from to use the Jackson demarshalling instead! Q. My application uses Lenses, but when they fail I get an HTTP 500 instead of the promised 400. A. You forgot to add the ServerFilters.CatchLensFailure filter to your Server stack.","title":"FAQ"},{"location":"faq/#general","text":"Q. Is http4k a library or a framework? A. Although it has many of the features of a framework, we consider http4k to be a library which adds a common HTTP routing layer. It is incredibly unopinionated and has been designed to not enforce design decisions on the API user. We use http4k for applications both large and small, using no DI framework. Q. Is http4k currently used in production? A. Absolutely! The library is currently in use serving the global traffic for a large academic publisher (easily serving 10s of millions of requests per day on a few nodes) and is also being used in production in at least 2 global Investment Banks (that we know of). If you're running http4k in production and would like to be listed on the site as an adopter, please get in touch. Q. Does http4k support an Async model? I need webscale! A. Not at the moment. Adding Async support is a decision that we are thinking about carefully so that we don't end up complicating the API. When we do add it, it'll probably use co-routines and they're still marked as experimental which is another reason we are holding off. As for the scaling arguments, see the above answer relating to production usage.","title":"General"},{"location":"faq/#api","text":"Q. I'm attempting to build HTTP messages using the API, but changes don't affect the object (e.g. calling request.body(\"hello\") )? A. http4k HTTP message objects are immutable , so you need to chain or reassign the value from the method call to get the updated version. Q. Where are all the useful Filters defined? A. Filters are all in the import org.http4k.filter package and are located as methods on a singleton object relevant to their use: org.http4k.filter.CachingFilters.Request org.http4k.filter.CachingFilters.Response org.http4k.filter.ClientFilters org.http4k.filter.DebuggingFilters org.http4k.filter.ServerFilters org.http4k.filter.TrafficFilters","title":"API"},{"location":"faq/#lenses-auto-marshalling","text":"Q. Where is the Body.auto method defined? A. Body.auto is an extension method which is declared on the parent singleton object for each of the message libraries that supports auto-marshalling - eg. Jackson , Gson , Moshi and Xml . All of these objects are declared in the same package, so you need to add an import similar to: import org.http4k.format.Jackson.auto Q. Declared with Body.auto List XXX ().toLens() , my auto-marshalled List doesn't extract properly! A. This occurs in Jackson and Moshi when serialising bare lists to/from JSON and is to do with the underlying library being lazy in deserialising objects (using LinkedHashTreeMap) ()). Use Body.auto Array MyIntWrapper ().toLens() instead. Yes, it's annoying but we haven't found a way to turn if off. Q. Using Jackson, the Data class auto-marshalling is not working correctly when my JSON fields start with capital letters A. Because of the way in which the Jackson library works, uppercase field names are NOT supported. Either switch out to use http4k-format-gson (which has the same API), or annotate your Data class fields with @JsonAlias to get the deserialisation to work correctly. Q. Using Gson, the data class auto-marshalling does not fail when a null is populated in a Kotlin non-nullable field A. This happens because http4k uses straight GSON demarshalling, of JVM objects with no-Kotlin library in the mix. The nullability generally gets checked at compile-type and the lack of a Kotlin sanity check library exposes this flaw. No current fix - apart from to use the Jackson demarshalling instead! Q. My application uses Lenses, but when they fail I get an HTTP 500 instead of the promised 400. A. You forgot to add the ServerFilters.CatchLensFailure filter to your Server stack.","title":"Lenses &amp; Auto-Marshalling"},{"location":"guide/example/","text":"Application Design What follows is a guide to how we build http4k applications test first to provide excellent test coverage driven by decoupled tests. For this example, we will use an example of a Maths app with the following requirements: The app must add 2 numbers together via an HTTP call The app must multiply 2 numbers together via an HTTP call Answers generated by the service will be logged (via HTTP POST) to another server - the Recorder. Apps can generally be split into 3 tiers: Endpoint: HttpHandlers are constructed individually, by providing a builder function which takes the business-level dependencies. Application: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier. Server: Builder function which takes the configuration for environmental concerns such as ports and downstream urls.","title":"Introduction"},{"location":"guide/example/#application-design","text":"What follows is a guide to how we build http4k applications test first to provide excellent test coverage driven by decoupled tests. For this example, we will use an example of a Maths app with the following requirements: The app must add 2 numbers together via an HTTP call The app must multiply 2 numbers together via an HTTP call Answers generated by the service will be logged (via HTTP POST) to another server - the Recorder. Apps can generally be split into 3 tiers: Endpoint: HttpHandlers are constructed individually, by providing a builder function which takes the business-level dependencies. Application: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier. Server: Builder function which takes the configuration for environmental concerns such as ports and downstream urls.","title":"Application Design"},{"location":"guide/example/_1_building_a_walking_skeleton/","text":"Until we have an application that can be deployed, we cannot create any business value. The Walking Skeleton model dictates that putting the most trivial endpoint into a production environment will prove our deployment pipeline is sound, and helps to set the direction for the testing strategy that we will use going forward. We start with in ICT (In-Container-Test), which have the job of testing server-level concerns such as monitoring, documentation, and checking in a high-level way that the business endpoints are wired correctly. Requirements: The service can be pinged over HTTP to prove that is still alive. Tests: Production:","title":"1. Building a walking skeleton"},{"location":"guide/example/_1_building_a_walking_skeleton/#requirements","text":"The service can be pinged over HTTP to prove that is still alive.","title":"Requirements:"},{"location":"guide/example/_1_building_a_walking_skeleton/#tests","text":"","title":"Tests:"},{"location":"guide/example/_1_building_a_walking_skeleton/#production","text":"","title":"Production:"},{"location":"guide/example/_2_adding_the_first_endpoint/","text":"Starting with another EndToEnd test, we can then drill-down into the functional behaviour of the system by introducing OCT (Out of Container) tests and converting the e2e test to just test endpoint wiring (so far). The common assertions have also been converted to reusable extension methods on Response. Requirements: Implement an \"add\" service, which will sum a number of integer values. Tests: Production:","title":"2. Adding an endpoint"},{"location":"guide/example/_2_adding_the_first_endpoint/#requirements","text":"Implement an \"add\" service, which will sum a number of integer values.","title":"Requirements:"},{"location":"guide/example/_2_adding_the_first_endpoint/#tests","text":"","title":"Tests:"},{"location":"guide/example/_2_adding_the_first_endpoint/#production","text":"","title":"Production:"},{"location":"guide/example/_3_adding_the_second_endpoint/","text":"Requirements: Implement a \"multiply\" service, which will find the product of a number of integer values. Tests: Production:","title":"3. Adding another endpoint"},{"location":"guide/example/_3_adding_the_second_endpoint/#requirements","text":"Implement a \"multiply\" service, which will find the product of a number of integer values.","title":"Requirements:"},{"location":"guide/example/_3_adding_the_second_endpoint/#tests","text":"","title":"Tests:"},{"location":"guide/example/_3_adding_the_second_endpoint/#production","text":"","title":"Production:"},{"location":"guide/example/_4_adding_an_external_dependency/","text":"At this point, the separation of the layers starts to become clear: - The server layer is responsible for taking external configuration and instantiating the app layer. - The application layer API is only in terms of HTTP transports - it constructs business level abstractions which are passed down into to the individual endpoints The process here is to create fake versions of the dependency which can be tested against through the business interface. This requires another style of testing, CDCs (Consumer Driven Contracts), to be created. These contract tests ensure that our interactions with the external service are valid. Requirements: Results from calculations should be POSTed via HTTP to another \"answer recording\" service. Implementation Notes: The following process is followed to us to the final state, whilst always allowing us to keep the build green: Determine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer} Create RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder Create FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement Include the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything) Pass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler Factor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done Introduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment Alter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp In MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record() Tests: Production:","title":"4. An external dependency"},{"location":"guide/example/_4_adding_an_external_dependency/#requirements","text":"Results from calculations should be POSTed via HTTP to another \"answer recording\" service.","title":"Requirements:"},{"location":"guide/example/_4_adding_an_external_dependency/#implementation-notes","text":"The following process is followed to us to the final state, whilst always allowing us to keep the build green: Determine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer} Create RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder Create FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement Include the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything) Pass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler Factor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done Introduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment Alter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp In MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record()","title":"Implementation Notes:"},{"location":"guide/example/_4_adding_an_external_dependency/#tests","text":"","title":"Tests:"},{"location":"guide/example/_4_adding_an_external_dependency/#production","text":"","title":"Production:"},{"location":"guide/modules/aws/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-aws\", version: \"3.113.0\" About This module provides super-simple AWS request signing functionality for talking to AWS services. Once configured with the correct keys, the various AWS services are actually really simple to integrate with they're just RESTy-type HTTPS services - the main difficulty is that all requests need to have their contents digitally signed with the AWS credentials to be authorised. http4k provides a Filter which does this request signing process. Just decorate a standard HTTP client and then make the relevant calls: Code","title":"AWS"},{"location":"guide/modules/aws/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-aws\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/aws/#about","text":"This module provides super-simple AWS request signing functionality for talking to AWS services. Once configured with the correct keys, the various AWS services are actually really simple to integrate with they're just RESTy-type HTTPS services - the main difficulty is that all requests need to have their contents digitally signed with the AWS credentials to be authorised. http4k provides a Filter which does this request signing process. Just decorate a standard HTTP client and then make the relevant calls:","title":"About"},{"location":"guide/modules/aws/#code","text":"","title":"Code "},{"location":"guide/modules/chaos/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-testing-chaos\", version: \"3.113.0\" About The http4k Chaos module provides the facility to statically or dynamically inject failure modes into http4k applications, such as random HTTP failures, killing of processes, and extra latency injection. By modelling these modes, it is possible to plan for mitigation of particular scenarios on a wider scale, resulting either from failures within your system boundary, or those caused by dependent remote HTTP services. The Principles of Chaos Engineering approach was made prominent by Netflix open-sourcing the Simian Army libraries. API concepts To understand the API, these domain-language concepts are important, all modelled as simple Kotlin typealiases and interfaces in order that API users can create their own: Behaviours: typealias Behaviour = Filter A Behaviour applies the failure mode to the HTTP call. This could involve blocking a thread permanently, introducing extra latency into an HTTP service, or even causing a Stack Overflow or Killing the running process. Behaviour function Effect as JSON Latency Adds random latency to a call between the min and max durations {\"type\":\"latency\",\"min\":\"PT0.1S\",\"max\":\"PT0.3S\"} ThrowException Throws an uncaught Exception with the supplied message {\"type\":\"throw\",\"message\":\"foo\"} ReturnStatus Returns an HTTP response with the specified HTTP status code {\"type\":\"status\",\"status\":404} NoBody Completes the call normally, but strips the body content from the response {\"type\":\"body\"} EatMemory Forces an OOM exception {\"type\":\"memory\"} KillProcess Kills the Java process with a 1 error code {\"type\":\"kill\"} StackOverflow Generates a StackOverflow {\"type\":\"overflow\"} BlockThread Permanently blocks the request thread {\"type\":\"block\"} None Requests complete normally {\"type\":\"none\"} Triggers: typealias Trigger = (req: Request) - Boolean A Trigger is just a predicate which determines if an HTTP call should have an Behaviour applied to it. Triggers can be stateless, based on the request content, or stateful - deadlines or countdowns. Trigger function Activation condition as JSON Deadline After an instant in time {\"type\":\"deadline\",\"endTime\":\"1970-01-01T00:00:00Z\"} Delay After a specified period (since construction) {\"type\":\"delay\",\"period\":\"PT0.1S\"} Countdown For the first n requests only {\"type\":\"countdown\",\"count\":\"1\"} Request If the request meets the criteria set out in the specification. All but method are Regex patterns, and all are optional {\"type\":\"request\",\"method\":\"get\",\"path\":\".*bob\",\"queries\":{\"query\":\".*query\"},\"headers\":{\"header\":\".*header\"},\"body\":\".*body\"} Once For the first request only {\"type\":\"once\"} PercentageBased Applies to a certain (randomly decided) percentage of requests {\"type\":\"percentage\", \"percentage\":100} Always For all requests {\"type\":\"always\"} Stages: interface Stage: (Request) - Filter? A Stage provides the lifecycle for applying a behaviour, and applies until a Trigger indicates that the stage is complete. Stages can be chained with then() , or can be produced by combining a Behaviour and a Trigger using appliedWhen() . Stage function Lifecycle notes as JSON Wait Does nothing while active {\"type\":\"wait\",\"until\": insert trigger json } Repeat Loops through the stages and then repeats {\"type\":\"repeat\",\"stages\":[ insert stage json elements ],\"until\": insert trigger json } (Triggered) Combines a Trigger and a Behaviour {\"type\":\"trigger\",\"behaviour\":{\"type\":\"body\"},\"trigger\": insert trigger json ,\"until\": insert trigger json }} Manually injecting Chaos For use in automated test suites, it is simple to define the Chaos behaviour programmatically using the API and then apply it as a Filter onto an existing application. Code Dynamic behaviour injection using Chaos Controls For use in deployed environments or when experimenting with the reaction of systems to failure, there is the need to vary (and otherwise control) the Chaos behaviour that an application or downstream fake exhibits, in order to simulate periods of failures and then observe the after-effects. The module contains a simple extension method HttpHandler.withChaosControls() that decorates an existing http4k application with the ability to dynamically inject Chaos behaviour using a set of RPC-style endpoints. This API is presented via an OpenAPI specification, which allows it to be controlled by a simple Swagger client. Apart from being able to turn the Chaos on/off and check the status, the most powerful endpoint in ChaosControls lives at /activate/new . By POSTing a JSON definition of the required behaviour, this JSON is deserialised into actual Chaos behaviours which can be then activated in the application. The supported JSON formats of the various Chaos concepts are defined above, but by way of an example, POSTing this piece of JSON would: Wait for 100 seconds Always return an HTTP 404 (Not Found) status for 10 requests Repeat the above until Big Ben strikes in the New Year 2020. [ { type : repeat , stages : [ { type : wait , until : { type : delay , period : PT100S } }, { type : trigger , behaviour : { type : status , status : 404 }, trigger : { type : always , }, until : { type : countdown , count : 10 } } ], until : { type : deadline , endTime : 2020-01-01T00:00:00Z } } ] Code Interacting with ChaosControls using an HTTP client Code","title":"Chaos Testing"},{"location":"guide/modules/chaos/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-testing-chaos\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/chaos/#about","text":"The http4k Chaos module provides the facility to statically or dynamically inject failure modes into http4k applications, such as random HTTP failures, killing of processes, and extra latency injection. By modelling these modes, it is possible to plan for mitigation of particular scenarios on a wider scale, resulting either from failures within your system boundary, or those caused by dependent remote HTTP services. The Principles of Chaos Engineering approach was made prominent by Netflix open-sourcing the Simian Army libraries.","title":"About"},{"location":"guide/modules/chaos/#api-concepts","text":"To understand the API, these domain-language concepts are important, all modelled as simple Kotlin typealiases and interfaces in order that API users can create their own:","title":"API concepts"},{"location":"guide/modules/chaos/#behaviours-typealias-behaviour-filter","text":"A Behaviour applies the failure mode to the HTTP call. This could involve blocking a thread permanently, introducing extra latency into an HTTP service, or even causing a Stack Overflow or Killing the running process. Behaviour function Effect as JSON Latency Adds random latency to a call between the min and max durations {\"type\":\"latency\",\"min\":\"PT0.1S\",\"max\":\"PT0.3S\"} ThrowException Throws an uncaught Exception with the supplied message {\"type\":\"throw\",\"message\":\"foo\"} ReturnStatus Returns an HTTP response with the specified HTTP status code {\"type\":\"status\",\"status\":404} NoBody Completes the call normally, but strips the body content from the response {\"type\":\"body\"} EatMemory Forces an OOM exception {\"type\":\"memory\"} KillProcess Kills the Java process with a 1 error code {\"type\":\"kill\"} StackOverflow Generates a StackOverflow {\"type\":\"overflow\"} BlockThread Permanently blocks the request thread {\"type\":\"block\"} None Requests complete normally {\"type\":\"none\"}","title":"Behaviours: typealias Behaviour = Filter"},{"location":"guide/modules/chaos/#triggers-typealias-trigger-req-request-gt-boolean","text":"A Trigger is just a predicate which determines if an HTTP call should have an Behaviour applied to it. Triggers can be stateless, based on the request content, or stateful - deadlines or countdowns. Trigger function Activation condition as JSON Deadline After an instant in time {\"type\":\"deadline\",\"endTime\":\"1970-01-01T00:00:00Z\"} Delay After a specified period (since construction) {\"type\":\"delay\",\"period\":\"PT0.1S\"} Countdown For the first n requests only {\"type\":\"countdown\",\"count\":\"1\"} Request If the request meets the criteria set out in the specification. All but method are Regex patterns, and all are optional {\"type\":\"request\",\"method\":\"get\",\"path\":\".*bob\",\"queries\":{\"query\":\".*query\"},\"headers\":{\"header\":\".*header\"},\"body\":\".*body\"} Once For the first request only {\"type\":\"once\"} PercentageBased Applies to a certain (randomly decided) percentage of requests {\"type\":\"percentage\", \"percentage\":100} Always For all requests {\"type\":\"always\"}","title":"Triggers: typealias Trigger = (req: Request) -&gt; Boolean"},{"location":"guide/modules/chaos/#stages-interface-stage-request-gt-filter","text":"A Stage provides the lifecycle for applying a behaviour, and applies until a Trigger indicates that the stage is complete. Stages can be chained with then() , or can be produced by combining a Behaviour and a Trigger using appliedWhen() . Stage function Lifecycle notes as JSON Wait Does nothing while active {\"type\":\"wait\",\"until\": insert trigger json } Repeat Loops through the stages and then repeats {\"type\":\"repeat\",\"stages\":[ insert stage json elements ],\"until\": insert trigger json } (Triggered) Combines a Trigger and a Behaviour {\"type\":\"trigger\",\"behaviour\":{\"type\":\"body\"},\"trigger\": insert trigger json ,\"until\": insert trigger json }}","title":"Stages: interface Stage: (Request) -&gt; Filter?"},{"location":"guide/modules/chaos/#manually-injecting-chaos","text":"For use in automated test suites, it is simple to define the Chaos behaviour programmatically using the API and then apply it as a Filter onto an existing application.","title":"Manually injecting Chaos"},{"location":"guide/modules/chaos/#code","text":"","title":"Code "},{"location":"guide/modules/chaos/#dynamic-behaviour-injection-using-chaos-controls","text":"For use in deployed environments or when experimenting with the reaction of systems to failure, there is the need to vary (and otherwise control) the Chaos behaviour that an application or downstream fake exhibits, in order to simulate periods of failures and then observe the after-effects. The module contains a simple extension method HttpHandler.withChaosControls() that decorates an existing http4k application with the ability to dynamically inject Chaos behaviour using a set of RPC-style endpoints. This API is presented via an OpenAPI specification, which allows it to be controlled by a simple Swagger client. Apart from being able to turn the Chaos on/off and check the status, the most powerful endpoint in ChaosControls lives at /activate/new . By POSTing a JSON definition of the required behaviour, this JSON is deserialised into actual Chaos behaviours which can be then activated in the application. The supported JSON formats of the various Chaos concepts are defined above, but by way of an example, POSTing this piece of JSON would: Wait for 100 seconds Always return an HTTP 404 (Not Found) status for 10 requests Repeat the above until Big Ben strikes in the New Year 2020. [ { type : repeat , stages : [ { type : wait , until : { type : delay , period : PT100S } }, { type : trigger , behaviour : { type : status , status : 404 }, trigger : { type : always , }, until : { type : countdown , count : 10 } } ], until : { type : deadline , endTime : 2020-01-01T00:00:00Z } } ]","title":"Dynamic behaviour injection using Chaos Controls"},{"location":"guide/modules/chaos/#code_1","text":"","title":"Code "},{"location":"guide/modules/chaos/#interacting-with-chaoscontrols-using-an-http-client","text":"","title":"Interacting with ChaosControls using an HTTP client"},{"location":"guide/modules/chaos/#code_2","text":"","title":"Code "},{"location":"guide/modules/clients/","text":"Installation (Gradle) Java (for development only): compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.113.0\" Apache (Sync): compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"3.113.0\" Apache (Async): compile group: \"org.http4k\", name: \"http4k-client-apache-async\", version: \"3.113.0\" Jetty (Sync + Async): compile group: \"org.http4k\", name: \"http4k-client-jetty\", version: \"3.113.0\" OkHttp (Sync + Async): compile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"3.113.0\" Websocket: compile group: \"org.http4k\", name: \"http4k-client-websocket\", version: \"3.113.0\" HTTP Supported HTTP client adapter APIs are wrapped to provide an HttpHandler interface in 1 LOC. Activate streaming mode by passing a BodyMode (default is non-streaming). These examples are for the Apache HTTP client, but the API is similar for the others: Code Additionally, all HTTP client adapter modules allow for custom configuration of the relevant underlying client. Async-supporting clients implement the AsyncHttpClient interface can be passed a callback. Websocket http4k supplies both blocking and non-blocking Websocket clients. The former is perfect for integration testing purposes, and as it uses the same interface WsClient as the in-memory test client ( WsHandler.testWsClient() ) it is simple to write unit tests which can then be reused as system tests by virtue of swapping out the client. Code","title":"HTTP/Websocket clients"},{"location":"guide/modules/clients/#installation-gradle","text":"Java (for development only): compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.113.0\" Apache (Sync): compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"3.113.0\" Apache (Async): compile group: \"org.http4k\", name: \"http4k-client-apache-async\", version: \"3.113.0\" Jetty (Sync + Async): compile group: \"org.http4k\", name: \"http4k-client-jetty\", version: \"3.113.0\" OkHttp (Sync + Async): compile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"3.113.0\" Websocket: compile group: \"org.http4k\", name: \"http4k-client-websocket\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/clients/#http","text":"Supported HTTP client adapter APIs are wrapped to provide an HttpHandler interface in 1 LOC. Activate streaming mode by passing a BodyMode (default is non-streaming). These examples are for the Apache HTTP client, but the API is similar for the others:","title":"HTTP"},{"location":"guide/modules/clients/#code","text":"Additionally, all HTTP client adapter modules allow for custom configuration of the relevant underlying client. Async-supporting clients implement the AsyncHttpClient interface can be passed a callback.","title":"Code "},{"location":"guide/modules/clients/#websocket","text":"http4k supplies both blocking and non-blocking Websocket clients. The former is perfect for integration testing purposes, and as it uses the same interface WsClient as the in-memory test client ( WsHandler.testWsClient() ) it is simple to write unit tests which can then be reused as system tests by virtue of swapping out the client.","title":"Websocket"},{"location":"guide/modules/clients/#code_1","text":"","title":"Code "},{"location":"guide/modules/cloud_native/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-cloudnative\", version: \"3.113.0\" http4k applications are naturally at home operating in distributed, Cloud Native environments. Whilst simple to create, this module provides requisite tooling to get apps up and running with the minimum of effort to enable the following operational aspects: Quick start Because http4k does not use reflection or annotation process for application startup, all of the supported Server-backends start up and shutdown very quickly - this is crucial for cloud-based environments where an orchestration framework might move instances around to redistribute load or avoid problematic server/rack/DCs. Configuration All application configuration should be injected via environmental variables. http4k provides an Environment object, along with typesafe variable binding using the in-built Lenses mechanism. This typesafe API is consistent with the other usages of Lenses throughout http4k, so should have a near-zero learning curve. Also provided are a set of extension methods for retrieving standard environmental config for service ports from Kubernetes. Observability Orchestration software such as Kubernetes and CloudFoundry regularly query a set of diagnostic endpoints to monitor the state of an application. This module provides standardised HttpHandler implementations to model the following endpoints: Liveness - used to determine if the application is actually alive. Readiness - used to determine if the application is available to receive production traffic from the cloud Load Balancer. This endpoint performs a series of diagnostic checks against it's dependencies (such as database connectivity) and collates the results to report back to the orchestrator. http4k provides the ReadinessCheck interface which can be implementaed as required and plugged into the endpoint. In Kubernetes, his set of endpoints is generally hosted on a second port to avoid the API clashes, so http4k provides the machinery to easily start these services on a different port to the main application API via the Http4kK8sServer object. Code","title":"Cloud native"},{"location":"guide/modules/cloud_native/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-cloudnative\", version: \"3.113.0\" http4k applications are naturally at home operating in distributed, Cloud Native environments. Whilst simple to create, this module provides requisite tooling to get apps up and running with the minimum of effort to enable the following operational aspects:","title":"Installation (Gradle)"},{"location":"guide/modules/cloud_native/#quick-start","text":"Because http4k does not use reflection or annotation process for application startup, all of the supported Server-backends start up and shutdown very quickly - this is crucial for cloud-based environments where an orchestration framework might move instances around to redistribute load or avoid problematic server/rack/DCs.","title":"Quick start"},{"location":"guide/modules/cloud_native/#configuration","text":"All application configuration should be injected via environmental variables. http4k provides an Environment object, along with typesafe variable binding using the in-built Lenses mechanism. This typesafe API is consistent with the other usages of Lenses throughout http4k, so should have a near-zero learning curve. Also provided are a set of extension methods for retrieving standard environmental config for service ports from Kubernetes.","title":"Configuration"},{"location":"guide/modules/cloud_native/#observability","text":"Orchestration software such as Kubernetes and CloudFoundry regularly query a set of diagnostic endpoints to monitor the state of an application. This module provides standardised HttpHandler implementations to model the following endpoints: Liveness - used to determine if the application is actually alive. Readiness - used to determine if the application is available to receive production traffic from the cloud Load Balancer. This endpoint performs a series of diagnostic checks against it's dependencies (such as database connectivity) and collates the results to report back to the orchestrator. http4k provides the ReadinessCheck interface which can be implementaed as required and plugged into the endpoint. In Kubernetes, his set of endpoints is generally hosted on a second port to avoid the API clashes, so http4k provides the machinery to easily start these services on a different port to the main application API via the Http4kK8sServer object.","title":"Observability"},{"location":"guide/modules/cloud_native/#code","text":"","title":"Code "},{"location":"guide/modules/contracts/","text":"Installation (Gradle) compile group: org.http4k , name: http4k-contract , version: 3.113.0 compile group: org.http4k , name: http4k-format- insert json lib , version: 3.113.0 About The http4k-contract module adds a much more sophisticated routing mechanism to that available in http4k-core . It adds the facility to declare server-side Routes in a completely typesafe way, leveraging the Lens functionality from the core. These Routes are combined into RouteModules , which have the following features: Auto-validating - the Route contract is automatically validated on each call for required-fields and type conversions, removing the requirement for any validation code to be written by the API user. Invalid calls result in a HTTP 400 (BAD_REQUEST) response. Self-describing: - a generated endpoint is provided which describes all of the Routes in that module. Implementations include OpenApi/Swagger documentation, including generation of [JSON schema] (http://json-schema.org/) models for messages. Security: to secure the Routes against unauthorised access. Current implementations include ApiKey . Code When launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module. Code When launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module. For a more extended example, see the following example apps: Todo backend (typesafe contract version) TDD'd example application","title":"Typesafe contracts"},{"location":"guide/modules/contracts/#installation-gradle","text":"compile group: org.http4k , name: http4k-contract , version: 3.113.0 compile group: org.http4k , name: http4k-format- insert json lib , version: 3.113.0","title":"Installation (Gradle)"},{"location":"guide/modules/contracts/#about","text":"The http4k-contract module adds a much more sophisticated routing mechanism to that available in http4k-core . It adds the facility to declare server-side Routes in a completely typesafe way, leveraging the Lens functionality from the core. These Routes are combined into RouteModules , which have the following features: Auto-validating - the Route contract is automatically validated on each call for required-fields and type conversions, removing the requirement for any validation code to be written by the API user. Invalid calls result in a HTTP 400 (BAD_REQUEST) response. Self-describing: - a generated endpoint is provided which describes all of the Routes in that module. Implementations include OpenApi/Swagger documentation, including generation of [JSON schema] (http://json-schema.org/) models for messages. Security: to secure the Routes against unauthorised access. Current implementations include ApiKey .","title":"About"},{"location":"guide/modules/contracts/#code","text":"When launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module.","title":"Code "},{"location":"guide/modules/contracts/#code_1","text":"When launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module. For a more extended example, see the following example apps: Todo backend (typesafe contract version) TDD'd example application","title":"Code "},{"location":"guide/modules/core/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.113.0\" About Apart from Kotlin StdLib, the core module has ZERO dependencies and provides the following: Immutable versions of the HTTP spec objects (Request, Response, Cookies etc). HTTP handler and filter abstractions which models services as simple, composable functions. Simple routing implementation, plus HttpHandlerServlet to enable plugging into any Servlet engine. Lens mechanism for typesafe destructuring and construction of HTTP messages. Typesafe Request Context operations using Lenses. Abstractions for Servers, Clients, JSON Message formats, Templating, Websockets etc. SunHttp Ultra-fast single-LOC development server-backend Static file-serving capability with Caching and Hot-Reload APIs to record and replay HTTP traffic to disk or memory HttpHandlers In http4k , an HTTP service is just a typealias of a simple function: typealias HttpHandler = ( Request ) - Response First described in this Twitter paper \"Your Server as a Function\" , this abstraction allows us lots of flexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an HttpHandler , neither do we need to launch a real HTTP container to exercise it: val handler = { request : Request - Response ( OK ). body ( Hello, ${request.query( name )}! ) } val get = Request ( Method . GET , / ). query ( name , John Doe ) val response = handler ( get ) println ( response . status ) println ( response . bodyString ()) To mount the HttpHandler in a container, the can simply be converted to a Servlet by calling handler.asServlet() Filters Filters add extra processing to either the Request or Response. In http4k , they are modelled as: interface Filter : ( HttpHandler ) - HttpHandler Filters are designed to simply compose together (using then() ) , creating reusable stacks of behaviour which can then be applied to any HttpHandler . For example, to add Basic Auth and latency reporting to a service: val handler = { _ : Request - Response ( OK ) } val myFilter = Filter { next : HttpHandler - { request : Request - val start = System . currentTimeMillis () val response = next ( request ) val latency = System . currentTimeMillis () - start println ( I took $latency ms ) response } } val latencyAndBasicAuth : HttpHandler = ServerFilters . BasicAuth ( my realm , user , password ). then ( myFilter ) val app : HttpHandler = latencyAndBasicAuth . then ( handler ) The http4k-core module comes with a set of handy Filters for application to both Server and Client HttpHandlers , covering common things like: Request tracing headers (x-b3-traceid etc) Basic Auth Cache Control CORS Cookie handling Debugging request and responses Check out the org.http4k.filter package for the exact list. Routers - Nestable, path-based Routing Create a Router using routes() to bind a static or dynamic path to either an HttpHandler, or to another sub-Router. These Routers can be nested infinitely deep and http4k will search for a matching route using a depth-first search algorithm, before falling back finally to a 404: routes ( /hello bind routes ( /{name:.*} bind GET to { request : Request - Response ( OK ). body ( Hello, ${request.path( name )}! ) } ), /fail bind POST to { request : Request - Response ( INTERNAL_SERVER_ERROR ) } ). asServer ( Jetty ( 8000 )). start () Note that the http4k-contract module contains a more typesafe implementation of routing functionality, with runtime-generated live documentation in OpenApi/Swagger format. Typesafe parameter destructuring/construction of HTTP messages with Lenses Getting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. For this purpose, we can use a Lens . A Lens is a bi-directional entity which can be used to either get or set a particular value from/onto an HTTP message. http4k provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional). To utilise a lens, first you have to declare it with the form Location . configuration and mapping operations . terminator . There is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location: Location Starting type Applicable to Multiplicity Requirement terminator Examples Query String Request Singular or multiple Optional or Required Query.optional(\"name\") Query.required(\"name\") Query.int().required(\"name\") Query.localDate().multi.required(\"name\") Query.map(::CustomType, { it.value }).required(\"name\") Header String Request or Response Singular or multiple Optional or Required Header.optional(\"name\") Header.required(\"name\") Header.int().required(\"name\") Header.localDate().multi.required(\"name\") Header.map(::CustomType, { it.value }).required(\"name\") Path String Request Singular Required Path.of(\"name\") Path.int().of(\"name\") Path.map(::CustomType, { it.value }).of(\"name\") FormField String WebForm Singular or multiple Optional or Required FormField.optional(\"name\") FormField.required(\"name\") FormField.int().required(\"name\") FormField.localDate().multi.required(\"name\") FormField.map(::CustomType, { it.value }).required(\"name\") Body ByteBuffer Request or Response Singular Required Body.string(ContentType.TEXT_PLAIN).toLens() Body.json().toLens() Body.webForm(Validator.Strict, FormField.required(\"name\")).toLens() Once the lens is declared, you can use it on a target object to either get or set the value: Retrieving a value: use lens .extract( target ) , or the more concise invoke form: lens ( target ) Setting a value: use lens .inject( value , target ) , or the more concise invoke form: lens ( value , target ) Code Serving static assets For serving static assets, just bind a path to a Static block as below, using either a Classpath or Directory (Hot reloading) based ResourceLoader instance (find these on the ResourceLoader companion object). Typically, Directory is used during development and the Classpath strategy is used to serve assets in production from an UberJar. This is usually based on a \"devmode\" flag when constructing your app\": routes ( /static bind static ( Classpath ( /org/http4k/some/package/name )), /hotreload bind static ( Directory ( path/to/static/dir/goes/here )) ) Typesafe Websockets. Websockets have been modeled using the same methodology as standard HTTP endpoints - ie. with both simplicity and testability as a first class concern, as well as benefiting from Lens-based typesafety. Websocket communication consists of 3 main concepts: WsHandler - represented as a typealias: WsHandler = (Request) - WsConsumer? . This is responsible for matching an HTTP request to a websocket. WsConsumer - represented as a typealias: WsConsumer = (WebSocket) - Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket. WsMessage - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the http4k HTTP message model, WsMessages are immutable data classes. The routing aspect of Websockets is done using a very similar API to the standard HTTP routing for HTTP messages and dynamic parts of the upgrade request are available when constructing a websocket instance: data class Wrapper ( val value : String ) val body = WsMessage . string (). map ( :: Wrapper , Wrapper :: value ). toLens () val nameLens = Path . of ( name ) val ws : WsHandler = websockets ( /hello bind websockets ( /{name} bind { ws : WebSocket - val name = nameLens ( ws . upgradeRequest ) ws . send ( WsMessage ( hello $name )) ws . onMessage { val received = body ( it ) ws . send ( body ( received )) } ws . onClose { println ( closed ) } } ) ) A WsHandler can be combined with an HttpHandler into a PolyHandler and then mounted into a supported backend server using asServer() : val app = PolyHandler ( routes ( / bind { r : Request - Response ( OK ) } ), websockets ( /ws bind { ws : WebSocket - ws . send ( WsMessage ( hello! )) } ) ) app . asServer ( Jetty ( 9000 )). start () Alternatively, the WsHandler can be also converted to a synchronous WsClient - this allows testing to be done completely offline, which allows for super-fast tests: val client = app . testWsClient ( Request ( Method . GET , ws://localhost:9000/hello/bob )) !! client . send ( WsMessage ( 1 )) client . close ( Status ( 200 , bob )) client . received . take ( 2 ). forEach ( :: println ) Request and Response toString() The HttpMessages used by http4k toString in the HTTP wire format, which it simple to capture and replay HTTP message streams later in a similar way to tools like Mountebank . CURL format Creates curl command for a given request - this is useful to include in audit logs so exact requests can be replayed if required: val curl = Request ( POST , http://httpbin.org/post ). body ( listOf ( foo to bar ). toBody ()). toCurl () // curl -X POST --data foo=bar http://httpbin.org/post","title":"Core"},{"location":"guide/modules/core/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/core/#about","text":"Apart from Kotlin StdLib, the core module has ZERO dependencies and provides the following: Immutable versions of the HTTP spec objects (Request, Response, Cookies etc). HTTP handler and filter abstractions which models services as simple, composable functions. Simple routing implementation, plus HttpHandlerServlet to enable plugging into any Servlet engine. Lens mechanism for typesafe destructuring and construction of HTTP messages. Typesafe Request Context operations using Lenses. Abstractions for Servers, Clients, JSON Message formats, Templating, Websockets etc. SunHttp Ultra-fast single-LOC development server-backend Static file-serving capability with Caching and Hot-Reload APIs to record and replay HTTP traffic to disk or memory","title":"About"},{"location":"guide/modules/core/#httphandlers","text":"In http4k , an HTTP service is just a typealias of a simple function: typealias HttpHandler = ( Request ) - Response First described in this Twitter paper \"Your Server as a Function\" , this abstraction allows us lots of flexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an HttpHandler , neither do we need to launch a real HTTP container to exercise it: val handler = { request : Request - Response ( OK ). body ( Hello, ${request.query( name )}! ) } val get = Request ( Method . GET , / ). query ( name , John Doe ) val response = handler ( get ) println ( response . status ) println ( response . bodyString ()) To mount the HttpHandler in a container, the can simply be converted to a Servlet by calling handler.asServlet()","title":"HttpHandlers"},{"location":"guide/modules/core/#filters","text":"Filters add extra processing to either the Request or Response. In http4k , they are modelled as: interface Filter : ( HttpHandler ) - HttpHandler Filters are designed to simply compose together (using then() ) , creating reusable stacks of behaviour which can then be applied to any HttpHandler . For example, to add Basic Auth and latency reporting to a service: val handler = { _ : Request - Response ( OK ) } val myFilter = Filter { next : HttpHandler - { request : Request - val start = System . currentTimeMillis () val response = next ( request ) val latency = System . currentTimeMillis () - start println ( I took $latency ms ) response } } val latencyAndBasicAuth : HttpHandler = ServerFilters . BasicAuth ( my realm , user , password ). then ( myFilter ) val app : HttpHandler = latencyAndBasicAuth . then ( handler ) The http4k-core module comes with a set of handy Filters for application to both Server and Client HttpHandlers , covering common things like: Request tracing headers (x-b3-traceid etc) Basic Auth Cache Control CORS Cookie handling Debugging request and responses Check out the org.http4k.filter package for the exact list.","title":"Filters"},{"location":"guide/modules/core/#routers-nestable-path-based-routing","text":"Create a Router using routes() to bind a static or dynamic path to either an HttpHandler, or to another sub-Router. These Routers can be nested infinitely deep and http4k will search for a matching route using a depth-first search algorithm, before falling back finally to a 404: routes ( /hello bind routes ( /{name:.*} bind GET to { request : Request - Response ( OK ). body ( Hello, ${request.path( name )}! ) } ), /fail bind POST to { request : Request - Response ( INTERNAL_SERVER_ERROR ) } ). asServer ( Jetty ( 8000 )). start () Note that the http4k-contract module contains a more typesafe implementation of routing functionality, with runtime-generated live documentation in OpenApi/Swagger format.","title":"Routers - Nestable, path-based Routing"},{"location":"guide/modules/core/#typesafe-parameter-destructuringconstruction-of-http-messages-with-lenses","text":"Getting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. For this purpose, we can use a Lens . A Lens is a bi-directional entity which can be used to either get or set a particular value from/onto an HTTP message. http4k provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional). To utilise a lens, first you have to declare it with the form Location . configuration and mapping operations . terminator . There is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location: Location Starting type Applicable to Multiplicity Requirement terminator Examples Query String Request Singular or multiple Optional or Required Query.optional(\"name\") Query.required(\"name\") Query.int().required(\"name\") Query.localDate().multi.required(\"name\") Query.map(::CustomType, { it.value }).required(\"name\") Header String Request or Response Singular or multiple Optional or Required Header.optional(\"name\") Header.required(\"name\") Header.int().required(\"name\") Header.localDate().multi.required(\"name\") Header.map(::CustomType, { it.value }).required(\"name\") Path String Request Singular Required Path.of(\"name\") Path.int().of(\"name\") Path.map(::CustomType, { it.value }).of(\"name\") FormField String WebForm Singular or multiple Optional or Required FormField.optional(\"name\") FormField.required(\"name\") FormField.int().required(\"name\") FormField.localDate().multi.required(\"name\") FormField.map(::CustomType, { it.value }).required(\"name\") Body ByteBuffer Request or Response Singular Required Body.string(ContentType.TEXT_PLAIN).toLens() Body.json().toLens() Body.webForm(Validator.Strict, FormField.required(\"name\")).toLens() Once the lens is declared, you can use it on a target object to either get or set the value: Retrieving a value: use lens .extract( target ) , or the more concise invoke form: lens ( target ) Setting a value: use lens .inject( value , target ) , or the more concise invoke form: lens ( value , target )","title":"Typesafe parameter destructuring/construction of HTTP messages with Lenses"},{"location":"guide/modules/core/#code","text":"","title":"Code "},{"location":"guide/modules/core/#serving-static-assets","text":"For serving static assets, just bind a path to a Static block as below, using either a Classpath or Directory (Hot reloading) based ResourceLoader instance (find these on the ResourceLoader companion object). Typically, Directory is used during development and the Classpath strategy is used to serve assets in production from an UberJar. This is usually based on a \"devmode\" flag when constructing your app\": routes ( /static bind static ( Classpath ( /org/http4k/some/package/name )), /hotreload bind static ( Directory ( path/to/static/dir/goes/here )) )","title":"Serving static assets"},{"location":"guide/modules/core/#typesafe-websockets","text":"Websockets have been modeled using the same methodology as standard HTTP endpoints - ie. with both simplicity and testability as a first class concern, as well as benefiting from Lens-based typesafety. Websocket communication consists of 3 main concepts: WsHandler - represented as a typealias: WsHandler = (Request) - WsConsumer? . This is responsible for matching an HTTP request to a websocket. WsConsumer - represented as a typealias: WsConsumer = (WebSocket) - Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket. WsMessage - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the http4k HTTP message model, WsMessages are immutable data classes. The routing aspect of Websockets is done using a very similar API to the standard HTTP routing for HTTP messages and dynamic parts of the upgrade request are available when constructing a websocket instance: data class Wrapper ( val value : String ) val body = WsMessage . string (). map ( :: Wrapper , Wrapper :: value ). toLens () val nameLens = Path . of ( name ) val ws : WsHandler = websockets ( /hello bind websockets ( /{name} bind { ws : WebSocket - val name = nameLens ( ws . upgradeRequest ) ws . send ( WsMessage ( hello $name )) ws . onMessage { val received = body ( it ) ws . send ( body ( received )) } ws . onClose { println ( closed ) } } ) ) A WsHandler can be combined with an HttpHandler into a PolyHandler and then mounted into a supported backend server using asServer() : val app = PolyHandler ( routes ( / bind { r : Request - Response ( OK ) } ), websockets ( /ws bind { ws : WebSocket - ws . send ( WsMessage ( hello! )) } ) ) app . asServer ( Jetty ( 9000 )). start () Alternatively, the WsHandler can be also converted to a synchronous WsClient - this allows testing to be done completely offline, which allows for super-fast tests: val client = app . testWsClient ( Request ( Method . GET , ws://localhost:9000/hello/bob )) !! client . send ( WsMessage ( 1 )) client . close ( Status ( 200 , bob )) client . received . take ( 2 ). forEach ( :: println )","title":"Typesafe Websockets."},{"location":"guide/modules/core/#request-and-response-tostring","text":"The HttpMessages used by http4k toString in the HTTP wire format, which it simple to capture and replay HTTP message streams later in a similar way to tools like Mountebank .","title":"Request and Response toString()"},{"location":"guide/modules/core/#curl-format","text":"Creates curl command for a given request - this is useful to include in audit logs so exact requests can be replayed if required: val curl = Request ( POST , http://httpbin.org/post ). body ( listOf ( foo to bar ). toBody ()). toCurl () // curl -X POST --data foo=bar http://httpbin.org/post","title":"CURL format"},{"location":"guide/modules/hamkrest/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-testing-hamkrest\", version: \"3.113.0\" About A set of Hamkrest matchers for use when testing http4k apps. Code","title":"Hamkrest"},{"location":"guide/modules/hamkrest/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-testing-hamkrest\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/hamkrest/#about","text":"A set of Hamkrest matchers for use when testing http4k apps.","title":"About"},{"location":"guide/modules/hamkrest/#code","text":"","title":"Code "},{"location":"guide/modules/json/","text":"Installation (Gradle) Argo: compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"3.113.0\" Gson: compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"3.113.0\" Jackson: compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.113.0\" Moshi: compile group: \"org.http4k\", name: \"http4k-format-moshi\", version: \"3.113.0\" About These modules add the ability to use JSON as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of standard methods and extension methods for converting common types into native JSON/XML objects, including custom Lens methods for each library so that JSON node objects can be written and read directly from HTTP messages: Code Auto-marshalling capabilities Some of the message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection. We can use this facility in http4k to automatically marshall objects to/from HTTP message bodies using Lenses : Code There is a utility to generate Kotlin data class code for JSON documents here . These data classes are compatible with using the Body.auto T () functionality. FAQ (aka gotchas) regarding Auto-marshalling capabilities Uppercase JSON key names The Jackson version of the automarshalling does NOT work for objects with uppercase key names - this is a known issue with the Jackson library and we are unable to fix it. Either use the GSON alternative, or annotate your Data class fields with JsonAlias annotations to work around this. JSON arrays When handling raw JSON array messages, such as: [123, 456, 567] , there is a slight gotcha when auto-marshalling messages from JSON. This is demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list. As shown, a workaround to this is to use Body.auto Array MyIntWrapper ().toLens() instead, and then compare using Arrays.equal()","title":"JSON handling"},{"location":"guide/modules/json/#installation-gradle","text":"Argo: compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"3.113.0\" Gson: compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"3.113.0\" Jackson: compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.113.0\" Moshi: compile group: \"org.http4k\", name: \"http4k-format-moshi\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/json/#about","text":"These modules add the ability to use JSON as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of standard methods and extension methods for converting common types into native JSON/XML objects, including custom Lens methods for each library so that JSON node objects can be written and read directly from HTTP messages:","title":"About"},{"location":"guide/modules/json/#code","text":"","title":"Code "},{"location":"guide/modules/json/#auto-marshalling-capabilities","text":"Some of the message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection. We can use this facility in http4k to automatically marshall objects to/from HTTP message bodies using Lenses :","title":"Auto-marshalling capabilities"},{"location":"guide/modules/json/#code_1","text":"There is a utility to generate Kotlin data class code for JSON documents here . These data classes are compatible with using the Body.auto T () functionality.","title":"Code "},{"location":"guide/modules/json/#faq-aka-gotchas-regarding-auto-marshalling-capabilities","text":"","title":"FAQ (aka gotchas) regarding Auto-marshalling capabilities"},{"location":"guide/modules/json/#uppercase-json-key-names","text":"The Jackson version of the automarshalling does NOT work for objects with uppercase key names - this is a known issue with the Jackson library and we are unable to fix it. Either use the GSON alternative, or annotate your Data class fields with JsonAlias annotations to work around this.","title":"Uppercase JSON key names"},{"location":"guide/modules/json/#json-arrays","text":"When handling raw JSON array messages, such as: [123, 456, 567] , there is a slight gotcha when auto-marshalling messages from JSON. This is demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list. As shown, a workaround to this is to use Body.auto Array MyIntWrapper ().toLens() instead, and then compare using Arrays.equal()","title":"JSON arrays"},{"location":"guide/modules/jsonrpc/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-jsonrpc\", version: \"3.113.0\" About Support for JSON-RPC handlers, with support for both manual and automatic marshalling modes. Each service method \"name\" is bound to a particular endpoint function and then the entire API is exposed as a standard http4k HttpHandler , so it can be composed with other HttpHandlers and Filters. A specialised ErrorHandler can also be assigned to the RPC contract. Note that in order to activate JSON RPC, you need to import one of the supported JSON modules. Code","title":"JSON RPC"},{"location":"guide/modules/jsonrpc/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-jsonrpc\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/jsonrpc/#about","text":"Support for JSON-RPC handlers, with support for both manual and automatic marshalling modes. Each service method \"name\" is bound to a particular endpoint function and then the entire API is exposed as a standard http4k HttpHandler , so it can be composed with other HttpHandlers and Filters. A specialised ErrorHandler can also be assigned to the RPC contract. Note that in order to activate JSON RPC, you need to import one of the supported JSON modules.","title":"About"},{"location":"guide/modules/jsonrpc/#code","text":"","title":"Code "},{"location":"guide/modules/metrics/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-metrics-micrometer\", version: \"3.113.0\" About This module provides configurable Filters to provide metrics for http4k apps, plugging into the awesome Micrometer library. Micrometer Both Server and Client filters are available for recording request counts and latency, optionally overriding values for the metric names, descriptions and request identification.","title":"Metrics"},{"location":"guide/modules/metrics/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-metrics-micrometer\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/metrics/#about","text":"This module provides configurable Filters to provide metrics for http4k apps, plugging into the awesome Micrometer library.","title":"About"},{"location":"guide/modules/metrics/#micrometer","text":"Both Server and Client filters are available for recording request counts and latency, optionally overriding values for the metric names, descriptions and request identification.","title":"Micrometer "},{"location":"guide/modules/multipart/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-multipart\", version: \"3.113.0\" About Multipart form support for fields and files, including a set of lens extensions for fields/files. See the cookbook for example use.","title":"Multipart forms"},{"location":"guide/modules/multipart/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-multipart\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/multipart/#about","text":"Multipart form support for fields and files, including a set of lens extensions for fields/files. See the cookbook for example use.","title":"About"},{"location":"guide/modules/oauth/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.113.0\" About Support for using integrating with external OAuth2 providers for authentication purposes and to provide access to external APIs of entities such as Auth0, Google etc. Specifically, http4k supports the popular OAuth2 Authorization Code Grant . This flow provides a callback mechanism that plays out like this: App developer (you!) creates an application on the OAuth provider and receives a Client Id and a Client Secret . You also provide a \"callback\" URL to the provider which will be used later. When accessing a protected resource, your app checks for an Access Token from the user (via cookie or similar) If the user has no token, the app redirects the user browser back to the OAuth provider site, along with the \"state\" of the user - containing a generated CrossSiteRequestForgeryToken (CSRF - which is also stored by the app) and the original URI the user was trying to access. The user logs in on the OAuth provider site, which generates a code that is returned as a query parameter in a redirect back to the registered callback URL in your app, along with the CSRF token. Your app checks the content of the CSRF token to determine that the redirect is genuine, then sends the received code back to the OAuth provider in exchange for a valid AccessToken . This completes the flow The AccessToken can then be used to access various services from the OAuth provider APIs. There is a single user-defined interface, OAuthPersistence , required to implement to enable this flow. This interface is required to provide the custom way in which your application will store and retrieve the CSRF and AccessToken for a request. A common way to do this is through Cookies, but the values should definitely be encrypted. http4k only provides an insecure version of this class that you can use for testing. In order to remain provider-agnostic, the AccessToken object also contains the entirety of the (typically JSON) token response from the provider, which may include other fields depending on the types of scope for which your application is authorised by the user. To enable OAuth integration, construct a configured instance of OAuthProvider . This provides 3 things: 1. A filter to protect application resources 1. A callback HttpHandler for the OAuth provider to redirect the authticated user to 1. A fully configured API client (which populated the Host on the URI) - this allows different implementations of the provider to be used across environments. Example provider Out of the box, http4k provides implementations for several OAuth providers. See the cookbook for a custom implementation.","title":"OAuth"},{"location":"guide/modules/oauth/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/oauth/#about","text":"Support for using integrating with external OAuth2 providers for authentication purposes and to provide access to external APIs of entities such as Auth0, Google etc. Specifically, http4k supports the popular OAuth2 Authorization Code Grant . This flow provides a callback mechanism that plays out like this: App developer (you!) creates an application on the OAuth provider and receives a Client Id and a Client Secret . You also provide a \"callback\" URL to the provider which will be used later. When accessing a protected resource, your app checks for an Access Token from the user (via cookie or similar) If the user has no token, the app redirects the user browser back to the OAuth provider site, along with the \"state\" of the user - containing a generated CrossSiteRequestForgeryToken (CSRF - which is also stored by the app) and the original URI the user was trying to access. The user logs in on the OAuth provider site, which generates a code that is returned as a query parameter in a redirect back to the registered callback URL in your app, along with the CSRF token. Your app checks the content of the CSRF token to determine that the redirect is genuine, then sends the received code back to the OAuth provider in exchange for a valid AccessToken . This completes the flow The AccessToken can then be used to access various services from the OAuth provider APIs. There is a single user-defined interface, OAuthPersistence , required to implement to enable this flow. This interface is required to provide the custom way in which your application will store and retrieve the CSRF and AccessToken for a request. A common way to do this is through Cookies, but the values should definitely be encrypted. http4k only provides an insecure version of this class that you can use for testing. In order to remain provider-agnostic, the AccessToken object also contains the entirety of the (typically JSON) token response from the provider, which may include other fields depending on the types of scope for which your application is authorised by the user. To enable OAuth integration, construct a configured instance of OAuthProvider . This provides 3 things: 1. A filter to protect application resources 1. A callback HttpHandler for the OAuth provider to redirect the authticated user to 1. A fully configured API client (which populated the Host on the URI) - this allows different implementations of the provider to be used across environments.","title":"About"},{"location":"guide/modules/oauth/#example-provider","text":"Out of the box, http4k provides implementations for several OAuth providers. See the cookbook for a custom implementation.","title":"Example provider "},{"location":"guide/modules/resilience/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-resilience4j\", version: \"3.113.0\" About This module provides configurable Filters to provide CircuitBreaking, RateLimiting, Retrying and Bulkheading, by integrating with the awesome Resilience4J library. Circuit Breaking A Circuit Filter detects failures and then Opens for a set period to allow the underlying system to recover. Rate Limiting A RateLimit Filter monitors the number of requests over a set window. Retrying A Retrying Filter retries requests if a failure is generated. Bulkheading A Bulkhead Filter limits the amount of parallel calls that can be executed.","title":"Resilience"},{"location":"guide/modules/resilience/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-resilience4j\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/resilience/#about","text":"This module provides configurable Filters to provide CircuitBreaking, RateLimiting, Retrying and Bulkheading, by integrating with the awesome Resilience4J library.","title":"About"},{"location":"guide/modules/resilience/#circuit-breaking","text":"A Circuit Filter detects failures and then Opens for a set period to allow the underlying system to recover.","title":"Circuit Breaking "},{"location":"guide/modules/resilience/#rate-limiting","text":"A RateLimit Filter monitors the number of requests over a set window.","title":"Rate Limiting "},{"location":"guide/modules/resilience/#retrying","text":"A Retrying Filter retries requests if a failure is generated.","title":"Retrying "},{"location":"guide/modules/resilience/#bulkheading","text":"A Bulkhead Filter limits the amount of parallel calls that can be executed.","title":"Bulkheading "},{"location":"guide/modules/serverless/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-serverless-lambda\", version: \"3.113.0\" About These modules provide integration with Serverless deployment environments, such as AWS Lambda. AWS Lambda integration Since http4k is server independent, it turns out to be fairly trivial to deploy full applications to AWS Lambda , and then call them by setting up the API Gateway to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. This has the added bonus that you can test your applications in a local environment and then simply deploy them to AWS Lambda via S3 upload. In order to achieve this, only a single interface AppLoader needs to be implemented. This is far from a complete guide, but configuring AWS Lambda and the API Gateway involves several stages: Users, Roles and Policies for the API Gateway and Lambda. API Gateway to proxy all requests to your Lambda. Building your http4k application into a standard UberJar. Optionally using Proguard to minify the JAR. Package up the (minified) JAR into a standard Zip distribution. Create and configure the Lambda function, and at the same time: Upload the standard Zip file to S3. Set the function execution to call the main http4k entry point: org.http4k.serverless.lambda.LambdaFunction::handle Set an environment variable for the Lambda HTTP4K_BOOTSTRAP_CLASS to the class of your AppLoader class. We hope to soon provide some tools to automate at least some of the above process, or at least document it somewhat. However, AWS is a complicated beast and many people have a preferred way to set it up: CloudFormation templates, Serverless framework, Terraform, etc. In the meantime, here is an example of how the AppLoader is created and a sneak peak at launching the app locally: Code","title":"Serverless backend"},{"location":"guide/modules/serverless/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-serverless-lambda\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/serverless/#about","text":"These modules provide integration with Serverless deployment environments, such as AWS Lambda.","title":"About"},{"location":"guide/modules/serverless/#aws-lambda-integration","text":"Since http4k is server independent, it turns out to be fairly trivial to deploy full applications to AWS Lambda , and then call them by setting up the API Gateway to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. This has the added bonus that you can test your applications in a local environment and then simply deploy them to AWS Lambda via S3 upload. In order to achieve this, only a single interface AppLoader needs to be implemented. This is far from a complete guide, but configuring AWS Lambda and the API Gateway involves several stages: Users, Roles and Policies for the API Gateway and Lambda. API Gateway to proxy all requests to your Lambda. Building your http4k application into a standard UberJar. Optionally using Proguard to minify the JAR. Package up the (minified) JAR into a standard Zip distribution. Create and configure the Lambda function, and at the same time: Upload the standard Zip file to S3. Set the function execution to call the main http4k entry point: org.http4k.serverless.lambda.LambdaFunction::handle Set an environment variable for the Lambda HTTP4K_BOOTSTRAP_CLASS to the class of your AppLoader class. We hope to soon provide some tools to automate at least some of the above process, or at least document it somewhat. However, AWS is a complicated beast and many people have a preferred way to set it up: CloudFormation templates, Serverless framework, Terraform, etc. In the meantime, here is an example of how the AppLoader is created and a sneak peak at launching the app locally:","title":"AWS Lambda integration"},{"location":"guide/modules/serverless/#code","text":"","title":"Code "},{"location":"guide/modules/servers/","text":"Installation (Gradle) Apache: compile group: \"org.http4k\", name: \"http4k-server-apache\", version: \"3.113.0\" Jetty: compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.113.0\" Ktor CIO: compile group: \"org.http4k\", name: \"http4k-server-ktorcio\", version: \"3.113.0\" Netty: compile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"3.113.0\" Undertow: compile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"3.113.0\" SunHttp (for development only): compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.113.0\" About Server-backend modules provide a consistent API to mount HttpHandlers into the specified container in 1 LOC, by simply passing it to the relevant ServerConfig implementation (in this case Jetty ): Code Customisation Each of the server backends implement an interface ServerConfig , which is written with sensible defaults for the server in questions, but is also designed to be used as a starting point for tweaking to API user needs. To customize, simply use the relevant ServerConfig class as a starting point and reimplement as required.","title":"Server backend"},{"location":"guide/modules/servers/#installation-gradle","text":"Apache: compile group: \"org.http4k\", name: \"http4k-server-apache\", version: \"3.113.0\" Jetty: compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.113.0\" Ktor CIO: compile group: \"org.http4k\", name: \"http4k-server-ktorcio\", version: \"3.113.0\" Netty: compile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"3.113.0\" Undertow: compile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"3.113.0\" SunHttp (for development only): compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/servers/#about","text":"Server-backend modules provide a consistent API to mount HttpHandlers into the specified container in 1 LOC, by simply passing it to the relevant ServerConfig implementation (in this case Jetty ):","title":"About"},{"location":"guide/modules/servers/#code","text":"","title":"Code "},{"location":"guide/modules/servers/#customisation","text":"Each of the server backends implement an interface ServerConfig , which is written with sensible defaults for the server in questions, but is also designed to be used as a starting point for tweaking to API user needs. To customize, simply use the relevant ServerConfig class as a starting point and reimplement as required.","title":"Customisation"},{"location":"guide/modules/templating/","text":"Installation (Gradle) Dust: compile group: \"org.http4k\", name: \"http4k-template-dust\", version: \"3.113.0\" Handlebars: compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"3.113.0\" Pebble: compile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"3.113.0\" Thymeleaf: compile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"3.113.0\" About The http4k templating API provides a standard mechanism for rendering using common templating libraries. Simply implement the ViewModel interface on a model class and pass it to the renderer to get a string. All of the implementations support view rendering using the following strategies: Cached on the classpath Cached from the filesystem Hot-Reloading from the filesystem The examples below are for Handlebars, but the others have the same APIs: Code","title":"Templating"},{"location":"guide/modules/templating/#installation-gradle","text":"Dust: compile group: \"org.http4k\", name: \"http4k-template-dust\", version: \"3.113.0\" Handlebars: compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"3.113.0\" Pebble: compile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"3.113.0\" Thymeleaf: compile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/templating/#about","text":"The http4k templating API provides a standard mechanism for rendering using common templating libraries. Simply implement the ViewModel interface on a model class and pass it to the renderer to get a string. All of the implementations support view rendering using the following strategies: Cached on the classpath Cached from the filesystem Hot-Reloading from the filesystem The examples below are for Handlebars, but the others have the same APIs:","title":"About"},{"location":"guide/modules/templating/#code","text":"","title":"Code  "},{"location":"guide/modules/webdriver/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-testing-webdriver\", version: \"3.113.0\" About A basic Selenium WebDriver API implementation for http4k HttpHandlers, which runs completely out of container (no network) for ultra fast tests. Feature Supported Notes Navigation yes simple back/forward/refresh history CSS selectors yes Link navigation yes Form field entry and submission yes Cookie storage yes manual expiry management JavaScript no Alerts no Screenshots no Frames no Multiple windows no Use the API like any other WebDriver implementation, by simply passing your app HttpHandler to construct it: Code","title":"WebDriver"},{"location":"guide/modules/webdriver/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-testing-webdriver\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/webdriver/#about","text":"A basic Selenium WebDriver API implementation for http4k HttpHandlers, which runs completely out of container (no network) for ultra fast tests. Feature Supported Notes Navigation yes simple back/forward/refresh history CSS selectors yes Link navigation yes Form field entry and submission yes Cookie storage yes manual expiry management JavaScript no Alerts no Screenshots no Frames no Multiple windows no Use the API like any other WebDriver implementation, by simply passing your app HttpHandler to construct it:","title":"About"},{"location":"guide/modules/webdriver/#code","text":"","title":"Code "},{"location":"guide/modules/xml/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-format-xml\", version: \"3.113.0\" About This module adds the ability to use XML as a first-class citizen when reading from and to HTTP messages. It also adds an automarshalling facility to read XML node objects directly into a custom type which matches the schema: Code There is a utility to generate data class code from XML input here . These data classes are compatible with using the Body.auto T () functionality.","title":"XML handling"},{"location":"guide/modules/xml/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-format-xml\", version: \"3.113.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/xml/#about","text":"This module adds the ability to use XML as a first-class citizen when reading from and to HTTP messages. It also adds an automarshalling facility to read XML node objects directly into a custom type which matches the schema:","title":"About"},{"location":"guide/modules/xml/#code","text":"There is a utility to generate data class code from XML input here . These data classes are compatible with using the Body.auto T () functionality.","title":"Code "},{"location":"guide/testing/","text":"The creators of http4k takes testing very seriously - so seriously that there really isn't that much to say here! The API has been designed to make it as simple as possible to test both individual endpoints and entire applications in a consistent fashion, which is aided by remembering that: The input and output Request/Response objects are immutable. HttpHandlers are just functions. An entire http4k application is just an HttpHandler . Because of the above, there really isn't much required in the way of \"testing infrastructure\" - no magic containers or test fixtures that you might find in other frameworks. Testing is just matter of calling the correct function! Additionally, because the server and client HttpHandler interfaces are symmetrical - moving between in and out of container contexts (or indeed even to another HTTP framework entirely) is just a matter of switching out the HttpHandler implementation from the constructed app (out of container) to an HTTP client (in-container). That said, possibly the most useful thing is to demonstrate the process that we have developed to test micro-services. A simple example of the development process can be found here . Testing modules We have developed the following modules to help with testing: http4k-testing-hamkrest : a set of composable Hamkrest matchers for matching http4k message objects against. http4k-testing-webdriver : an ultra-lightweight Selenium WebDriver implementation which can be used to test-drive http4k apps (ie. HttpHandlers). Example code for testing Testing HttpHandlers with static paths Testing HttpHandlers with dynamic paths Testing Filters Testing Websockets with offline and online clients","title":"Application Testing"},{"location":"guide/testing/#testing-modules","text":"We have developed the following modules to help with testing: http4k-testing-hamkrest : a set of composable Hamkrest matchers for matching http4k message objects against. http4k-testing-webdriver : an ultra-lightweight Selenium WebDriver implementation which can be used to test-drive http4k apps (ie. HttpHandlers).","title":"Testing modules"},{"location":"guide/testing/#example-code-for-testing","text":"","title":"Example code for testing"},{"location":"guide/testing/#testing-httphandlers-with-static-paths","text":"","title":"Testing HttpHandlers with static paths "},{"location":"guide/testing/#testing-httphandlers-with-dynamic-paths","text":"","title":"Testing HttpHandlers with dynamic paths "},{"location":"guide/testing/#testing-filters","text":"","title":"Testing Filters "},{"location":"guide/testing/#testing-websockets-with-offline-and-online-clients","text":"","title":"Testing Websockets with offline and online clients "},{"location":"in_action/","text":"Rationale design KotlinConf presentations: Server as a Function. In Kotlin. _ _ ____ Slides Video See http4k in action in these example projects and repos: Each project is tagged with the http4k features it demonstrates: \"Hello World\" CD pipeline TDD'd example application Templates Testing JSON / Lenses CD pipeline OpenApi Static resources Dropbox clone in 70 lines of Kotlin Templates Testing Http Client Multipart AWS CD pipeline Serverless GraalVM Simple websocket driven chat-server in 30 lines of Kotlin Testing Websockets CD Pipeline Static resources Stage-by-stage example of London-style TDD development process Testing Todo backend (standard routing) Testing JSON / Lenses CD pipeline Todo backend (contract routing) Testing JSON / Lenses OpenApi CD pipeline Real World example (Medium clone) Testing Contracts","title":"In action"},{"location":"in_action/#rationale-design","text":"","title":"Rationale &amp; design"},{"location":"in_action/#kotlinconf-presentations-server-as-a-function-in-kotlin-______","text":"Slides Video","title":"KotlinConf presentations: Server as a Function. In Kotlin. ______"},{"location":"in_action/#see-http4k-in-action-in-these-example-projects-and-repos","text":"Each project is tagged with the http4k features it demonstrates:","title":"See http4k in action in these example projects and repos:"},{"location":"in_action/#hello-world","text":"CD pipeline","title":"\"Hello World\""},{"location":"in_action/#tddd-example-application","text":"Templates Testing JSON / Lenses CD pipeline OpenApi Static resources","title":"TDD'd example application"},{"location":"in_action/#dropbox-clone-in-70-lines-of-kotlin","text":"Templates Testing Http Client Multipart AWS CD pipeline Serverless GraalVM","title":"Dropbox clone in 70 lines of Kotlin"},{"location":"in_action/#simple-websocket-driven-chat-server-in-30-lines-of-kotlin","text":"Testing Websockets CD Pipeline Static resources","title":"Simple websocket driven chat-server in 30 lines of Kotlin"},{"location":"in_action/#stage-by-stage-example-of-london-style-tdd-development-process","text":"Testing","title":"Stage-by-stage example of London-style TDD development process"},{"location":"in_action/#todo-backend-standard-routing","text":"Testing JSON / Lenses CD pipeline","title":"Todo backend (standard routing)"},{"location":"in_action/#todo-backend-contract-routing","text":"Testing JSON / Lenses OpenApi CD pipeline","title":"Todo backend (contract routing)"},{"location":"in_action/#real-world-example-medium-clone","text":"Testing Contracts","title":"Real World example (Medium clone)"},{"location":"installation/","text":"All http4k libraries are available on Maven Central and JCenter and are released under a single version. For the core module, add the following to your Gradle file: compile group: org.http4k , name: http4k-core , version: 3.113.0","title":"Installation"},{"location":"performance/","text":"The http4k server-backend modules provide a very thin adapter layer over the raw APIs of the underlying servers, so generally performs at a very low overhead compared to the raw server. Tech Empower Benchmarks We have entered http4k into the prominent Tech Empower Framework Benchmarks project, which assesses frameworks over a series of realistic tests. For this benchmark, no customisation or performance tuning of the underlying servers was done - the default application HttpHandler was used which is then plugged into each custom backend, as below: fun main () { Http4kBenchmarkServer . start ( Undertow ( 9000 )) } Command-line JVM options, however, were tuned for the test to take advantage of various JVM features. The full implementation of the benchmark can be found here . Results - Round 17 Overall, http4k did very well in this round of benchmarking, especially considering that the ethos of the library is one of excellent Developer experience over and above high-end performance (which tends to result in less friendly APIs). The big surprise was the high performance of the Apache server backend, which consistently outranked Undertow (which is the the most fully featured of all the supported backends and our default option). The SunHttp backend, which we entered for a baseline comparison, unfortunately didn't produce any results in this round. DB query + HTML rendering: results : Top rank: 6/73 - Apache backend Database driver used is PostgreSql backed by a Hikari pool. Handlebars templating engine is used for rendering. Multiple DB queries: results : Top rank: 3/66 - Jetty backend Database driver used is PostgreSql backed by a Hikari pool. Single DB query: results : Top rank: 8/68 - Apache backend Database driver used is PostgreSql backed by a Hikari pool. Random DB updates: results : Top rank: 14/59 - Jetty backend Database driver used is PostgreSql backed by a Hikari pool. JSON Serialization: results : Top rank: 20/69 - Apache backend The standard Jackson module is used for JSON creation and marshalling. Plaintext pipelining: results : Top rank: 23/66 - Apache backend","title":"Performance"},{"location":"performance/#tech-empower-benchmarks","text":"We have entered http4k into the prominent Tech Empower Framework Benchmarks project, which assesses frameworks over a series of realistic tests. For this benchmark, no customisation or performance tuning of the underlying servers was done - the default application HttpHandler was used which is then plugged into each custom backend, as below: fun main () { Http4kBenchmarkServer . start ( Undertow ( 9000 )) } Command-line JVM options, however, were tuned for the test to take advantage of various JVM features. The full implementation of the benchmark can be found here .","title":"Tech Empower Benchmarks"},{"location":"performance/#results-round-17","text":"Overall, http4k did very well in this round of benchmarking, especially considering that the ethos of the library is one of excellent Developer experience over and above high-end performance (which tends to result in less friendly APIs). The big surprise was the high performance of the Apache server backend, which consistently outranked Undertow (which is the the most fully featured of all the supported backends and our default option). The SunHttp backend, which we entered for a baseline comparison, unfortunately didn't produce any results in this round.","title":"Results - Round 17"},{"location":"performance/#db-query-html-rendering-results","text":"Top rank: 6/73 - Apache backend Database driver used is PostgreSql backed by a Hikari pool. Handlebars templating engine is used for rendering.","title":"DB query + HTML rendering: results:"},{"location":"performance/#multiple-db-queries-results","text":"Top rank: 3/66 - Jetty backend Database driver used is PostgreSql backed by a Hikari pool.","title":"Multiple DB queries: results:"},{"location":"performance/#single-db-query-results","text":"Top rank: 8/68 - Apache backend Database driver used is PostgreSql backed by a Hikari pool.","title":"Single DB query: results:"},{"location":"performance/#random-db-updates-results","text":"Top rank: 14/59 - Jetty backend Database driver used is PostgreSql backed by a Hikari pool.","title":"Random DB updates: results:"},{"location":"performance/#json-serialization-results","text":"Top rank: 20/69 - Apache backend The standard Jackson module is used for JSON creation and marshalling.","title":"JSON Serialization: results:"},{"location":"performance/#plaintext-pipelining-results","text":"Top rank: 23/66 - Apache backend","title":"Plaintext pipelining: results:"},{"location":"quickstart/","text":"Quickstart This simple example demonstates how to serve and consume HTTP services using http4k . To install, add these dependencies to your Gradle file: dependencies { compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-server-jetty , version: 3.113.0 compile group: org.http4k , name: http4k-client-apache , version: 3.113.0 } The following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it. Single-line CD Bootstrap Run the single command in the readme of this repo to create a HelloWorld http4k app with a full CD pipeline using Github - TravisCI - Heroku. Why should I use this library? Presentation about the development of http4k given at the Kotlin London meetup.","title":"Getting started"},{"location":"quickstart/#quickstart","text":"This simple example demonstates how to serve and consume HTTP services using http4k . To install, add these dependencies to your Gradle file: dependencies { compile group: org.http4k , name: http4k-core , version: 3.113.0 compile group: org.http4k , name: http4k-server-jetty , version: 3.113.0 compile group: org.http4k , name: http4k-client-apache , version: 3.113.0 } The following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it.","title":"Quickstart"},{"location":"quickstart/#single-line-cd-bootstrap","text":"Run the single command in the readme of this repo to create a HelloWorld http4k app with a full CD pipeline using Github - TravisCI - Heroku.","title":"Single-line CD Bootstrap"},{"location":"quickstart/#why-should-i-use-this-library","text":"Presentation about the development of http4k given at the Kotlin London meetup.","title":"Why should I use this library?"},{"location":"rationale/","text":"tldr; Presentation about the development of http4k given at the Kotlin London meetup. About http4k is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - the routing module is inspired by UtterlyIdle , the \"Server as a function\" and filter model is stolen from Finagle , and the contract module OpenApi/Swagger generator is ported from Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch. For our purposes, we needed something that: Starts/stops ultra quickly. Easily testable outside of an HTTP container, and testing should require little to no custom infrastructure. Provides typesafe HTTP message deconstruction/construction (in this case via Lenses). Automatically deals with contract breaches (missing/invalid params etc) to remove boilerplate. Absolutely no magic involved: No reflection. No annotations. Minimal dependencies (apart from the Kotlin StdLib, http4k-core has zero). Automatic generation of OpenApi/Swagger documentation (including JSON Schema models). Has a symmetric server/client API ( HttpHandler should just be Request - Response ). Has immutable Request/Response objects. http4k ticks all of these boxes. It allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers using a single line of code. The symmetric HTTP API also allows Filter chains (often called \"Middleware\" or \"Interceptors\" in other frameworks) to be constructed into reusable units/stacks for both server and client sides (eg. logging/metrics/caching...) since they can be composed together for later use. As a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests). Scenarios such as \"what happens if this HTTP dependency continually takes 5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary. Concepts All incoming and outgoing HTTP services are modelled as HttpHandler , which is modelled as (Request) - Response : val handler : HttpHandler = { request : Request - Response ( OK ) } Pre/post processing is done using a Filter , which is modelled as (HttpHandler) - HttpHandler . Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating HttpHandler - to yield a decorated HttpHandler : val filter : Filter = Filter { next : HttpHandler - { request : Request - next ( request ). header ( my response header , value ) } } val decorated : HttpHandler = filter . then ( handler ) Binding an HttpHandler to a path and HTTP verb yields a RoutingHttpHandler , which is both an HttpHandler and a Router : val route : RoutingHttpHandler = /path bind GET to { Response ( OK ). body ( you GET bob ) } RoutingHttpHandler s can be grouped together: val app : RoutingHttpHandler = routes ( bob bind GET to { Response ( OK ). body ( you GET bob ) }, rita bind POST to { Response ( OK ). body ( you POST rita ) }, sue bind DELETE to { Response ( OK ). body ( you DELETE sue ) } ) A Router is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next Router in the list. Routers can be combined together (under particular context roots) to form another RoutingHttpHandler : val bigApp : HttpHandler = routes ( /this bind app , /other bind app ) HttpHandlers can be bound to a container (to create an Http4kServer ) with 1 LOC. The decouples the server implementation from the business logic: val jettyServer = app . asServer ( Jetty ( 9000 )). start () An Http client is also a HttpHandler : val client : HttpHandler = ApacheClient () Because the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other: val app1 : HttpHandler = MyApp1 () val app2 : HttpHandler = MyApp2 ( app1 )","title":"Rationale & Concepts"},{"location":"rationale/#tldr","text":"Presentation about the development of http4k given at the Kotlin London meetup.","title":"tldr;"},{"location":"rationale/#about","text":"http4k is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - the routing module is inspired by UtterlyIdle , the \"Server as a function\" and filter model is stolen from Finagle , and the contract module OpenApi/Swagger generator is ported from Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch. For our purposes, we needed something that: Starts/stops ultra quickly. Easily testable outside of an HTTP container, and testing should require little to no custom infrastructure. Provides typesafe HTTP message deconstruction/construction (in this case via Lenses). Automatically deals with contract breaches (missing/invalid params etc) to remove boilerplate. Absolutely no magic involved: No reflection. No annotations. Minimal dependencies (apart from the Kotlin StdLib, http4k-core has zero). Automatic generation of OpenApi/Swagger documentation (including JSON Schema models). Has a symmetric server/client API ( HttpHandler should just be Request - Response ). Has immutable Request/Response objects. http4k ticks all of these boxes. It allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers using a single line of code. The symmetric HTTP API also allows Filter chains (often called \"Middleware\" or \"Interceptors\" in other frameworks) to be constructed into reusable units/stacks for both server and client sides (eg. logging/metrics/caching...) since they can be composed together for later use. As a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests). Scenarios such as \"what happens if this HTTP dependency continually takes 5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary.","title":"About"},{"location":"rationale/#concepts","text":"All incoming and outgoing HTTP services are modelled as HttpHandler , which is modelled as (Request) - Response : val handler : HttpHandler = { request : Request - Response ( OK ) } Pre/post processing is done using a Filter , which is modelled as (HttpHandler) - HttpHandler . Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating HttpHandler - to yield a decorated HttpHandler : val filter : Filter = Filter { next : HttpHandler - { request : Request - next ( request ). header ( my response header , value ) } } val decorated : HttpHandler = filter . then ( handler ) Binding an HttpHandler to a path and HTTP verb yields a RoutingHttpHandler , which is both an HttpHandler and a Router : val route : RoutingHttpHandler = /path bind GET to { Response ( OK ). body ( you GET bob ) } RoutingHttpHandler s can be grouped together: val app : RoutingHttpHandler = routes ( bob bind GET to { Response ( OK ). body ( you GET bob ) }, rita bind POST to { Response ( OK ). body ( you POST rita ) }, sue bind DELETE to { Response ( OK ). body ( you DELETE sue ) } ) A Router is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next Router in the list. Routers can be combined together (under particular context roots) to form another RoutingHttpHandler : val bigApp : HttpHandler = routes ( /this bind app , /other bind app ) HttpHandlers can be bound to a container (to create an Http4kServer ) with 1 LOC. The decouples the server implementation from the business logic: val jettyServer = app . asServer ( Jetty ( 9000 )). start () An Http client is also a HttpHandler : val client : HttpHandler = ApacheClient () Because the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other: val app1 : HttpHandler = MyApp1 () val app2 : HttpHandler = MyApp2 ( app1 )","title":"Concepts"},{"location":"support/","text":"In the first instance, try and see if there is a relevant example in the cookbook - more and more are being added all the time! For issues, please describe giving as much detail as you can - including version and steps to recreate. Slack room: #http4k @ slack.kotlinlang.org -- PREFERRED Gitter channel: http4k/http4k @ gitter.im Twitter: @http4k Note: As a general rule, you'll get a quicker response from the Slack channel. Logo usage The http4k logo design and branding are copyright 2018 to http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant branding guidelines .","title":"Help & Support"},{"location":"support/#logo-usage","text":"The http4k logo design and branding are copyright 2018 to http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant branding guidelines .","title":"Logo usage"}]}