{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"http4k is a lightweight but fully-featured HTTP toolkit written in pure Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way. http4k applications are just Kotlin functions which can be mounted into a running backend. For example, here's a simple echo server: val app : HttpHandler = { request : Request -> Response ( OK ). body ( request . body ) } val server = app . asServer ( SunHttp ( 8000 )). start () http4k consists of a core library, http4k-core , providing a base HTTP implementation + a number of capability abstractions (such as servers, clients, templating, websockets etc). These capabilities are then implemented in add-on modules. The principles of http4k are: Application as a Function: Based on the Twitter paper \"Your Server as a Function\" , all HTTP services can be composed of 2 types of simple function: HttpHandler: (Request) -> Response - provides a remote call for processing a Request. Filter: (HttpHandler) -> HttpHandler - adds Request/Response pre/post processing. These filters are composed to make stacks of reusable behaviour that can then be applied to an HttpHandler . Immutability: All entities in the library are immutable unless their function explicitly disallows this. Symmetric: The HttpHandler interface is identical for both HTTP services and clients. This allows for simple offline testability of applications, as well as plugging together of services without HTTP container being required. Dependency-lite: Apart the from Kotlin StdLib, http4k-core module has ZERO dependencies and weighs in at ~700kb. Add-on modules only have dependencies required for specific implementation. Testability Built by TDD enthusiasts, so supports super-easy mechanisms for both In and Out of Container testing of: individual endpoints applications websockets full suites of microservices Module feature overview Core: Base HTTP handler and immutable HTTP message objects, cookie handling. Commonly used HTTP functionalities provided as reusable Filters (caching, debugging, Zipkin request tracing ) Path-based routing , including nestable contexts Typesafe HTTP message construction/desconstruction and Request Contexts using Lenses Static file-serving capability with Caching and Hot-Reload Single Page Application support with Caching and Hot-Reload Servlet implementation to allow plugin to any Servlet container Launch applications in 1LOC with an embedded SunHttp server backend (recommended for development use only) Path-based websockets including typesafe message marshalling using Lenses, which are testable without a running container APIs to record and replay HTTP traffic to disk or memory Core abstraction APIs implemented by the other modules Client: 1LOC client adapters Apache sync + async HTTP Jetty HTTP (supports sync and async HTTP) OkHttp HTTP (supports sync and async HTTP) Java (bundled with http4k-core ) 1LOC WebSocket client, with blocking and non-blocking modes Server: 1LOC server backend spinup for: Jetty (including websocket support) Undertow Apache (from httpcore) Netty Ktor CIO SunHttp (bundled with http4k-core ) API design allows for plugging into configurable instances of each Serverless: Implement a single Factory method, then upload your http4k applications to AWS Lambda to be called from API Gateway. Contracts: Define Typesafe HTTP contracts, with required and optional path/query/header/bodies Typesafe path matching Auto-validation of incoming requests == zero boilerplate validation code Self-documenting for all routes - eg. Built in support for live OpenApi v2 and v3 description endpoints including JSON Schema model breakdown. Templating: Pluggable templating system support for: Dust Freemarker Handlebars Pebble Thymeleaf Jade4j Caching and Hot-Reload template support Message formats: Consistent API provides first class support for marshalling formats to/from HTTP messages for: JSON - with support for: Jackson - includes support for fully automatic marshalling of Data classes Gson - includes support for fully automatic marshalling of Data classes Moshi - includes support for fully automatic marshalling of Data classes KotlinX Serialization - official Kotlin JSON API. Argo - lightweight Java JSON API with zero dependencies. XML - includes support for: Jackson - includes support for fully automatic marshalling of Data classes Xml - includes support for one way automatic marshalling of Data classes Resilience: Support for Circuits, Retrying, Rate-Limiting, Bulkheading via Resilience4J integration. Metrics: Support for plugging http4k apps into micrometer Multipart: Support for Multipart HTML forms, including Lens extensions for type-safe marshalling of fields. AWS: Client filter to allow super-simple interaction with AWS services (via request signing) OAuth Security Implement OAuth Authorisation Code Grant flow with a single Interface Pre-configured OAuth for following providers: Auth0 Dropbox Google Soundcloud Cloud Native: Tooling to support operating http4k applications in orchestrated cloud environments such as Kubernetes and CloudFoundry. 12-factor configuration, dual-port servers and health checks such as liveness and readiness checking. WebDriver: Ultra-lightweight Selenium WebDriver implementation for http4k application. Hamkrest: A set of Hamkrest matchers for testing http4k Request and Response messages. Approval Testing: JUnit 5 extensions for Approval testing of http4k Request and Response messages. Chaos: API for declaring and injecting failure modes into http4k applications, allowing modelling and hence answering of \"what if\" style questions to help understand how code fares under failure conditions such as latency and dying processes. Service Virtualisation: Record and replay versioned HTTP contracts to/from Servirtium Markdown format. Includes Servirtium MiTM server and simple JUnit extensions. Example This quick example is designed to convey the simplicity & features of http4k . See also the quickstart for the simplest possible starting point and demonstrates how to serve and consume HTTP services with dynamic routing. To install, add these dependencies to your Gradle file: dependencies { compile group: \"org.http4k\" , name: \"http4k-core\" , version: \"3.247.0\" compile group: \"org.http4k\" , name: \"http4k-server-jetty\" , version: \"3.247.0\" compile group: \"org.http4k\" , name: \"http4k-client-okhttp\" , version: \"3.247.0\" } package cookbook import org.http4k.client.OkHttp import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.CachingFilters import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { // we can bind HttpHandlers (which are just functions from Request -> Response) to paths/methods to create a Route, // then combine many Routes together to make another HttpHandler val app : HttpHandler = routes ( \"/ping\" bind GET to { _ : Request -> Response ( OK ). body ( \"pong!\" ) }, \"/greet/{name}\" bind GET to { req : Request -> val name : String ? = req . path ( \"name\" ) Response ( OK ). body ( \"hello ${name ?: \" anon ! \"}\" ) } ) // call the handler in-memory without spinning up a server val inMemoryResponse : Response = app ( Request ( GET , \"/greet/Bob\" )) println ( inMemoryResponse ) // Produces: // HTTP/1.1 200 OK // // // hello Bob // this is a Filter - it performs pre/post processing on a request or response val timingFilter = Filter { next : HttpHandler -> { request : Request -> val start = System . currentTimeMillis () val response = next ( request ) val latency = System . currentTimeMillis () - start println ( \"Request to ${request.uri} took ${latency}ms\" ) response } } // we can \"stack\" filters to create reusable units, and then apply them to an HttpHandler val compositeFilter = CachingFilters . Response . NoCache (). then ( timingFilter ) val filteredApp : HttpHandler = compositeFilter . then ( app ) // only 1 LOC to mount an app and start it in a container filteredApp . asServer ( Jetty ( 9000 )). start () // HTTP clients are also HttpHandlers! val client : HttpHandler = OkHttp () val networkResponse : Response = client ( Request ( GET , \"http://localhost:9000/greet/Bob\" )) println ( networkResponse ) // Produces: // Request to /api/greet/Bob took 1ms // HTTP/1.1 200 // cache-control: private, must-revalidate // content-length: 9 // date: Thu, 08 Jun 2017 13:01:13 GMT // expires: 0 // server: Jetty(9.3.16.v20170120) // // hello Bob } Acknowledgments Dan Bodart 's utterlyidle Ivan Moore for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\" Contributors This project exists thanks to all the people who contribute . Backers & Sponsors If you use http4k in your project or enterprise and would like to support ongoing development, please consider becoming a backer or a sponsor. Sponsor logos will show up here with a link to your website.","title":"Introduction"},{"location":"#module-feature-overview","text":"Core: Base HTTP handler and immutable HTTP message objects, cookie handling. Commonly used HTTP functionalities provided as reusable Filters (caching, debugging, Zipkin request tracing ) Path-based routing , including nestable contexts Typesafe HTTP message construction/desconstruction and Request Contexts using Lenses Static file-serving capability with Caching and Hot-Reload Single Page Application support with Caching and Hot-Reload Servlet implementation to allow plugin to any Servlet container Launch applications in 1LOC with an embedded SunHttp server backend (recommended for development use only) Path-based websockets including typesafe message marshalling using Lenses, which are testable without a running container APIs to record and replay HTTP traffic to disk or memory Core abstraction APIs implemented by the other modules Client: 1LOC client adapters Apache sync + async HTTP Jetty HTTP (supports sync and async HTTP) OkHttp HTTP (supports sync and async HTTP) Java (bundled with http4k-core ) 1LOC WebSocket client, with blocking and non-blocking modes Server: 1LOC server backend spinup for: Jetty (including websocket support) Undertow Apache (from httpcore) Netty Ktor CIO SunHttp (bundled with http4k-core ) API design allows for plugging into configurable instances of each Serverless: Implement a single Factory method, then upload your http4k applications to AWS Lambda to be called from API Gateway. Contracts: Define Typesafe HTTP contracts, with required and optional path/query/header/bodies Typesafe path matching Auto-validation of incoming requests == zero boilerplate validation code Self-documenting for all routes - eg. Built in support for live OpenApi v2 and v3 description endpoints including JSON Schema model breakdown. Templating: Pluggable templating system support for: Dust Freemarker Handlebars Pebble Thymeleaf Jade4j Caching and Hot-Reload template support Message formats: Consistent API provides first class support for marshalling formats to/from HTTP messages for: JSON - with support for: Jackson - includes support for fully automatic marshalling of Data classes Gson - includes support for fully automatic marshalling of Data classes Moshi - includes support for fully automatic marshalling of Data classes KotlinX Serialization - official Kotlin JSON API. Argo - lightweight Java JSON API with zero dependencies. XML - includes support for: Jackson - includes support for fully automatic marshalling of Data classes Xml - includes support for one way automatic marshalling of Data classes Resilience: Support for Circuits, Retrying, Rate-Limiting, Bulkheading via Resilience4J integration. Metrics: Support for plugging http4k apps into micrometer Multipart: Support for Multipart HTML forms, including Lens extensions for type-safe marshalling of fields. AWS: Client filter to allow super-simple interaction with AWS services (via request signing) OAuth Security Implement OAuth Authorisation Code Grant flow with a single Interface Pre-configured OAuth for following providers: Auth0 Dropbox Google Soundcloud Cloud Native: Tooling to support operating http4k applications in orchestrated cloud environments such as Kubernetes and CloudFoundry. 12-factor configuration, dual-port servers and health checks such as liveness and readiness checking. WebDriver: Ultra-lightweight Selenium WebDriver implementation for http4k application. Hamkrest: A set of Hamkrest matchers for testing http4k Request and Response messages. Approval Testing: JUnit 5 extensions for Approval testing of http4k Request and Response messages. Chaos: API for declaring and injecting failure modes into http4k applications, allowing modelling and hence answering of \"what if\" style questions to help understand how code fares under failure conditions such as latency and dying processes. Service Virtualisation: Record and replay versioned HTTP contracts to/from Servirtium Markdown format. Includes Servirtium MiTM server and simple JUnit extensions.","title":"Module feature overview"},{"location":"#example","text":"This quick example is designed to convey the simplicity & features of http4k . See also the quickstart for the simplest possible starting point and demonstrates how to serve and consume HTTP services with dynamic routing. To install, add these dependencies to your Gradle file: dependencies { compile group: \"org.http4k\" , name: \"http4k-core\" , version: \"3.247.0\" compile group: \"org.http4k\" , name: \"http4k-server-jetty\" , version: \"3.247.0\" compile group: \"org.http4k\" , name: \"http4k-client-okhttp\" , version: \"3.247.0\" } package cookbook import org.http4k.client.OkHttp import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.CachingFilters import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { // we can bind HttpHandlers (which are just functions from Request -> Response) to paths/methods to create a Route, // then combine many Routes together to make another HttpHandler val app : HttpHandler = routes ( \"/ping\" bind GET to { _ : Request -> Response ( OK ). body ( \"pong!\" ) }, \"/greet/{name}\" bind GET to { req : Request -> val name : String ? = req . path ( \"name\" ) Response ( OK ). body ( \"hello ${name ?: \" anon ! \"}\" ) } ) // call the handler in-memory without spinning up a server val inMemoryResponse : Response = app ( Request ( GET , \"/greet/Bob\" )) println ( inMemoryResponse ) // Produces: // HTTP/1.1 200 OK // // // hello Bob // this is a Filter - it performs pre/post processing on a request or response val timingFilter = Filter { next : HttpHandler -> { request : Request -> val start = System . currentTimeMillis () val response = next ( request ) val latency = System . currentTimeMillis () - start println ( \"Request to ${request.uri} took ${latency}ms\" ) response } } // we can \"stack\" filters to create reusable units, and then apply them to an HttpHandler val compositeFilter = CachingFilters . Response . NoCache (). then ( timingFilter ) val filteredApp : HttpHandler = compositeFilter . then ( app ) // only 1 LOC to mount an app and start it in a container filteredApp . asServer ( Jetty ( 9000 )). start () // HTTP clients are also HttpHandlers! val client : HttpHandler = OkHttp () val networkResponse : Response = client ( Request ( GET , \"http://localhost:9000/greet/Bob\" )) println ( networkResponse ) // Produces: // Request to /api/greet/Bob took 1ms // HTTP/1.1 200 // cache-control: private, must-revalidate // content-length: 9 // date: Thu, 08 Jun 2017 13:01:13 GMT // expires: 0 // server: Jetty(9.3.16.v20170120) // // hello Bob }","title":"Example "},{"location":"#acknowledgments","text":"Dan Bodart 's utterlyidle Ivan Moore for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\"","title":"Acknowledgments"},{"location":"#contributors","text":"This project exists thanks to all the people who contribute .","title":"Contributors"},{"location":"#backers-sponsors","text":"If you use http4k in your project or enterprise and would like to support ongoing development, please consider becoming a backer or a sponsor. Sponsor logos will show up here with a link to your website.","title":"Backers &amp; Sponsors"},{"location":"api/","text":"","title":"API docs"},{"location":"blog/meet_http4k/","text":"Server as a Function. In Kotlin. Typesafe. Without the Server. @daviddenton Meet http4k http4k is an HTTP toolkit written in Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way. Whenever (yet another) new JVM HTTP framework is released, the inevitable question that rightly get asked is \"How it this different to X?\" . In this post, I'm going to briefly cover what http4k is, how we think it's different, and address some of those bold claims from the title of this post. Here's a quick rundown of what we think those differences are: http4k is small. Written in pure, functional Kotlin, with zero dependencies. http4k is simple. Like, really simple. No static API magic, no annotations, no reflection. http4k is immutable. It relies on an immutable HTTP model, which makes it a snap to test and debug. http4k is symmetric. It supports remote calls as a first-class concern, and the remote HTTP model is identical to the incoming HTTP model. http4k is typesafe. Say goodbye to all your validation and marshalling boilerplate and hello to automatic request validation and data class-based contracts for HTTP bodies using the Lens API. http4k is serverless. Or rather - server independent. Test an app out of container and then deploy it into any supported local container with 1 LOC - or as a function into AWS Lambda. Oh god, not another framework! Why does this even exist?!? Firstly - we don't consider http4k to be a framework - it's a set of libraries providing a functional toolkit to serve and consume HTTP services, focusing on simple, consistent, and testable APIs. Hence, whilst it does provide support for various APIs relevant to serving and consuming HTTP , it does not provide every integration under the sun - merely simple points to allow those integrations to be hooked in. Another thing to say is that (not very much) of http4k is new - it's rather the distillation of 15 years worth of experience of using various server-side libraries and hence most of the good ideas are stolen. For instance - the routing module is inspired by UtterlyIdle , the basic \"Server as a function\" model is stolen from Finagle , and the contract module OpenApi/Swagger generator is ported from Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the functional features of the language and it felt like a good time to start something from scratch, whilst avoiding the magic that plagues other frameworks. Hence, http4k is primarily designed to be a Kotlin-first library. Claim A: Small, simple, immutable. Based on the awesome \"Your Server as a Function\" paper from Twitter, http4k apps are modelled by composing 2 types of simple, independent function. Function 1: HttpHandler An HttpHandler represents an HTTP endpoint. It's not even an Interface, modelled merely as a Typealias : typealias HttpHandler = ( Request ) -> Response Below is a entire http4k application that echoes the request body back in the response. It only relies on the http4k-core module, which itself has zero dependencies: val app = { request : Request -> Response ( OK ). body ( request . body ) } val server = app . asServer ( SunHttp ( 8000 )). start () The Request and Response objects in there are immutable data classes/POKOs, so testing the app requires absolutely no extra infrastructure - just call the function, it's as easy as: class AppTest { @Test fun `echoes request body` () { assertThat ( app ( Request ( POST , \"/\" ). body ( \"hello\" )), equalTo ( Response ( OK ). body ( \"hello\" ))) } } To plug it into a different Server-backend, just depend on the relevant module (Jetty, Undertow, Netty, Apache (httpcore), Ktor CIO, Ktor Netty, and SunHttp are available) and change the call to asServer() . Function 2: Filter Filters provides pre and post Request processing and are simply: interface Filter : ( HttpHandler ) -> HttpHandler For API conciseness and discoverability reasons this is modelled as an Interface and not a Typealias - it also has a couple of Kotlin extension methods to allow you to compose Filters with HttpHandlers and other Filters : val setContentType = Filter { next -> { request -> next ( request ). header ( \"Content-Type\" , \"text/plain\" ) } } val repeatBody = Filter { next -> { request -> next ( request . body ( request . bodyString () + request . bodyString () } } val composedFilter : Filter = repeatBody . then ( setContentType ) val decoratedApp : HttpHandler = composedFilter . then ( app ) Filters are also trivial to test independently, because they are generally just stateless functions. Routing http4k 's nestable routing looks a lot like every other Sinatra-style framework these days, and allows for infinitely nesting HttpHandlers - this just exposes another HttpHandler so you can easily extract, test and reuse sets of routes as easily as you could with one: val app : HttpHandler = routes ( \"/app\" bind GET to decoratedApp , \"/other\" bind routes ( \"/delete\" bind DELETE to { _ : Request -> Response ( OK ) }, \"/post/{name}\" bind POST to { request : Request -> Response ( OK ). body ( \"you POSTed to ${request.path(\" name \")}\" ) } ) ) And that it - those functions are everything you need to know to write a simple http4k application. The http4k-core module rocks in at about 700kb, and has zero dependencies (other than the Kotlin language itself). Additionally, everything in the core is functional and predictable - there is no static API magic going on under the covers (making it difficult to have multiple apps in the same JVM), no annotations, no compiler-plugins, and no reflection. Claim B. Symmetric HTTP Out of the multitude of JVM http frameworks out there, not many actually consider how you app talks to other services, yet in this Microservice\u2122 world that's an absolutely massive part of what many apps do! As per a core principle behind \"Server as a Function\", http4k provides a symmetric API for HTTP clients - ie. it's exactly the same API as is exposed in http4k server applications - the HttpHandler . Here's that entire API again, just in case you've forgotten: typealias HttpHandler = ( Request ) -> Response What does that mean in practice? Well - for one thing, it's less for your brain to learn because you already know the API: val client : HttpHandler = ApacheClient () val response : Response = client ( Request ( GET , \"http://server/path\" )) For another, it means that since clients are just function s you can easily stub them for testing, and since applications and clients are interchangeable, they can be plugged together in memory without putting them on the network - which makes testing insanely fast: fun MyApp1 (): HttpHandler = { Response ( OK ) } fun MyApp2 ( app1 : HttpHandler ): HttpHandler = { app1 ( it ) } val app1 : HttpHandler = MyApp1 () val app2 : HttpHandler = MyApp2 ( app1 ) http4k provides a HTTP client adapters for both Apache and OkHttp , all with streaming support. Claim C. Typesafe HTTP with Lenses The immutable http4k model for HTTP objects contains all the usual suspect methods for getting values from the messages. For instance, if we are expecting a search parameter with a query containing a page number: val request = Request ( GET , \"http://server/search?page=123\" ) val page : Int = request . query ( \"page\" ) !! . toInt ...but we also want to ensure that the expected values are both present and valid, since the above example will fail if either of those things is not true. For this purpose, we can use a Lens to enforce the expected HTTP contract. The use of Lenses in http4k applications can remove the need for writing any parsing or validation code for all incoming data (including Forms), as validations are taken care of by the library. Lens basics A Lens is a bi-directional entity which can be used to either get or set a particular value from/onto an HTTP message. http4k provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional) and the type. For the above example, we could use the Query Lens builder and then invoke() the Lens on the message to extract the target value: val pageLens = Query . int (). required ( \"page\" ) val page : Int = pageLens ( Request ( GET , \"http://server/search?page=123\" )) If the query parameter is missing or not an Int, the lens extraction operation will fail. There are similar Lens builder functions for all parts of the HTTP message ( Header , Path , Body , FormField etc..), and functions for all common JVM primitive types. They are all completely typesafe - there is no reflection or magic going on - just marshalling of the various entities (in this case String to Int conversion). In the case of failure, we need to apply a Filter to detect the errors and convert them to a BAD_REQUEST response: val queryName = Query . string (). required ( \"name\" ) val app : HttpHandler = routes ( \"/post\" bind POST to { request : Request -> Response ( OK ). body ( queryName ( request )) } ) val app = ServerFilters . CatchLensFailure . then ( handler )( Request ( GET , \"/hello/2000-01-01?myCustomType=someValue\" )) Lenses can also be applied with a correctly typed value (via invoke() ) to set it onto a target object - and as HTTP messages in http4k are immutable, this results in a copy of the modified message: val pageSizeLens = Header . int (). required ( \"page\" ) val page : Response = pageLens ( Response ( OK ), 123 ) // or apply multiple lenses using with() val updated : Request = Request ( GET , \"/foo\" ). with ( pageLens of 123 , pageSizeLens of 10 ) Securely extracting JDK primitives from HTTP messages is great, but we really want to avoid primitives entirely and go straight to domain types. During construction of Lens, the builders allow mapping to occur so we can leverage Kotlin data classes. This works for both get and set operations: data class MyDate ( val value : LocalDate ) val dateQuery = Query . localDate (). map ( :: MyDate , MyDate :: value ). required ( \"date\" ) val myDate : MyDate = dateQuery ( Request ( GET , \"http://server/search?date=2000-01-01\" )) Lensing HTTP bodies with Data classes Some of the supported message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection (oops - looks like we broke our reflection promise - but technically we're not doing it ;) !). This behaviour is supported in http4k Lenses through the use of the auto() method, which will marshall objects to/from HTTP messages: data class Email ( val value : String ) data class Message ( val subject : String , val from : Email , val to : Email ) val messageLens = Body . auto < Message >(). toLens () val body = \"\"\"{\"subject\":\"hello\",\"from\":{\"value\":\"bob@git.com\"},\"to\":{\"value\":\"sue@git.com\"}}\"\"\" val message : Message = messageLens ( Request ( GET , \"/\" ). body ( body )) This mechanism works for all incoming and outgoing JSON and XML Requests and Responses. To assist with developing whilst using this type of auto-marshalling, we have created a tool to automatically generate a set of data classes for a given messages. Claim D. Serverless Ah yes - Serverless - the latest in the Cool Kids Club and killer fodder for the resume. Well, since http4k is server independent, it turns out to be fairly trivial to deploy full applications to AWS Lambda , and then call them by setting up the API Gateway to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. In order to achieve this, only a single interface AppLoader needs to be implemented - this is responsible for creating the HttpHandler which is adapted to the API of the ApiGatewayProxyRequest/ApiGatewayProxyResponse used by AWS. As this is AWS, there is a fair amount of configuration required to make this possible, but the only http4k specific config is to: Set the function execution to call org.http4k.serverless.lambda.LambdaFunction::handle Set an environment variable for the Lambda HTTP4K_BOOTSTRAP_CLASS to the class of your AppLoader class. Here's a simple example: object TweetEcho : AppLoader { override fun invoke ( env : Map < String , String >): HttpHandler = { Response ( OK ). body ( it . bodyString (). take ( 140 )) } } Since http4k is very dependency-light, full binary uploads of these AWS Lambdas tend to be very small - and by utilising Proguard we've seen the size of a Lambda UberJar go as small as 150kb. Introduced in v3.0.0, this support is available in the http4k-serverless-lambda module. The final word(s)! As pointed out above, http4k-core module has zero dependencies. It is also small, even though it also provides: Support for static file-serving with HotReload. A bunch of useful Filters for stuff like Zipkin Request Tracing. Support for Request Contexts. Facilities to record and replay HTTP traffic. There are also a bunch of other modules available, all presented with the same concentration on Testability, API simplicity and consistency: ViewModel driven templating engine support (Handlerbars etc) with HotReload. Popular JSON/XML (Gson, Jackson, Moshi, etc) library support for HTTP bodies. Typesafe HTML Form and Multipart Forms processing, with support for Streaming uploads to a storage service. Forms can also be configured to collect errors instead of just rejecting outright. Typesafe contract module, providing live [OpenApi v2 & v3] documentation. AWS request signing. Resilience4j integration, including Circuit Breakers & Rate Limiting. Testing support via Hamkrest matchers and an in-memory WebDriver implementation. Finally, http4k is proven in production , it has been adopted in at least 2 global investment banks and is serving the vast majority of traffic for a major publishing website (in the top 1000 sites globally according to alexa.com - ie. easily serving 10s of million hits per day on a few nodes) since March 2017. You can see a few example applications here , including a bootstrap project for creating a Github -> Travis -> Heroku CD pipeline in a single command. Well, that's it for this whirlwind tour - we hope you found it worth reading this far! We'd love you to try out http4k and feedback why you love/hate/are indifferent to it :) . And if you want to get involved or chat to the authors, we hang out in the friendly #http4k channel @ slack.kotlinlang,org . Footnotes \"But... but... but... asynchronous! And Webscale!\" , I heard them froth . Yes, you are correct - \"Server as a Function\" is based on asynchronous functions and http4k exposes a synchronous API. However, our experience suggests that for the vast majority of apps, this actually makes API integration harder unless you've got async all the way down - and that is assuming that async clients are actually available for all your various remote dependencies. We found that this plainly didn't matter for our use-cases so went for Simple API\u2122 instead... it's possible however that Kotlin co-routines will allow us to revisit this decision. (UPDATE) Websockets? Yep - simple, testable, and now available in v3.2.1! See the introductory blog post for details!","title":"Meet http4k"},{"location":"blog/meet_http4k/#server-as-a-function-in-kotlin-typesafe-without-the-server","text":"","title":"Server as a Function. In Kotlin. Typesafe. Without the Server."},{"location":"blog/meet_http4k/#daviddenton","text":"","title":"@daviddenton"},{"location":"blog/meet_http4k/#meet-http4k","text":"http4k is an HTTP toolkit written in Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way. Whenever (yet another) new JVM HTTP framework is released, the inevitable question that rightly get asked is \"How it this different to X?\" . In this post, I'm going to briefly cover what http4k is, how we think it's different, and address some of those bold claims from the title of this post. Here's a quick rundown of what we think those differences are: http4k is small. Written in pure, functional Kotlin, with zero dependencies. http4k is simple. Like, really simple. No static API magic, no annotations, no reflection. http4k is immutable. It relies on an immutable HTTP model, which makes it a snap to test and debug. http4k is symmetric. It supports remote calls as a first-class concern, and the remote HTTP model is identical to the incoming HTTP model. http4k is typesafe. Say goodbye to all your validation and marshalling boilerplate and hello to automatic request validation and data class-based contracts for HTTP bodies using the Lens API. http4k is serverless. Or rather - server independent. Test an app out of container and then deploy it into any supported local container with 1 LOC - or as a function into AWS Lambda.","title":"Meet http4k"},{"location":"blog/meet_http4k/#oh-god-not-another-framework-why-does-this-even-exist","text":"Firstly - we don't consider http4k to be a framework - it's a set of libraries providing a functional toolkit to serve and consume HTTP services, focusing on simple, consistent, and testable APIs. Hence, whilst it does provide support for various APIs relevant to serving and consuming HTTP , it does not provide every integration under the sun - merely simple points to allow those integrations to be hooked in. Another thing to say is that (not very much) of http4k is new - it's rather the distillation of 15 years worth of experience of using various server-side libraries and hence most of the good ideas are stolen. For instance - the routing module is inspired by UtterlyIdle , the basic \"Server as a function\" model is stolen from Finagle , and the contract module OpenApi/Swagger generator is ported from Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the functional features of the language and it felt like a good time to start something from scratch, whilst avoiding the magic that plagues other frameworks. Hence, http4k is primarily designed to be a Kotlin-first library.","title":"Oh god, not another framework! Why does this even exist?!?"},{"location":"blog/meet_http4k/#claim-a-small-simple-immutable","text":"Based on the awesome \"Your Server as a Function\" paper from Twitter, http4k apps are modelled by composing 2 types of simple, independent function.","title":"Claim A: Small, simple, immutable."},{"location":"blog/meet_http4k/#function-1-httphandler","text":"An HttpHandler represents an HTTP endpoint. It's not even an Interface, modelled merely as a Typealias : typealias HttpHandler = ( Request ) -> Response Below is a entire http4k application that echoes the request body back in the response. It only relies on the http4k-core module, which itself has zero dependencies: val app = { request : Request -> Response ( OK ). body ( request . body ) } val server = app . asServer ( SunHttp ( 8000 )). start () The Request and Response objects in there are immutable data classes/POKOs, so testing the app requires absolutely no extra infrastructure - just call the function, it's as easy as: class AppTest { @Test fun `echoes request body` () { assertThat ( app ( Request ( POST , \"/\" ). body ( \"hello\" )), equalTo ( Response ( OK ). body ( \"hello\" ))) } } To plug it into a different Server-backend, just depend on the relevant module (Jetty, Undertow, Netty, Apache (httpcore), Ktor CIO, Ktor Netty, and SunHttp are available) and change the call to asServer() .","title":"Function 1: HttpHandler"},{"location":"blog/meet_http4k/#function-2-filter","text":"Filters provides pre and post Request processing and are simply: interface Filter : ( HttpHandler ) -> HttpHandler For API conciseness and discoverability reasons this is modelled as an Interface and not a Typealias - it also has a couple of Kotlin extension methods to allow you to compose Filters with HttpHandlers and other Filters : val setContentType = Filter { next -> { request -> next ( request ). header ( \"Content-Type\" , \"text/plain\" ) } } val repeatBody = Filter { next -> { request -> next ( request . body ( request . bodyString () + request . bodyString () } } val composedFilter : Filter = repeatBody . then ( setContentType ) val decoratedApp : HttpHandler = composedFilter . then ( app ) Filters are also trivial to test independently, because they are generally just stateless functions.","title":"Function 2: Filter"},{"location":"blog/meet_http4k/#routing","text":"http4k 's nestable routing looks a lot like every other Sinatra-style framework these days, and allows for infinitely nesting HttpHandlers - this just exposes another HttpHandler so you can easily extract, test and reuse sets of routes as easily as you could with one: val app : HttpHandler = routes ( \"/app\" bind GET to decoratedApp , \"/other\" bind routes ( \"/delete\" bind DELETE to { _ : Request -> Response ( OK ) }, \"/post/{name}\" bind POST to { request : Request -> Response ( OK ). body ( \"you POSTed to ${request.path(\" name \")}\" ) } ) ) And that it - those functions are everything you need to know to write a simple http4k application. The http4k-core module rocks in at about 700kb, and has zero dependencies (other than the Kotlin language itself). Additionally, everything in the core is functional and predictable - there is no static API magic going on under the covers (making it difficult to have multiple apps in the same JVM), no annotations, no compiler-plugins, and no reflection.","title":"Routing"},{"location":"blog/meet_http4k/#claim-b-symmetric-http","text":"Out of the multitude of JVM http frameworks out there, not many actually consider how you app talks to other services, yet in this Microservice\u2122 world that's an absolutely massive part of what many apps do! As per a core principle behind \"Server as a Function\", http4k provides a symmetric API for HTTP clients - ie. it's exactly the same API as is exposed in http4k server applications - the HttpHandler . Here's that entire API again, just in case you've forgotten: typealias HttpHandler = ( Request ) -> Response What does that mean in practice? Well - for one thing, it's less for your brain to learn because you already know the API: val client : HttpHandler = ApacheClient () val response : Response = client ( Request ( GET , \"http://server/path\" )) For another, it means that since clients are just function s you can easily stub them for testing, and since applications and clients are interchangeable, they can be plugged together in memory without putting them on the network - which makes testing insanely fast: fun MyApp1 (): HttpHandler = { Response ( OK ) } fun MyApp2 ( app1 : HttpHandler ): HttpHandler = { app1 ( it ) } val app1 : HttpHandler = MyApp1 () val app2 : HttpHandler = MyApp2 ( app1 ) http4k provides a HTTP client adapters for both Apache and OkHttp , all with streaming support.","title":"Claim B. Symmetric HTTP"},{"location":"blog/meet_http4k/#claim-c-typesafe-http-with-lenses","text":"The immutable http4k model for HTTP objects contains all the usual suspect methods for getting values from the messages. For instance, if we are expecting a search parameter with a query containing a page number: val request = Request ( GET , \"http://server/search?page=123\" ) val page : Int = request . query ( \"page\" ) !! . toInt ...but we also want to ensure that the expected values are both present and valid, since the above example will fail if either of those things is not true. For this purpose, we can use a Lens to enforce the expected HTTP contract. The use of Lenses in http4k applications can remove the need for writing any parsing or validation code for all incoming data (including Forms), as validations are taken care of by the library.","title":"Claim C. Typesafe HTTP with Lenses"},{"location":"blog/meet_http4k/#lens-basics","text":"A Lens is a bi-directional entity which can be used to either get or set a particular value from/onto an HTTP message. http4k provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional) and the type. For the above example, we could use the Query Lens builder and then invoke() the Lens on the message to extract the target value: val pageLens = Query . int (). required ( \"page\" ) val page : Int = pageLens ( Request ( GET , \"http://server/search?page=123\" )) If the query parameter is missing or not an Int, the lens extraction operation will fail. There are similar Lens builder functions for all parts of the HTTP message ( Header , Path , Body , FormField etc..), and functions for all common JVM primitive types. They are all completely typesafe - there is no reflection or magic going on - just marshalling of the various entities (in this case String to Int conversion). In the case of failure, we need to apply a Filter to detect the errors and convert them to a BAD_REQUEST response: val queryName = Query . string (). required ( \"name\" ) val app : HttpHandler = routes ( \"/post\" bind POST to { request : Request -> Response ( OK ). body ( queryName ( request )) } ) val app = ServerFilters . CatchLensFailure . then ( handler )( Request ( GET , \"/hello/2000-01-01?myCustomType=someValue\" )) Lenses can also be applied with a correctly typed value (via invoke() ) to set it onto a target object - and as HTTP messages in http4k are immutable, this results in a copy of the modified message: val pageSizeLens = Header . int (). required ( \"page\" ) val page : Response = pageLens ( Response ( OK ), 123 ) // or apply multiple lenses using with() val updated : Request = Request ( GET , \"/foo\" ). with ( pageLens of 123 , pageSizeLens of 10 ) Securely extracting JDK primitives from HTTP messages is great, but we really want to avoid primitives entirely and go straight to domain types. During construction of Lens, the builders allow mapping to occur so we can leverage Kotlin data classes. This works for both get and set operations: data class MyDate ( val value : LocalDate ) val dateQuery = Query . localDate (). map ( :: MyDate , MyDate :: value ). required ( \"date\" ) val myDate : MyDate = dateQuery ( Request ( GET , \"http://server/search?date=2000-01-01\" ))","title":"Lens basics"},{"location":"blog/meet_http4k/#lensing-http-bodies-with-data-classes","text":"Some of the supported message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection (oops - looks like we broke our reflection promise - but technically we're not doing it ;) !). This behaviour is supported in http4k Lenses through the use of the auto() method, which will marshall objects to/from HTTP messages: data class Email ( val value : String ) data class Message ( val subject : String , val from : Email , val to : Email ) val messageLens = Body . auto < Message >(). toLens () val body = \"\"\"{\"subject\":\"hello\",\"from\":{\"value\":\"bob@git.com\"},\"to\":{\"value\":\"sue@git.com\"}}\"\"\" val message : Message = messageLens ( Request ( GET , \"/\" ). body ( body )) This mechanism works for all incoming and outgoing JSON and XML Requests and Responses. To assist with developing whilst using this type of auto-marshalling, we have created a tool to automatically generate a set of data classes for a given messages.","title":"Lensing HTTP bodies with Data classes"},{"location":"blog/meet_http4k/#claim-d-serverless","text":"Ah yes - Serverless - the latest in the Cool Kids Club and killer fodder for the resume. Well, since http4k is server independent, it turns out to be fairly trivial to deploy full applications to AWS Lambda , and then call them by setting up the API Gateway to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. In order to achieve this, only a single interface AppLoader needs to be implemented - this is responsible for creating the HttpHandler which is adapted to the API of the ApiGatewayProxyRequest/ApiGatewayProxyResponse used by AWS. As this is AWS, there is a fair amount of configuration required to make this possible, but the only http4k specific config is to: Set the function execution to call org.http4k.serverless.lambda.LambdaFunction::handle Set an environment variable for the Lambda HTTP4K_BOOTSTRAP_CLASS to the class of your AppLoader class. Here's a simple example: object TweetEcho : AppLoader { override fun invoke ( env : Map < String , String >): HttpHandler = { Response ( OK ). body ( it . bodyString (). take ( 140 )) } } Since http4k is very dependency-light, full binary uploads of these AWS Lambdas tend to be very small - and by utilising Proguard we've seen the size of a Lambda UberJar go as small as 150kb. Introduced in v3.0.0, this support is available in the http4k-serverless-lambda module.","title":"Claim D. Serverless"},{"location":"blog/meet_http4k/#the-final-words","text":"As pointed out above, http4k-core module has zero dependencies. It is also small, even though it also provides: Support for static file-serving with HotReload. A bunch of useful Filters for stuff like Zipkin Request Tracing. Support for Request Contexts. Facilities to record and replay HTTP traffic. There are also a bunch of other modules available, all presented with the same concentration on Testability, API simplicity and consistency: ViewModel driven templating engine support (Handlerbars etc) with HotReload. Popular JSON/XML (Gson, Jackson, Moshi, etc) library support for HTTP bodies. Typesafe HTML Form and Multipart Forms processing, with support for Streaming uploads to a storage service. Forms can also be configured to collect errors instead of just rejecting outright. Typesafe contract module, providing live [OpenApi v2 & v3] documentation. AWS request signing. Resilience4j integration, including Circuit Breakers & Rate Limiting. Testing support via Hamkrest matchers and an in-memory WebDriver implementation. Finally, http4k is proven in production , it has been adopted in at least 2 global investment banks and is serving the vast majority of traffic for a major publishing website (in the top 1000 sites globally according to alexa.com - ie. easily serving 10s of million hits per day on a few nodes) since March 2017. You can see a few example applications here , including a bootstrap project for creating a Github -> Travis -> Heroku CD pipeline in a single command. Well, that's it for this whirlwind tour - we hope you found it worth reading this far! We'd love you to try out http4k and feedback why you love/hate/are indifferent to it :) . And if you want to get involved or chat to the authors, we hang out in the friendly #http4k channel @ slack.kotlinlang,org .","title":"The final word(s)!"},{"location":"blog/meet_http4k/#footnotes","text":"\"But... but... but... asynchronous! And Webscale!\" , I heard them froth . Yes, you are correct - \"Server as a Function\" is based on asynchronous functions and http4k exposes a synchronous API. However, our experience suggests that for the vast majority of apps, this actually makes API integration harder unless you've got async all the way down - and that is assuming that async clients are actually available for all your various remote dependencies. We found that this plainly didn't matter for our use-cases so went for Simple API\u2122 instead... it's possible however that Kotlin co-routines will allow us to revisit this decision. (UPDATE) Websockets? Yep - simple, testable, and now available in v3.2.1! See the introductory blog post for details!","title":"Footnotes"},{"location":"blog/typesafe_websockets/","text":"Websockets. But typesafe. And testable. Without the Server. @daviddenton Reaction to the last post introducing http4k was pretty good, and one of the most popular questions was: \"But what about Websockets\" ? The answer to that question at the time was an emphatic \"Not yet\" - because they didn't fit the \"Server as a Function\" model, and the team hadn't worked out a way to deliver them in a simple, offline testable* way. Well, a month is a long time, and we've been beavering away, so now we're thrilled to release Websockets for http4k , which are: Simple : using the same style of API as the rest of http4k , allowing the same dynamic path-based routing as is available for standard HttpHandlers . Typesafe : Marshall and unmarshall typed objects from Websocket Messages using the established Lens API. Testable : This is something that is massively important to us - and just like standard HttpHandlers, http4k Websockets are completely testable in a synchronous online or offline environment. No. Server. Required. Details schmeetails... Just as with HttpHandlers, the here are 2 basic function types which make up the core of the Websocket routing API: A WsHandler - represented as a typealias: (Request) -> WsConsumer? . This is responsible for matching an incoming HTTP upgrade request to a websocket. WsConsumer - represented as a typealias: (WebSocket) -> Unit . This function is called on connection and allow the API user to react to events coming from the connected Websocket by attaching listeners. Additionally, WsMessage objects are used for actual communication - ie. a message which is sent or received on a Websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. And just like the http4k HTTP message model, WsMessages are immutable data classes . An example server The example below shows how: Websockets can be dynamically routed Lens-based marshalling of Websocket message objects using Jackson. WsHandler can be combined with an HttpHandler to make a PolyHandler - an application which can serve many protocols. Conversion of the PolyHandler to a supporting Server can be done via the standard asServer() mechanism, or it can be kept offline for ultra-fast in-memory testing: package blog . typesafe_websockets import org.http4k.core.HttpHandler import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.format.Jackson.auto import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.PolyHandler import org.http4k.websocket.Websocket import org.http4k.websocket.WsHandler import org.http4k.websocket.WsMessage // in json , this looks like : { \"value\" : 123 , \"currency: \" EUR \" } data class Money ( val value : Int , val currency : String ) fun main () { // we use the Lens API to convert between the WsMessage and the Money instance , and to // dynamically bind the \"name\" from the path val moneyLens = WsMessage . auto < Money > () . toLens () val nameLens = Path . of ( \"name\" ) // the routing API is virtually identical to the standard http4k http routing API . // on connection , the bound WsConsumer is called with the Websocket instance val ws : WsHandler = websockets ( \"/hello\" bind websockets ( \"/{name}\" bind { ws : Websocket -> val name = nameLens ( ws . upgradeRequest ) ws . onMessage { val received = moneyLens ( it ) ws . send ( moneyLens ( received )) } ws . onClose { println ( \"closed\" ) } ws . send ( WsMessage ( \"hello $name\" )) } ) ) val http : HttpHandler = { _ : Request -> Response ( OK ) . body ( \"hiya world\" ) } // the poly - handler can serve both http and ws protocols . PolyHandler ( http , ws ) . asServer ( Jetty ( 9000 )) . start () . block () } Alternatively, you can check out the Websocket enabled http4k demo: IRC clone in 30 lines of Kotlin . Testability As well as API simplicity, the http4k team are very passionate about testing, and it was very important that this could be done in an out-of-container fashion - ie. in memory and with no server being started. As such, it is possible to call testWsClient() on an WsHandler to provide a synchronous API for testing. Messages and other events can be \"sent\" to a connected websocket and responses will be received back in a completely predictable way from the application under test. In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. http4k provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic: package blog . typesafe_websockets import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.WebsocketClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Uri import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.testing.testWsClient import org.http4k.websocket.Websocket import org.http4k.websocket.WsClient import org.http4k.websocket.WsHandler import org.http4k.websocket.WsMessage import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test val namePath = Path . of ( \"name\" ) // here is our websocket app - it uses dynamic path binding and lenses val testApp : WsHandler = websockets ( \"/{name}\" bind { ws : Websocket -> val name = namePath ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) } ) // this is the abstract contract that defines the behaviour to be tested abstract class WebsocketContract { // subclasses only have to supply a blocking WsClient abstract fun client (): WsClient @Test fun `echoes back connected name` () { assertThat ( client () . received () . take ( 1 ) . toList (), equalTo ( listOf ( WsMessage ( \"hello bob\" )))) } } // a unit test version of the contract - it connects to the websocket in memory with no network class WebsocketUnitTest : WebsocketContract () { override fun client () = cookbook . websockets . testApp . testWsClient ( Request ( GET , \"/bob\" )) !! } // a integration test version of the contract - it starts a server and connects to the websocket over the network class WebsocketServerTest : WebsocketContract () { override fun client () = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/bob\" )) private val server = cookbook . websockets . testApp . asServer ( Jetty ( 8000 )) @BeforeEach fun before () { server . start () } @AfterEach fun after () { server . stop () } } Fin Websocket support is now available for the Jetty server backend in http4k v3.2.0 . We plan to roll out support for other server-backends in due course. Have a play a let us know what you think... Footnotes * We had a bit of a search for \"unit testing websockets\", half through curiosity and half because we wanted to swipe other people's ideas for implementing it. But we came up with nothing - it seems like all the existing JVM HTTP libraries rely on running servers for testing websockets. We hope we're wrong - because the alternative makes us a little <insert sadface emoji/>. If we are, then please let us know! \ud83d\ude1d","title":"Typesafe Websockets"},{"location":"blog/typesafe_websockets/#websockets-but-typesafe-and-testable-without-the-server","text":"","title":"Websockets. But typesafe. And testable. Without the Server."},{"location":"blog/typesafe_websockets/#daviddenton","text":"Reaction to the last post introducing http4k was pretty good, and one of the most popular questions was: \"But what about Websockets\" ? The answer to that question at the time was an emphatic \"Not yet\" - because they didn't fit the \"Server as a Function\" model, and the team hadn't worked out a way to deliver them in a simple, offline testable* way. Well, a month is a long time, and we've been beavering away, so now we're thrilled to release Websockets for http4k , which are: Simple : using the same style of API as the rest of http4k , allowing the same dynamic path-based routing as is available for standard HttpHandlers . Typesafe : Marshall and unmarshall typed objects from Websocket Messages using the established Lens API. Testable : This is something that is massively important to us - and just like standard HttpHandlers, http4k Websockets are completely testable in a synchronous online or offline environment. No. Server. Required.","title":"@daviddenton"},{"location":"blog/typesafe_websockets/#details-schmeetails","text":"Just as with HttpHandlers, the here are 2 basic function types which make up the core of the Websocket routing API: A WsHandler - represented as a typealias: (Request) -> WsConsumer? . This is responsible for matching an incoming HTTP upgrade request to a websocket. WsConsumer - represented as a typealias: (WebSocket) -> Unit . This function is called on connection and allow the API user to react to events coming from the connected Websocket by attaching listeners. Additionally, WsMessage objects are used for actual communication - ie. a message which is sent or received on a Websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. And just like the http4k HTTP message model, WsMessages are immutable data classes .","title":"Details schmeetails..."},{"location":"blog/typesafe_websockets/#an-example-server","text":"The example below shows how: Websockets can be dynamically routed Lens-based marshalling of Websocket message objects using Jackson. WsHandler can be combined with an HttpHandler to make a PolyHandler - an application which can serve many protocols. Conversion of the PolyHandler to a supporting Server can be done via the standard asServer() mechanism, or it can be kept offline for ultra-fast in-memory testing: package blog . typesafe_websockets import org.http4k.core.HttpHandler import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.format.Jackson.auto import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.PolyHandler import org.http4k.websocket.Websocket import org.http4k.websocket.WsHandler import org.http4k.websocket.WsMessage // in json , this looks like : { \"value\" : 123 , \"currency: \" EUR \" } data class Money ( val value : Int , val currency : String ) fun main () { // we use the Lens API to convert between the WsMessage and the Money instance , and to // dynamically bind the \"name\" from the path val moneyLens = WsMessage . auto < Money > () . toLens () val nameLens = Path . of ( \"name\" ) // the routing API is virtually identical to the standard http4k http routing API . // on connection , the bound WsConsumer is called with the Websocket instance val ws : WsHandler = websockets ( \"/hello\" bind websockets ( \"/{name}\" bind { ws : Websocket -> val name = nameLens ( ws . upgradeRequest ) ws . onMessage { val received = moneyLens ( it ) ws . send ( moneyLens ( received )) } ws . onClose { println ( \"closed\" ) } ws . send ( WsMessage ( \"hello $name\" )) } ) ) val http : HttpHandler = { _ : Request -> Response ( OK ) . body ( \"hiya world\" ) } // the poly - handler can serve both http and ws protocols . PolyHandler ( http , ws ) . asServer ( Jetty ( 9000 )) . start () . block () } Alternatively, you can check out the Websocket enabled http4k demo: IRC clone in 30 lines of Kotlin .","title":"An example server "},{"location":"blog/typesafe_websockets/#testability","text":"As well as API simplicity, the http4k team are very passionate about testing, and it was very important that this could be done in an out-of-container fashion - ie. in memory and with no server being started. As such, it is possible to call testWsClient() on an WsHandler to provide a synchronous API for testing. Messages and other events can be \"sent\" to a connected websocket and responses will be received back in a completely predictable way from the application under test. In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. http4k provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic: package blog . typesafe_websockets import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.WebsocketClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Uri import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.testing.testWsClient import org.http4k.websocket.Websocket import org.http4k.websocket.WsClient import org.http4k.websocket.WsHandler import org.http4k.websocket.WsMessage import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test val namePath = Path . of ( \"name\" ) // here is our websocket app - it uses dynamic path binding and lenses val testApp : WsHandler = websockets ( \"/{name}\" bind { ws : Websocket -> val name = namePath ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) } ) // this is the abstract contract that defines the behaviour to be tested abstract class WebsocketContract { // subclasses only have to supply a blocking WsClient abstract fun client (): WsClient @Test fun `echoes back connected name` () { assertThat ( client () . received () . take ( 1 ) . toList (), equalTo ( listOf ( WsMessage ( \"hello bob\" )))) } } // a unit test version of the contract - it connects to the websocket in memory with no network class WebsocketUnitTest : WebsocketContract () { override fun client () = cookbook . websockets . testApp . testWsClient ( Request ( GET , \"/bob\" )) !! } // a integration test version of the contract - it starts a server and connects to the websocket over the network class WebsocketServerTest : WebsocketContract () { override fun client () = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/bob\" )) private val server = cookbook . websockets . testApp . asServer ( Jetty ( 8000 )) @BeforeEach fun before () { server . start () } @AfterEach fun after () { server . stop () } }","title":"Testability "},{"location":"blog/typesafe_websockets/#fin","text":"Websocket support is now available for the Jetty server backend in http4k v3.2.0 . We plan to roll out support for other server-backends in due course. Have a play a let us know what you think...","title":"Fin"},{"location":"blog/typesafe_websockets/#footnotes","text":"* We had a bit of a search for \"unit testing websockets\", half through curiosity and half because we wanted to swipe other people's ideas for implementing it. But we came up with nothing - it seems like all the existing JVM HTTP libraries rely on running servers for testing websockets. We hope we're wrong - because the alternative makes us a little <insert sadface emoji/>. If we are, then please let us know! \ud83d\ude1d","title":"Footnotes"},{"location":"changelog/","text":"Changelog This list is not currently intended to be all-encompassing - it will document major and breaking API changes with their rationale when appropriate: v3.248.0 (uncut) [all] Upgrade some dependency versions. [http4k-cloudnative] - Fix #418 - Fix separator propagation when adding values to an existing MapEnvironment. H/T @jshiell v3.247.0 [http4k-server-ktornetty] New backend module! H/T @albertlatacz for the contribution! [all] Upgrade some dependency versions. [http4k-security-oauth] Fix #414 BasicAuth server filter to not throw an exception on invalid base64 input. H/T @Sebruck for the fix. v3.246.0 [all] Upgrade some dependency versions. [http4k-template-pebble] Fix #411 - Non-root pebble templates when using CachingClasspath from a compiled JAR. H/T @alyphen v3.245.1 [http4k-server-ktorcio] Fix #410 - KtorCIO does not stop properly. v3.245.0 [all] Upgrade some dependency versions. [http4k-core] Factored out Http4kServletAdapter to allow usage of the Servlet API outside of creating a Servlet instance. [all] [Breaking (prevent API abuse)] Restricted generic with() method actual http4k types. Usage outside our API should not use this method. [http4k-contract] Fix #404 - Rework of some FieldRetrieval classes to remove duplication and to support PropertyNamingStrategies set at the global level v3.244.0 [all] Upgrade some dependency versions. [all] [Breaking (if you're not using it right!)] Fix #397 - Fixed up Maven dependencies so that they are not bringing in runtime libraries. [http4k-core] - Add enum StringBiDiMapping #395 - H/T @goodhoko v3.243.0 [all] Upgrade some dependency versions, including Kotlin to 1.3.72 . [http4k-security-oauth] A strategy can now be passed into AuthRequestWithRequestAuthRequestExtractor to determine how to combine AuthRequest and RequestObject H/T @tom v3.242.0 [all] Upgrade some dependency versions. [http4k-testing-servirtium] Improve error diagnostics. H/T @vchekan for the PR. [all] [Unlikely Break] Change Router to return RouterMatch instead of nullable HttpHandler . This allows us to support METHOD_NOT_ALLOWED (405) if we match a path but not a verb instead of just NOT_FOUND (404). This should break custom ro H/T @jshiell for the PR. v3.241.0 [http4k-security-oauth] [Breaking] client_id along with the corresponding TokenRequest is passed into access and refresh token generators so additional validation can take place H/T @tom v3.240.0 [all] Upgrade Kotlin to 1.3.71 . [http4k-testing-servirtium] Switch OkHttp client for Apache. [http4k-server-jetty] Made some classes non-internal so they can be easily reused for custom ServerConfig implementations. v3.239.0 [http4k-client-websocket] [Breaking] Added extra onError handler when creating a non-blocking websocket. [all] Upgrade some dependency versions, including Kotlin to 1.3.70. v3.238.0 [http4k-security-oauth] Early work on supporting refresh tokens. H/T @tom v3.237.0 [http4k-core] Fix #377. Added replaceHeaders() method. Thanks to @bastman for the idea. [http4k-contract] Fix nullability of references in OpenApi3 v3.236.0 [http4k-testing-servirtium] Don't pass recording handler into non-test methods as a resolved parameter. v3.235.0 [http4k-testing-chaos] [Break/Rename] ChaosEngine is now exposed when configuring API. Renamed withChaosEngine() to withChaosApi() , replaced toggle() and update() with enable()/disable() v3.234.0 [http4k-testing-chaos] [Break] Tweaked API make it simpler to use the ChaosEngine via programmatically (as opposed to REST). [http4k-testing-servirtium] [Tiny break] Tweaks to InteractionOptions to make working with Servirtium tests a bit nicer. v3.233.0 [http4k-testing-servirtium] Upgrade ServirtiumServer to use OkHttp instead of JavaHttpClient (due to streaming restrictions on MiTM). [http4k-testing-servirtium] [Break] Rename Github to GitHub . v3.232.0 [http4k-format-kotlinx-serialization] New JSON module! H/T @joscha-alisch for the PR. :) [http4k-testing-servirtium] Work around Kotlin @JvmOverloads problem in ServirtiumServer. [all] Upgrade some dependency versions. v3.231.0 [http4k-testing-servirtium] Making API a bit more Java-compatible friendly. Ability to vary the Server implementation. [http4k-server-jetty] Fix #362 - Websocket disconnect early causes lateinit reference race condition. H/T @fintara for the report/fix. v3.230.0 [http4k-aws] Improved efficiency of building AWS credentials (replace String.format). [http4k-testing-servirtium] Making API a bit more Java-compatible friendly. [all] Upgrade some dependency versions. v3.229.0 [http4k-security-oauth] Allowing for custom authenticate methods when fetching access tokens H/T @tom v3.228.0 [http4k-testing-servirtium] [Breaking] API is still in beta, so moving to a more composed approach which will increase reuse and allow for running Servirtium infra without a dependency on http4k or Junit. Added loading from GitHub. :) [http4k-security-oauth] [Breaking] Audience on request object is now a list to support multiple audiences. H/T @tom [http4k-security-oauth] Nonce is now also passed through on RequestJwts, so it can be added to request jwts. H/T @tom v3.227.0 [http4k-core] Implmement #340. Support SameSite cookies. H/T @danielwellman for the contribution. [http4k-format-jackson] Made JacksonJsonPropertyAnnotated Kotlin 1.4 safe (call to superclass might return null). H/T @pyos for spotting this. v3.226.0 [http4k-testing-servirtium] Moved Servirtium code to new module - was previously [http4k-incubator]. v3.225.0 [http4k-incubator] Rewrote Servirtium code to support manipulations. v3.224.0 [http4k-security-oauth] Fix issue where AuthRequestWithRequestAuthRequestExtractor doesn't take into account scopes not being nullable correctly. H/T @tom v3.223.0 [http4k-security-oauth] Adding expiry to RequestObject . H/T @tom [http4k-security-oauth] Fixing issue where unknown fields cause extracting RequestObject from a jwt, fails due to unknown fields. H/T @tom v3.222.0 [http4k-security-oauth] [Breaking] Error responses in the authorise endpoint now take into account values from the request parameter, this will require a validator for that jwt be implemented. H/T @tom [http4k-security-oauth] [Breaking] State is now its own type, and not just a string, so it can be validated. H/T @tom [http4k-security-oauth] [Breaking] redirectUri on AuthRequest is now nullable as it might come on a request jwt, this is validated to be always be present downstream. H/T @tom [http4k-security-oauth] Allow parsing of request jwt. H/T @tom [http4k-security-oauth] Adding RequestObject to AuthRequest . H/T @tom [http4k-security-oauth] Adding AuthRequestWithRequestAuthRequestExtractor that will extract the request from the jwt, assuming the validator is implemented which can be used instead of just using AuthRequestFromQueryParameters if support for parsing a request jwt is required. H/T @tom v3.221.0 [all] [Unlikely break from Java only] Make all custom http4k exceptions extend RuntimeException. This helps with Java compatibility so things like LensFailure inside Java Lambdas don't require catching (as they are caught/dealt with by other bits of http4k automatically) v3.220.0 [http4k-moshi] [Behaviour break] Fix #353 Don't fail by default on unknown properties. This is the expected default behaviour for all JSON implementations. H/T cnusp for the report. v3.219.0 [http4k-incubator] Next iteration of Servirtium JUnit extensions. Improved API to support multiple storage engines. v3.218.0 [http4k-incubator] Next iteration of Servirtium JUnit extensions. Correct indexing of interactions. [http4k-security-oauth] Authorisation rendering will now taking into account 'response_mode' of either query or fragment in responses and no longer just use the default fo the 'response_type'. H/T @tom [http4k-security-oauth] [Breaking] Error responses in the authorise endpoint will actually redirect back to 'redirect_uri' assuming the validator correctly validates both the 'client_id' and 'redirect_uri' to be valid. H/T @tom v3.217.0 [all] Upgrade some dependency versions. [http4k-incubator] Next iteration of Servirtium JUnit extensions. Only check content which is in the contract when replaying. v3.216.0 [http4k-core] [Breaking] Removed clashing Events then() from deprecated (meaning it cannot be used as there is also another then() in that package). Use the one in org.http4k.events instead. [http4k-security-oauth] Adding nonce to AuthorizationCodeDetails H/T @tom v3.215.0 [http4k-core] GZip client filters now send correct accept-encoding header. @jshiell [http4k-core] New AcceptGZip client filter allows handling of remote GZip without compressing client requests. @jshiell v3.214.0 [http4k-core] Fix #344 H/T Streaming GZip encoder loses data. @jshiell v3.213.0 [http4k-security-oauth] Fixing wrong AuthRequestExtractor passed to AuthRequestTrackingFilter. H/T @tom v3.212.0 [http4k-security-oauth] allowing additional properties to be stored on auth request, if using additional extractors H/T @tom v3.211.0 [http4k-core] Fixes for #338 - Gzip filters send content-encoding of gzip even when body is empty. H/T @jshiell [http4k-security-oauth] [Break] OIDC callback urls using the ResponseType 'code id_token' will now have the parameters returned as a fragment not a query as per 3.3.2.5 of the OpenID Connect Core 1.0 spec H/T @tom [http4k-security-oauth] [Break] Initial support of nonce in OIDC requests H/T @tom v3.210.0 [http4k-core] Support for GZipping response streams. H/T @jshiell [http4k-security-oauth] Adding expires_in to token endpoint response. H/T @tom v3.209.0 [all] Added Status to auto-marshalling JSON mappings. [http4k-security-oauth] Adding token_type to token endpoint response, and strip out nulls in response. H/T @tom v3.208.0 [all] Upgrade some dependency versions. [http4k-core] PR #333. Copy zipkin traces across threads. H/T @jshiell for the PR. [http4k-testing-approval] Close Readers when reading from them. [http4k-incubator] Next iteration of Servirtium JUnit extensions for recording and replaying. v3.207.0 [all] Upgrade some dependency versions [http4k-incubator] Added first cut of Servirtium classes for recording and replaying traffic. Needs validating in the wild [http4k-format-jackson] Fix #320. http4k-format-jackson incompatible with jackson-module-kotlin 2.10.1 v3.206.0 [all] Upgrade some dependency versions. [http4k-contract] Fix #323. Doc generation does not work with multipart lenses. [http4k-format-jackson] Fix #313. Jackson serialization is not working properly with polymorphic types stored in a collection. H/T @alphaho for the PR :) [http4k-core] [Break] Renamed value on ParamMeta to description . v3.205.0 [all] Upgrade some dependency versions, including Kotlin to 1.3.61 [http4k-security-oauth] allowing setting scopes on AccessToken creation so they are set on the response. H/T @tom v3.204.0 [http4k-core, http4k-aws] - increase efficiency of Hex implementation for trace ids and HMAC. H/T @time4tea [http4k-cloudnative] Reimplemented Environment to be more efficient. H/T @time4tea for noticing this. v3.203.0 [http4k-security-oauth] On generating tokens allowing for the client id to be based on the result of validation rather than just the form parameters of the request. To support client assertions. H/T @tom v3.202.0 [http4k-security-oauth] Adding new errors to support issues with client assertions. H/T @tom v3.201.0 [http4k-security-oauth] Allowing a scope to be set on AccessToken. Allowing for more low level validation of Authorise and Token Requests, by implementing org.http4k.security.oauth.server.AuthoriseRequestValidator and org.http4k.security.oauth.server.accesstoken.AccessTokenRequestAuthentication respectively. H/T @tom v3.200.0 [http4k-contract] Support multiple request bodies in OpenApi v3 v3.199.1 [http4k-format-jackson] Fix #313 Part 2 - Revert default behaviour for collections of polymorphic types, but is now overridable by using autoBody() instead of auto() . Reopened #313. v3.199.0 [http4k-format-jackson] [Breaking] Fix #313 - ConfigurableJackson.autoBody implementation would not work with collections of polymorphic types. This fix has the effect of blowing up auto-json behaviour when classes are defined inside functions (causing nasty java.lang.reflect.GenericSignatureFormatError: Signature Parse error exceptions). To remedy, just move inlined classes outside of the functions that they are defined in. H/T @alphaho for the PR. [all] Update some dependency versions v3.198.0 [http4k-core] [Breaking] Reworking of ContentType to support multiple directives. directive field is now directives , so just add the extra 's' to fix :) [http4k-security-oauth] Moar options on OAuthProviderConfig . H/T @tom v3.197.0 [all] Update some dependency versions, including Kotlin to 1.3.60 . [http4k-core] Make Query value optional when setting on a Request . [http4k-core] [Breaking] Fix #316. Optional Query lens handling is more accurate. See issue for details of change in behaviour. v3.196.0 [all] Update some dependency versions. [http4k-format-jackson, http4k-format-gson] Add support for auto marshalling Throwable in a sensible way. [http4k-cloudnative] Renamed badly named UpstreamRequestFailed to RemoteRequestFailed . Improved error handling. v3.195.1 [http4k-cloudnative] Fix adding value to overridden environment when using set() . H/T @jippeholwerda for the PR v3.195.0 [http4k-security-oauth] Tweak to handle Content-Type comparisons (with and without directive). H/T @jippeholwerda for the PR [http4k-multipart] - [Breaking] Added support for setting custom headers in Multipart form fields and files. This has removed the String as the default field type (it is now MultipartFormField . Calls to create lenses using MultipartFormField will now require MultipartFormField.string() instead. v3.194.0 [http4k-contract] Useful tweaks to the contracts API v3.193.1 [http4k-cloudnative] Fix #304 - map get() does not respect fallback values in overridden environment. v3.193.0 [http4k-contract] Marking endpoints as deprecated in OpenApi3 v3.192.0 [http4k-template-jade4j] New module! H/T @RichyHBM for the contribution! :) v3.191.0 [http4k-contract] Better support for overriding of raw map definition id in JSON schema generation v3.190.0 [http4k-core] Added method to (immutably) modify status on Response . H/T @brandon-atkinson for the suggestion [http4k-core] Added composite object support to lens system, allowing creation of simple lenses which draw from several different values (of the same location only - e.g Query/EnvironmentKey) [http4k-contract] Support for overriding the entity definition id in JSON schema generation [all] Update some dependency versions. v3.189.0 [http4k-server-netty] Fix reported port in Netty . H/T @fantayeneh for the PR :) [http4k-security-oauth] Add validateScopes() to ClientValidator . H/T @tom v3.188.0 [http4k-contract] Support multiple-response models in OpenApi2 and 3. Note that this currently is unsupported in the OpenApi UI due to a bug (which doesn't display the schema for the response correctly). However, the JSON schema is generated correctly in these cases. [all] Update some dependency versions. v3.187.0 [all] Update some dependency versions, and changes to various APIs involved (Jackson and Resilience4J) [http4k-core] - Add YearMonth support to standard JSON mappings [http4k-format-jackson, http4k-format-gson] [Possible break] - Moved reified NODE.asA() method from JsonLibAutoMarshallingJson down onto the instances of the Json ( ConfigurableJackson / ConfigurableGson ). This is so that we can handle generified classes such as lists and maps correctly. (As per the problems fixed in 3.181.0) v3.186.0 [http4k-core] - Rollback a couple of places which were using Java9+ APIs (for no good reason). v3.185.0 [http4k-contract] Improvements to rendering enums as their own objects in JSON Schema. v3.184.0 [http4k-contract] Add Cookies options to contract DSL v3.183.0 [http4k-serverless-lambda] Add ability to access Lambda context. H/T @ivoanjo for the PR. [http4k-contract] Fix rendering of OrSecurity when there are more than 2 parts. v3.182.0 [http4k-core] Rename EventsFilter to EventFilter because sanity. [http4k-format-jackson, http4k-format-gson] Reintroduce autoBody() method v3.181.0 [http4k-core] Added base events implementations for StructuredLogging. [http4k-core] [Repackage] Events classes are now in org.http4k.events . [http4k-core] [Breaking] EventCategory is no longer a field of Event . To fix, just remove override from your Event classes. [http4k-format-jackson, http4k-format-gson] Fixed problem when attempting to deserialise generic Lists. v3.180.0 [all] Update various dependencies. [http4k-testing-hamcrest] Improve messages of Hamkrest matchers. H/T @albertlatacz [http4k-cloudnative] Fix #291 - Readiness check result when there are > 2 checks may not report the correct result. H/T @alfi [http4k-security-oauth] [Possibly breaking] Making client_secret optional in AuthorizationCodeAccessTokenRequest to support non client_secret flows. H/T @tom v3.179.1 [http4k-client-okhttp] Include status description in Response object. v3.179.0 [http4k-contract] Added OpenApiExtension interface, which allows the definition of extensions that will modify the OpenApi specification JSON. H/T @rgladwell for the inspiration. [http4k-contract] Support composite security models using or() and and() . Once again, H/T @rgladwell :) v3.178.0 [http4k-security-oauth] [Possibly breaking] Request is passed as a parameter to the ClientValidator. Just pass it in! :) H/T @tom [http4k-contract] [Behaviour change] When specified, individual route security now replaces global security (this is as the security model in the OpenApi spec is specified) as opposed to both being applied. v3.177.0 [http4k-security-oauth] [Possibly breaking] More support for OIDC, adding state to AuthorizationCodeDetails, and passing it into createForAccessToken on IdTokens. H/T @tom v3.176.0 [http4k-security-oauth] More support for OIDC. H/T @tom v3.175.0 [all] Update various dependencies, including Kotlin to 1.3.50. [http4k-security-oauth] Some support for OIDC. H/T @tom v3.174.0 [all] Update various dependencies, including Jackson for a CVE. v3.173.0 [http4k-core] Fix #273 - parentSpanId trace incorrectly populated when no previous traces [http4k-contract] [Unlikely Break] Remodelled how Security is rendered, so it's possible that this may break slightly for customer implementations [http4k-contract] Added support for Implicit OAuth flow, with suport for custom googleCloudEndpoints Security. H/T @rgladwell v3.172.0 [http4k-core] Added uni-directional serialization/deserialization options to JSON lib auto-conversion configuration. v3.171.0 [http4k-core] [Break (mitigation)] Replaced default resource loader location for singlePageApp() to /public instead of root - this is for safety of NOT serving the root of the classpath by default. v3.170.0 [http4k-core] Add a warning when static() is used with no package path, thus exposing the contents of the classpath remotely. v3.169.0 [all] Update various dependencies. v3.168.0 [http4k-contract] Collect LensFailure causes into a single place when validating. v3.167.0 [http4k-contract] [Possibly Break] Open out ErrorResponseRenderer interface to take LensFailure instead of the individual failures when rendering badResponse() . To fix, simply wrap the list of failures into a LensFailure. v3.166.1 [http4k-core] Tweak singlePageApp() routing handler, to correctly apply filters when fallback page is used. v3.166.0 [http4k-core] Added singlePageApp() routing handler, which matches both static content or falls back to the root path index file v3.165.0 [http4k-contract] Fix invalid OpenApi2 when root and base path match. H/T @rgladwell [http4k-contract] ContractRoute is now an HttpHandler , so no need to wrap contract routes in a contract {} to test them. H/T @rgladwell for the inspiration. [http4k-contract] Support Host/baseUri values in OpenApi2. H/T @rgladwell [http4k-contract] Optionally add description route to route list H/T @rgladwell v3.164.0 [all] Update various dependencies, including Kotlin to 1.3.41. [http4k-testing-approval] Upgrade of HTML library from above may have an effect on output of HTML approval tests. [http4k-contract] Support for more Jackson annotations in JSON Schema rendering. H/T @tom for the PR contributing this. v3.163.0 [http4k-testing-chaos] Add detail to Chaos OpenApi interface. v3.162.0 [http4k-testing-chaos] Add detail to Chaos OpenApi interface. v3.161.0 [http4k-cloudnative] Added Forbidden request exception to HandleUpstreamRequestFailed. v3.160.1 [http4k-testing-chaos] Countdown chaos trigger fixed. v3.160.0 [http4k-testing-chaos] Slight fix to avoid consuming stream body when setting chaos. v3.159.0 [all] Update various dependencies. [http4k-client-okhttp] Updated OkHttp to v4.0.0 (Kotlin edition). [http4k-contract] Tweak to JSON Schema rendering to handle recursive objects better. v3.158.1 [http4k-server-netty] Fix #260 - cannot set multiple response headers with same name [http4k-server-undertow] Fix #260 - cannot set multiple response headers with same name v3.158.0 [http4k-contract] POSSIBLE BEHAVIOUR CHANGE DUE TO BUG: Fix #259 - Contract blocks do not produce 400s if an external CatchAll is provided. This may have an effect on how errors are generated (a 400 is produced instead of the previous 500 from the CatchAll). v3.157.1 [http4k-security-oauth] Fix broken deprecation annotation. v3.157.0 [http4k-security-oauth] Default to JSON format response in Access Token response [http4k-security-oauth] Renamed a couple of classes (AccessTokenContainer -> AccessToken), and removed isValid method from AuthorizationCodes because it doesn't make sense for this to be on the OAuthServer. v3.156.0 [all] Update Kotlin to 1.3.40 [http4k-contract] Support OAuthSecurity renderer. v3.155.2 [all] Update various dependencies. [all] Dokka improvements. Does not mitigate #196 as we run the main build on OpenJdk11. H/T @ivoanjo v3.155.1 DO NOT USE - broken v3.155.0 DO NOT USE - broken v3.154.1 [http4k-multipart] Made the multipart header parser case-insensitive. H/T @tenniscp25 v3.154.0 [http4k-contract] Add SchemaModelNamer to allow for custom JSON Schema model names. v3.153.0 [http4k-contract] OperationIds are generated without illegal characters {} . v3.152.0 [http4k-contract] Support non-string keys for \"text convertible\" values in maps for Auto-schema generation. v3.151.0 [http4k-contract] Fixed Auto-schema generation to detect and remove duplicate items from list schemas. v3.150.0 [http4k-security-oauth] Make authentication mechanism for grant types configurable. v3.149.0 [http4k-security-oauth] Initial support for client_credentials grant type. v3.148.0 [http4k-contract] Jackson property searching in OpenApi3 now searches superclasses. v3.147.0 [http4k-contract] Support custom JsonProperty annotation for OpenAPi3 generation [http4k-cloudnative] New exception type for unuathorised. H/T @tom v3.146.0 [http4k-contract] Fix #228 - Support Map-based fields in OpenApi 3 Auto-schema generation as additionalProperties . H/T @noahbetzen-wk for the idea. v3.145.0 [http4k-contract] Reimplement Auto-schema generation using reflection. Added test cases to use the OpenApi generator to create valid code-based OpenApi clients using the OpenApi generator. [http4k-format-jackson] Removed reflective JSON schema creator, since it was not actually OA3 compliant. v3.144.0 [all] Update various dependencies. [http4k-contract] Improvements to better adhere to OA3 spec. [http4k-security-oauth] Allow injecting OpenID's request parameter into the authorization request. [http4k-security-oauth] Expose request to AuthRequestTracking. v3.143.1 [http4k-core] Replace RequestContexts with reference to Store . H/T @amcghie [http4k-contract] Added some missing deprecations. [http4k-contract] Fix #243 - Nulls not allowed in OpenApi V3 JSON models. v3.143.0 [http4k-contract] Fix #239 - OpenApi v3 schemas for raw lists blow up when rendering. [all] Update various dependencies. v3.142.0 [http4k-contract] Both OpenApi v2 and v3 are now supported, including automatic schema generation. Some classes for OpenApi2 have moved to a new package - Deprecations should provide most alternatives. See module docs for details. For OpenApi v3, optionally include http4k-format-jackson to get JSON schema models based on JVM objects. [http4k-format-jackson] Added reflective JSON schema creator, to be used for generating named models from JVM objects. v3.141.0 [http4k-core] - Fix #233 - MemoryBody blows up with \"java.nio.ReadOnlyBufferException\" [http4k-core] - Tighten up security on Basic and Bearer auth server filters. H/T @andymoody [http4k-security-oauth] - Add filter to check bearer token is valid access token. H/T @andymoody v3.140.0 [all] Update dependencies (including Kotlin bump to 1.3.31) [http4k-security-oauth] Handle user rejecting/failing authentication. H/T @andymoody v3.139.0 [http4k-security-oauth] Allow access token generation to explicitly reject an authorization code already used. H/T @andymoody v3.138.1 [http4k-security-oauth] Amend error responses from access token generation. H/T @andymoody v3.138.0 [http4k-contracts] Tweaks to Security model for http4k-contracts . (Renamed) ApiKeySecurity is now a proper class, and added BasicAuthSecurity . You can now also override the security model on a per-route basis. [http4k-contract] Added ability to set the Security on each individual contract route. This overrides any Security set on a contract-level basis. v3.137.1 [http4k-serverless] Allow invocation of serverless functions locally. H/T @Charlyzzz [http4k-core] Fix #226 - ResourceLoadingHandler not close stream v3.137.0 [http4k-security-oauth] Rename AuthRequestPersistence to AuthRequestTracking v3.136.0 [http4k-security-oauth] Allow the http request to be referenced when generating OAuth authorization codes. H/T @andymoody v3.135.0 [http4k-core] Change mime.types location so it doesn't conflic with other libraries. H/T @benusher and @dgliosca [http4k-testing-chaos] Added SnipRequestBody behaviour. [http4k-core] (Small) Breaking Fixed location of some extension files to be relevant to the particular package that they are referencing. This will require reimporting the new location into your source if you were using the imports. v3.134.0 [http4k-testing-approval] Made content-type aware approval tests check the content type after the content. This is friendlier for failing tests, as it is more important that the content is correct than the content-type (and often errors don't have content type set so you get an erroneous error message which masks the fact that the content was wrong). v3.133.0 [http4k-cloudnative] HandleUpstreamRequestFailed client filter now takes a predicate (Response) -> Boolean instead of a boolean. This allows for more fine grained custom control of which Responses are acceptable. [all] Upgrade deps, including Kotlin to 1.3.30 . [http4k-contract] Fix #221 - Contract path fixed segments cannot contain slash characters. v3.132.0 [http4k-format-jackson] Convert Jackson to use readValue instead of convertValue . This fixes some problems with type conversions. v3.131.0 [http4k-core] (Possible) Break: Made lense implementations Query, Header etc clear previous values by default instead of appending. This leads to a more consistent behaviour. In order to be able to set multiple values on an object using a lense, use the multi form instead - eg. Header.required(\"foo\") -> Header.multi.required(\"foo\") . We envisage the impact of this change is limited as it's only Queries that generally can have multiple possible values, and in the vast majority of cases a replace rather than append is expected. v3.130.0 [http4k-contract] Generify contract handling code to allow for custom HttpMessageMeta<XYZ> v3.129.0 (Slight) Break: Collapsed UpstreamRequestFailed exceptions to contain the status, and thus removing non-special cases like BadRequest and BadGateway . This makes them much easier to use in practice as users have access to the the status. To migrate, simply replace previous classes with UpstreamRequestFailed(Status.XYZ, message) . [http4k-contract] Open up ContractRoute API to facilitate extension when defining a custom ContractRenderer . [all] Upgrade deps. v3.128.0 [http4k-core] Added base64 to the supported mappings for Query/Headers etc... [http4k-testing-approval] Approver does not write actual output if there is none to write and there is no approved content v3.127.0 [http4k-testing-approval] Improved Approver interface to more closely match the traditional assert<XYZ> approach - this results in a more discoverable/obvious API. [http4k-testing-hamkrest] Added ability to create a Hamkrest matcher directly from the Approver instance to be combined with other relevant matchers. v3.126.0 [http4k-testing-approval] Add support for XML and HTML approval tests. v3.125.0 Added http4k-testing-approval module, which is compatible with JUnit5 tests and integrates with the OkeyDoke approval testing files and IntelliJ plugin. H/T to @jshiell for the inspiration Gist containing the base Junit5 Extension. v3.124.0 [http4k-security-oauth] Make authentication response available when creating AuthorizationCode. v3.123.0 [http4k-security-oauth] Introduce OAuthServer to http4k-security-oauth to assist in the creation of authorization servers. v3.122.0 Generified GenerateXmlDataClasses filter, and added default implementations for http4k-format-jackson-xml and http4k-format-xml modules. (Rename) Break: GenerateXmlDataClasses filter in http4k-format-xml is now GsonGenerateXmlDataClasses Removed superfluous CatchLensFailure filter from http4k-contracts module. This is not required as lens failures are already handled by the main contract handler. v3.121.0 Moved Jackson XML support to new module http4k-format-jackson-xml . Note that this is for auto-marshalling of data-classes only and does not expose an XML DOM model. v3.120.0 Deprecated Body.view() lens construction in favour of a Body.viewModel() call which removes the implicitly called toLens() . This allows further mapping from one ViewModel type to another, and brings the view lens construction into line with the rest of the extension functions on Body . Add auto-marshalling XML support to http4k-format-jackson module. Upgrade deps. v3.119.0 Add UpstreamRequestFailed exceptions and HandleUpstreamRequestFailed filters to http4k-cloudnative . These allow apps to neatly deal with upstream failure in a sensible way. v3.118.0 Tweak contract() DSL to add remaining options for configuration. v3.117.0 Renamed ChaosControls (deprecated) to ChaosEngine . v3.116.0 Added new templating module http4k-templates-freemarker . H/T @amcghie for the PR implementing this http4k-contract has a new DSL for construction of the contract which replaces the old one (now deprecated). This is consistent with the meta DSL used to construct individual contract routes and avoids repetition of the old API. We attempted to implement the standard replace-with deprecation, but IntelliJ didn't like it (too complex maybe), so we've hard coded the warning instead which code which should work. Added PreFlightExtraction to contract module, which adds the ability to disable body-checking for contract routes. This will allow refining of routes or entire contracts to be more efficient. Upgrade deps. v3.115.1 Fix #217 - Cannot override the definitionId of a top-level array in OpenAPI Upgrade deps v3.115.0 Chaos now do not blat x-uri-template when used with a RoutingHttpHandler Simplified usage of Once chaos trigger. (Slight break) Consistentified (!) construction of Chaos Behaviours, Stages and Triggers. Replaced singletons with function calls. Eg. Always -> Always() v3.114.0 (Possible Break): Fix #215 - LensFailure does not always include target object. Only change to the API is that IN generic in Lenses is now bounded by IN : Any . This fix is a actually internally consistent as we could not always include the target otherwise (which is an Any? ). Trim leading and trailing whitespace from extracted EnvironmentKey values. Secret value is now only usable once via the use() function. Upgrade to various deps. Removed deprecations. v3.113.0 Added some common types for Environmental setup, and equivalent BiDiLens mappings Handle null response in Java Http client. H/T @FredNordin v3.112.2 Fix #212 - allow null values in HTTP contract definitions. This does mean we lose the type definition for that field, but we don't blow up silently (which was the previous behaviour). H/T @xhanin v3.112.1 Re-add Path.nonEmptyString() which was accidentally removed. v3.112.0 Add support for prohibiting String unmarshalling in JSON auto-marshalling configuration. HTTP Contracts now use the underlying ContractRenderer to produce the BadRequest and NotFound responses. Made OpenAPI open so that these responses can be customised. v3.111.0 Add support for JSON views in Jackson module. H/T @xhanin for the donkey work. v3.110.0 Breaking: slight rearrangement of RouteMeta receiving/returning methods to provide consistency when defining route contracts. v3.109.0 Moved the set of predefined String BiDiMapping instances to their own class. Bulked out the auto-mapping configuration options. v3.108.0 Upgrade to various deps. Extracted out new BiDiMapping type, which encapsulates string <-> type conversions and removes a boatload of duplications. These conversions are now used consistently across all the various places (Lenses, auto-mapping). Improved configurability of AutoMarshallingJson instances. v3.107.0 Upgrade to various deps. Fix #208 - Xml auto deserialisation incorrectly converting strings to numbers v3.106.1 Fix #207 - repeating prefixes in static routes are not handled correctly. H/T @ruXlab for the PR to fix. v3.106.0 Add http4k-server-ktorcio server backend. Note that whilst this module does allow http4k apps to plug into the Ktor-CIO engine, it does not provide fully front-to-back coroutine support. v3.105.0 Preventing FallbackCacheControl from duplicating existing headers. H/T @leandronunes85 Breaking: Make Body.length nullable instead of throwing exception when value is not available. H/T @zvozin v3.104.0 Upgrade to various deps. Add session token support to AWS filter, and \"credentials provider\" to allow for rotating AWS sessions. H/T @dhobbs. Breaking: Moved WsClient from org.http4k.testing to org.http4k.websocket . v3.103.2 Fix access-control-allow-origin returned when server supports multiple origins H/T @johnnorris v3.103.1 (Properly) Fix #198 - Rewrote OpenApi contract to ensure it stays fixed. H/T @reik-wargaming for the help in tracking this down. v3.103.0 \"Fix\" #198 - Breaking change made in http4k-contracts to clarify/deconfuse API. Hid body parameter in contract route meta DSL - it is now receiving() . Upgraded some dependencies, including Gradle to v5.0. Breaking: Resilience4j dependency upgrade causes a break when providing custom config. Simply insert the Config type generic to fix: e.g. RetryConfig.custom() -> RetryConfig.custom<RetryConfig>() v3.102.1 Fix #197 - Swagger spec for form fields had incorrect description. v3.102.0 Introduce interface for Environment v3.101.0 Upgrades to dependencies Improved Client-side HTTP status descriptions Lenses now support Durations out of the box Environments now support multi-value keys (comma separated) v3.100.0 Make Undertow API friendlier Fix to JsonReadinessCheckResultRenderer to actually implement the correct interface v3.99.0 Enhancement of http4k-cloudnative - now supports extra-health check routes, and provide way to load app configuration via Properties files. v3.98.0 Add filter allowing Gzipping based on an allowed set of content types. H/T @jshiell Change HttpHandler extending HttpClients to use object invoke() mechanism, as the individual clients have no visible API surface of their own. Introduced DualSyncAsyncHttpHandler interface. v3.97.0 Webdriver checkbox handling improved. H/T @gypsydave5 upgrade to various versions v3.96.0 upgrade to Kotlin 1.3.0 v3.95.1 Tweak to K8S port variables. v3.95.0 (Unlikely break): Change Http4kServer interface to return Unit from stop() . This affects all server implementations. Added DSL function for working with JSON objects (scopes JSON as this ). fun <T> Json<NODE>.invoke(Json<NODE>.() -> T) New module http4k-cloudnative contains classes to help run http4k services inside cloud-native environments, including K8S. Upgrade some dependencies Deprecation: Moved Header.Common fields to main Header object. Extension properties should go there now. v3.94.1 Use UTC when checking cookie expiry v3.94.0 Deprecate String.toBody() Fix checkbox behaviour in webdriver ~v3.39.4~ v3.93.4 Use Jetty latest release version (rather than RC one) v3.39.3 Fix #189 - Uri toString now omits leading slash if the authority of a Uri is blank. This could be a potential break, but is actually more consistent as a Uri can currently be relative or absolute. v3.39.2 Extend SetBaseUriFrom to support query parameters v3.39.1 Added SetBaseUriFrom filter v3.39.0 (Possible breaking change): Json is now only generified by a single type parameter instead of 2. For most usages, this type would have been identical anyway, but the upgrade of Argo has finally allowed the removal of this dead generic. Simply replace Json<Node, Node> with Json<Node> . Added Offset datetime types to all JSON auto-marshalling libraries Build logic for versioning is now in Kotlin. H/T @jmfayard for the PR Upgrade Kotlin, and various other dependencies v3.38.1 Fix withChaosControls URL pattern so that it matches sub-routes ok on original handler v3.38.0 Added BearerAuth and BasicAuth implementations which populate RequestContexts . Plus cookbook example :) v3.37.1 Fix #177 - Make RequestContexts thread-safe. v3.37.0 Upgrades to http4k-testing-webdriver . H/T @dickon for the PRs Added ProxyHost request filter which is useful for writing proxy-type apps. v3.36.1 Fix #168 - Fix rest of hamkrest matchers caused by generics mishap. Upgrade HTTP client dependency versions. v3.36.0 Added http4k-testing-chaos module, designed to enhance failure-mode testing for http4k apps. Massive H/T to @IgorPerikov for the PR which drove this module's creation. Added http4k-incubator module, for hosting developing projects and other code which might be promoted to top-level modules in the future. v3.35.2 Fix #167 - Reintroduce hasBody compatibility with common matchers such as containsString() Remove deprecations. v3.35.1 Fix #165 - AWS auth filter does not replace headers - it sets them (which breaks for request signing) Fix #164 - Webdriver internal state breaks when navigating to a full URL Fix #162 - SetHostFrom doesn't set 'Host' header correctly (missing port). H/T @elifarley v3.35.0 Added some regex matchers to http4k-testing-hamkrest . Added BearerAuth authentication Server and Client Filters - these work similarly to BasicAuth . Added option for defaulted() lenses to fall back to another supplied lens in the case of missing value. Thanks to @dmcg for the inspiration. :) v3.34.3 Fix #160 - JavaHttpClient does not copy body stream correctly onto URL connection. v3.34.2 Fix #159 - Contracts should not have Security applied to the description route by default. v3.34.1 Fix #158 - Static and contract routes filters are applied in the wrong order. v3.34.0 Add default SamplingDecision param to ZipkinTraces - defaults to always sample. Fix #150 - StaticRoutingHandler filters being called twice. Fix #151 - POTENTIAL BREAK: Rework of Status objects to fix equality against the Status constant vals when a description has been overridden. This involves the following potential breaking change: The Status class is no longer a data class to tighten up encapsulation - user calls to copy() will have to be replaced. v3.33.2 Raise SO_BACKLOG in Apache and Netty server implementations. Add PERMANENT_REDIRECT and UNPROCESSABLE_ENTITY Status object. v3.33.1 No change from 3.33.0. Previous version couldn't be made available to maven central. v3.33.0 Add convenient way to extract from as a Map from http message. H/T to @dmcg (this version is available in jcenter only) v3.32.1 Fix #142 - Pebble templates don't load from JAR files. v3.32.0 Add support for propagation of the Zipkin x-b3-sampled header v3.31.0 Changes to the Netty factory to enable running http4k on GraalVM. H/T @RichyHBM v3.30.0 Allow all server implementations to start on port 0 (ie. find a free port) and then report it back as a part of the Http4kServer interface v3.29.0 Make HTTP clients resilient to unknown host and connection refused exceptions Implemented #134 - Added default (de)serialization for common JDK primitives to all Auto-marshalling JSON modules - eg. date times and UUIDs v3.28.0 Fix #131 - Uri's created with paths that don't contain leading slashes. Added etag parser filter. H/T @dgliosca for the PR Fix #132 - Ensured that disableDefaultTyping is called in default Jackson implementation. This should be the default anyway, but has been added to ensure that we don't fall foul of CVE-2017-7525 and to surface awareness of this issue. v3.27.0 OpenAPI now provides example values in the generated schema. H/T @skewwhiffy for the PR. v3.26.6 Fix #126 - ResourceLoadingHandler can expose mapped resources into the root. <-- We think this is an important update, so please upgrade! v3.26.5 Fix #125 - ApacheServer implementation now sets content length if present. v3.26.4 Fix #123 - Multipart Body objects blow up when parsed after being debugged. As with all streams, care should be taken to not blow heap when internalising them for debugging purposes. v3.26.3 Debugging filter now supports ignoring Multipart streams. v3.26.2 Tweak: OpenAPI now doesn't return null values in the schema. v3.26.1 Fix #124 - headers in WebSocket upgrade request are incorrectly joined. v3.26.0 Removed supportedContentTypes field from OpenApi contract JSON, since this is a legacy field. v3.25.0 Added option to Undertow to enable HTTP2 from main ServerConfig v3.24.0 Upgrade various dependencies for Java 10 compatibility. H/T @tom Fix bug with repeated params in Websocket upgrade request. H/T @tom v3.23.1 Composite LensFailures now capture (at least) the first failing cause (probably the body parameter in the case of an http4k-contract module. v3.23.0 Fix #116 - Can provide a custom Response creation method for CatchLensFailure . H/T @elifarley for the inspiration! v3.22.4 Added singleton method for Json.array, since if you pass in a single JsonNode (Jackson), it accidentally iterates over the fields in the node instead of using the object as an entry in the array. Fix #115 - Only add content-length for methods that allow content in AwsAuth filter v3.22.3 Preserve routing information on request/response manipulation v3.22.2 http4k-security-oauth module added - with support for OAuth2 Authorization Grant flow Replaced classes reliant on javax.activation package, which allows Java 9+ to not require any external dependencies. \\o/ Fix #112 - ApacheClient incorrectly sets headers on GET requests (this breaks F5 load balancers). H/T @simojenki PR #110 - Websocket client timeouts are incorrectly translated as seconds instead of millis. HT @anorth Core JavaHttpClient does not support streaming due to limitations with HttpURLConnection v3.21.1 Fix #109 - Jackson treats integer values inconsistently, leading to matching errors when using hamkrest. v3.21.0 Fix #107 - Killed the x-uri-template header and fixed the ReportHttpTransaction to have access to the routingGroup . Altered ordering of filters in http4k-contract so that the route is identified before pre-filters and security are applied. This allows knowledge of the path to be accessible at the time of application of those filters. v3.20.0 Introduce JavaHttpClient to http4k-core . It provides a very basic http client without any other 3rd party dependencies. v3.19.0 PR #104 - Add optional time/date formatters to LensSpecs so you can choose you serialisation format. H/T @elifarley Fix #105 - Swagger API json file: duplicate key in \"definitions\". v3.18.1 Fixed PR #100 - URI template regex required extra escaping. This only affects Android deployments as IDE shows the regex escaping is redundant. H/T @privatwolke v3.18.0 Breaking: converted contract pre-security filter to be a post-security filter. This means that all standard filters are applied before the security later, which allows for logging and monitoring and context setup. The previous filter mechanic applied security first, which didn't allow for this. In the unlikely event that post-security filters still need to be applied, use the withPostSecurityFilter() function when building the contract. Docs for contract RouteMeta function parameters, and deprecated some unused functions (missed when we introduced the DSL). PR #99 - Contract routes now support up to 10 path segments. Thanks to @scap1784 for the PR! :) v3.17.1 Fix #97. Moshi does not fail when deserialise non-nullable fields correctly. Note that GSON still suffers from this problem v3.17.0 Added a pre-security filter option to contract creation, so that you can explicitly specify behaviour to occur before security kicks in. v3.16.0 Convert Security (from sealed class) and ApiKey to be interfaces. This allows users to implement their own security models. v3.15.0 Introduce HttpTransaction and new ReportHttpTransaction filter provide better generic API for reporting, along with the ability to label transactions for this purpose. Breaking: Rework the metrics request counter and timer Filter API. There is now a HttpTransactionLabeller for you to add as many labels as required to the transaction. Each of these labels will be used to tag the metric. v3.14.1 Fix #95 - Filters are now applied to \"route not found\" responses v3.14.0 Fix #93 - Apache server doesn't like content-length or transfer-encoding headers present in http4k response. Add ability to \"name\" input and output contract body definitions in an OpenAPI JSON doc. This applies to only the top level entity. If no override is passed, the objects are named according to their hashcode. 3.13.4 Fix #92 - cookie date should always use US locale v3.13.3 Further tweak to Netty. H/T @FredDeschenes v3.13.2 Fix #91 - large message handli ng in Netty v3.13.1 Upgrade to Kotlin 1.2.20 v3.13.0 Support for operationId in OpenApi route metadata. H/T @danschultz for the PR. Removed previously deprecated methods. v3.12.0 New client module http4k-client-jetty , which supports both sync and async models. v3.11.1 Fix #84. OPTIONS requests are not detected by contract routes. Added option to NOT authorise OPTIONS requests in ApiKey security filter. Added support for Async HTTP clients and added new AsyncHttpClient interface, which is obviously used for HTTP clients only**, and not server-side calls. :) New client module http4k-client-apache-async . New metrics gathering module http4k-metrics-micrometer . Big H/T to @kirderf for the PR. Added support for async to OkHttp client module. v3.10.0 P/R 81 - adding headers and timeout to websocket client. v3.9.0 Added compactify and prettify to Json implementations Added Json.hasBody Hamkrest matchers for comparing bodies. Note these are extension methods and need to be referenced/imported as such. v3.8.0 Added facility for non-blocking websocket client to react to onConnect event. This API is the same as the inbound, server-side API - ie. there are no explicit connection event handlers. H/T @tom for the idea. v3.7.0 P/R #13 Create extension methods for Response to add caching headers. H/T @k0zakinio. v3.6.1 Fix #78. Serialisation of raw lists using Moshi fails in the same way as the Jackson auto-conversions do. Added convenience methods to get around this. v3.6.0 Added http4k-format-moshi to support the Square auto-marshalling library. v3.5.1 Fix #76 - encoding of path segments to use URI encoding instead of URL form encoding. v3.5.0 Added support for multiple HotReload template directories in HandlebarsTemplates . H/T @TomShacham Fix #74 - Request tracing span/parentSpan set too early so was shared between outgoing requests. v3.4.0 New server backend http4k-server-apache . H/T @kirderf for the PR :) We now set the length of the incoming request body when it is available in the incoming request. v3.3.1 Handlebars now uses combination of Class and Template name to cache templates. v3.3.0 Facility to compose TemplateRenderers with then() to provide fallback behaviour. v3.2.3 PR #70: Header order equality for Request/Response - H/T @gypsydave5. v3.2.2 Switched out Status for WsStatus (with proper RFC code set) in Websockets. v3.2.1 Typesafe Websockets! Jetty now supports websockets, using the same style of API in the main http4k routing. (Possible) Breaking change: Because WsHandler (typealias) implements the same inbound interface as HttpHandler , you now cannot declare HttpHandlers without specifying the input type, so any \"anonymous\" handlers will not compile as a result. The required fix is very simple, but manual: `{ Response(OK) } should become { _:Request -> Response(OK) } v3.1.3 Fix Request.form() for streaming requests v3.1.2 Remove possibility of empty message for Path Lens failure. v3.1.1 New (better!) API for http4k-contract module. Old meta DSL has been deprecated. v3.0.1 Fix #63 - Apache Client Connect. timeout exception handling. v3.0.0 Added http4k-serverless-lambda module, allowing http4k applications to be deployed into AWS Lambda and then called from API Gateway. Effectively, the combination of these two services become just another Server back-end supported by the library. \\o/ v2.38.1 RequestContextKey now follow the standardised Lens structure of required, optional, defaulted, and can now be removed (set to null). Replace calls to RequestContextKey.of() with RequestContextKey.required() Removed previously deprecated values. See below for details on replacements. v2.37.0 Added http4k-resilience4j module, which adds Circuits, RateLimiters, Retrying and Bulkheading. Fix #60 (H/T @michaelhixson for the spot). v2.36.0 Added a couple of useful ServerFilters . Upgrade various dependency versions. Tidying of Multipart code. v2.35.1 Fix #57. Static handlers behave oddly when combined with an HTTP verb in the routing tree. v2.35.0 Fix #56. Altered behaviour of CatchLensFailure to NOT catch errors from unmarshalling Response objects. This was causing BAD_REQUEST to be incorrectly generated. Simplification of generics around LensSpecs. This should not be a breaking change, (there were 3 generics, now the MID has been removed so there are just 2) but could break if signatures are used explicitly. v2.34.0 Reordered generics in LensInjector to make sense. This should have no effect on most code-bases, but could break if signatures are used explicitly. Just flip the generic types to switch. v2.33.1 Added support for unsigned AWS requests, which enables streaming content to S3. v2.33.0 Added BodyMode.Request to configure streaming for clients. ResponseBodyMode is now BodyMode.Response (Breaking change. Fixable with simple find/replace). v2.32.0 Added ServerFilter.ProcessFiles filter to stream Multipart Files, convert them into references and replace inline in the Form. v2.31.4 Avoid realising StreamBody unless necessary, which could break common usages of streaming. v2.31.3 Tweaks to Server backends to improve efficiency. v2.31.2 Webdriver will keep only the final URI after redirects. v2.31.1 Increased granularity of Replay.DiskStream and ensure that traffic is returned in exact order on all OSes. Add support for redirects to Webdriver. v2.31.0 Multipart module tweaked to provide a more consistent API. Fix FollowRedirects for POST/PUT request. v2.30.0 Multipart form support through new module http4k-multipart . Deprecation: Replaced Swagger with OpenApi and deprecated the former (via typealias). Deprecation: Replaced FormValidator with Validator and deprecated the former (via typealias). v2.29.4 Refactor release. v2.29.3 Fix #50 - Webdriver does not normalise relative links correctly. v2.29.2 Http client modules now catch and convert Socket Timeout exceptions to HTTP 504s (with a custom message) v2.29.1 Tweaks to how recorded traffic is stored on disk. Thanks to @dkandalov for the PR around this. v2.29.0 Added TrafficFilters for recording and replaying HTTP traffic. See org.http4k.traffic package for details. v2.28.0 Added http4k-template-dust for Dust template engine support. Thanks to @npryce for the PR to add this. v2.27.2 Fix #44 - Use quotes around cookie values v2.27.1 Raise proper Exception (instead of LensFailure) when RequestContexts are not set up correctly, so we don't accidentally classify developer errors as BadRequests v2.27.0 Added facility to assign values into a RequestContext which is passed down the Filter chain. v2.26.3 Fix #44 - Request cookies should not be wrapped in quotes. v2.26.2 Fix #43 - AWS does not sign binary requests correctly. v2.26.1 Fix #41 - Sending binary body alters the size of the payload. v2.26.0 Added \"catch all\" routing option, which matches all methods to a handler. v2.25.4 Fix #40 - GZip filters now use content-encoding headers instead of transfer-encoding. v2.25.3 Fix #39 - ResponseBodyMode.Memory properly closes streams (breaks jetty + gzip). v2.25.2 Ensure that streams are closed properly when consuming from an upstream client. v2.25.1 Remove Apache client request streaming because it may not release connections properly. v2.25.0 Add streaming support to HTTP Server and Client modules. Remove CatchLensFailure ClientFilter as it will never be used. v2.24.0 Added CatchLensFailure for ClientFilters - which catches un-deserializable invalid responses from clients and generates a BAD_GATEWAY error. v2.23.4 Switch XML generation to Gson over Jackson because Jackson doesn't handle uppercase field names well. Switch native XML parsed type to Document over Node. v2.23.3 New algorithm for XML data class deserialisation, so un-deprecated XML methods. v2.23.2 Deprecated methods in XML support due to limitation with underlying Jackson implementation. v2.23.1 Fixed bug with GenerateXmlDataClasses filter v2.23.0 Renamed http4k-format-jackson-xml module to http4k-format-xml . Improved XML unmarshalling support. v2.22.1 Fixed 36: Form entry is too strict with content encoding. v2.22.0 Added http4k-format-jackson-xml module, with XML parsing support. Upgrade several dependencies v2.21.2 Fixed Hamkrest matchers to be on HttpMessage and not Http Request. v2.21.1 Default body Content Negotiation strategy changed to None v2.21.0 Converted Content-Negotiation strategy from an Enum to an interface, so that users can define their own strategies. We also now check encoding so there are 4-built in strategies to choose from: Strict, StrictNoDirective, NonStrict and None. v2.20.1 Fixed #31 - Matching of segments in URIs is done after URLs are decoded, which results in not capturing encoded slashes in the path segments. v2.20.0 Fixed #30 - CachingClasspath template ResourceLoader not working with non-root packages. v2.19.0 Fixed #29 - webdriver submission of text area. Http clients now use a new instance of the default for each instantiation. Previously there was a shared instance. Add regex body type for parsing values out of bodies, and \"None\" option for content negotiation. v2.18.3 Fix AWS request signing for requests containing empty path v2.18.2 Fix AWS request signing for requests containing path with special characters v2.18.1 Added support for newRequest() in new RouteBinder mechanic. v2.18.0 Add support for unlimited nesting for routes() blocks. Removed the raw Route object, which can be replaced with Router or RoutingHttpHandler where appropriate. As part of above, rejigged route setup logic. Deprecated old routing structure, so now \"/path\" to GET bind is \"/path\" bind GET to . To fix deprecation, simply switch the calls to \"to\" and \"bind\" in routing setup. Rename of bind() in http4k-contract to be bindContract() v2.17.2 Added missing eclectic HTTP method. :) v2.17.1 Added GZip filters to http4k-core to zip request and response bodies. v2.16.1 Improved messages for http4k-testing-hamkrest matchers. v2.16.0 Added http4k-testing-hamkrest which contains a set of Hamkrest matchers for Http4k objects. v2.15.0 More features for http4k-testing-webdriver . Cookie support added. v2.14.0 More features for http4k-testing-webdriver . We now support Form entry and submission. v2.13.0 More features for http4k-testing-webdriver . v2.12.0 Added http4k-testing-webdriver module, an ultralight Selenium WebDriver for http4k apps v2.11.3 Fix #26 - GenerateDataClasses does not recurse into nested object trees v2.11.2 Fix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with then(RoutingHttpHandler() v2.11.1 Fix static routes not defaulting to index.html when in root context v2.11.0 Added SunHttp server implementation (for development use only) v2.10.1 Fix cookie parsing when value contains '=' v2.10.0 Add method to set form values in the request v2.9.0 Added PURGE HTTP method as it's used commonly by various caches. v2.8.1 Repackage AWS classes for consistency with rest of project v2.7.1 Alter AWS Auth filter creation. Now use ClientFilters.AwsAuth v2.7.0 Add AWS module v2.6.0 Newly created Zipkin traces are now populated onto incoming request in ServerFilters. v2.5.1 Slight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling v2.5.0 Add Thymeleaf templating support v2.4.0 Add Pebble templating support v2.3.0 Make Route a Router so we can nest them together. v2.2.1 Remove excess \"charset\" from headers in Undertow. v2.2.0 Rename by() to bind() in routing for clarity. v2.1.2 Fix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex. v2.1.0 Added GSON full-auto functions to convert arbitary objects to/from JSON. v2.0.5 Fix #23. Contract now supports multi-part URL params (for hardcoded parts) v2.0.4 Fix #22. Uri template does not parse out correct path params when URL starts with a path part. v2.0.3 toString() implementations to aid debugging v2.0.1 Readded missing default parameter for newRequest() on RouteSpec v2.0.0 Breaking: Inversion of routing API. GET to \"/someUri\" is now \"/someUri\" to GET for consistency across the entire API. v1.33.1 Reimplementation of http4k-contract API to match main routing API. Contracts are now nestable. v1.32.2 Fix Filters being applied twice in ContractRoutingHttpHandler v1.32.1 More work on http4k-contract contract API v1.31.0 Rework http4k-contract routing to be mounted in the same way as other RoutingHttpHandlers v1.30.0 Filters are now applied consistently to all Routers v1.29.0 Tweak to DSL for defining StaticRouters v1.28.1 Fix for #18: FollowRedirect will now work if location header includes charset information. v1.28.0 New DSL for defining StaticRouters v1.27.0 Merged StaticContent and StaticRouter and repackage of contract API into other packages v1.26.2 Extend fix for #17 to request Cookie header. v1.26.1 Fix for #17. Cookie can now parse a cookie without attributes and ending in semicolon. v1.26.0 Added nestable Routers. Merging of Modules and Routers. Router is the new Module ! RouteModule is now ContractRouter , so rename in code will be required. v1.25.1 Fix for #15. OkHttp client handling of POSTs with no body. v1.25.0 Can add custom mime types to Static Content GenerateDataClasses is capable of more complex object graphs v1.24.0 Remove HttpHandler.asServer in favour of HttpHandler.startServer to avoid confusion. Introduce Status.description() . v1.23.0 Netty sets content-length header. v1.22.2 Fix for #12. Undertow not constructing response correctly. v1.22.0 New module with Undertow.io support http4k-server-undertow Jackson implementation now ignores unknown properties in incoming messages Netty implementation tidied up v1.21.1 Fix for #11. Netty implementation returns incorrect status codes. v1.21.0 Add synonym methods for Lenses to aid readability. We now have invoke(IN)/extract(IN) and `invoke(IN, TARGET)/inject(IN, TARGET) v1.20.0 http4k-contracts : Add option to change the route of the module description route v1.19.1 http4k-contracts : Fix for contract module description routes not being authenticated via security filter v1.19.0 http4k-contracts : Add Swagger module rendering with JSON schema models for messages. v1.18.0 Add nonEmptyString() lens type to all request parts. v1.17.0 General rework v1.16.0 Further work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios. v1.15.0 Path lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc. Routes can now create shell Requests for themselves, using route.newRequest() v1.14.0 Body is now non-nullable (use Body.EMPTY instead) Rename methods BodyLens API for consistency and clarity. required() is now toLens() . to()' binding method is now of(). v1.13.0 New client module: http4k-client-okhttp v1.12.0 Tidying v1.11.0 Added option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :) v1.10.0 Moved Credentials to org.http4k.core package. Add various filters, including SetHostFrom and CatchAll . v1.9.0 Added GenerateDataClasses so you can generate Kotlin data classes from JSON messages. v1.8.0 Added CORs support v1.7.0 Added auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses v1.6.0 Added CachingFilters v1.5.0 Removed static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions. Merge org.http4k.core.Body and org.http4k.lens.Body . Add Request/Response message parsers. v1.4.0 Turn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected. v1.3.0 Removed non-mandatory parameters from Request and Response constructors. This is aid API clarity. and force users to use the API methods for properly constructing the objects. Regex Lens added. v1.0.0 Initial major release.","title":"Changelog"},{"location":"changelog/#v32480-uncut","text":"[all] Upgrade some dependency versions. [http4k-cloudnative] - Fix #418 - Fix separator propagation when adding values to an existing MapEnvironment. H/T @jshiell","title":"v3.248.0 (uncut)"},{"location":"changelog/#v32470","text":"[http4k-server-ktornetty] New backend module! H/T @albertlatacz for the contribution! [all] Upgrade some dependency versions. [http4k-security-oauth] Fix #414 BasicAuth server filter to not throw an exception on invalid base64 input. H/T @Sebruck for the fix.","title":"v3.247.0"},{"location":"changelog/#v32460","text":"[all] Upgrade some dependency versions. [http4k-template-pebble] Fix #411 - Non-root pebble templates when using CachingClasspath from a compiled JAR. H/T @alyphen","title":"v3.246.0"},{"location":"changelog/#v32451","text":"[http4k-server-ktorcio] Fix #410 - KtorCIO does not stop properly.","title":"v3.245.1"},{"location":"changelog/#v32450","text":"[all] Upgrade some dependency versions. [http4k-core] Factored out Http4kServletAdapter to allow usage of the Servlet API outside of creating a Servlet instance. [all] [Breaking (prevent API abuse)] Restricted generic with() method actual http4k types. Usage outside our API should not use this method. [http4k-contract] Fix #404 - Rework of some FieldRetrieval classes to remove duplication and to support PropertyNamingStrategies set at the global level","title":"v3.245.0"},{"location":"changelog/#v32440","text":"[all] Upgrade some dependency versions. [all] [Breaking (if you're not using it right!)] Fix #397 - Fixed up Maven dependencies so that they are not bringing in runtime libraries. [http4k-core] - Add enum StringBiDiMapping #395 - H/T @goodhoko","title":"v3.244.0"},{"location":"changelog/#v32430","text":"[all] Upgrade some dependency versions, including Kotlin to 1.3.72 . [http4k-security-oauth] A strategy can now be passed into AuthRequestWithRequestAuthRequestExtractor to determine how to combine AuthRequest and RequestObject H/T @tom","title":"v3.243.0"},{"location":"changelog/#v32420","text":"[all] Upgrade some dependency versions. [http4k-testing-servirtium] Improve error diagnostics. H/T @vchekan for the PR. [all] [Unlikely Break] Change Router to return RouterMatch instead of nullable HttpHandler . This allows us to support METHOD_NOT_ALLOWED (405) if we match a path but not a verb instead of just NOT_FOUND (404). This should break custom ro H/T @jshiell for the PR.","title":"v3.242.0"},{"location":"changelog/#v32410","text":"[http4k-security-oauth] [Breaking] client_id along with the corresponding TokenRequest is passed into access and refresh token generators so additional validation can take place H/T @tom","title":"v3.241.0"},{"location":"changelog/#v32400","text":"[all] Upgrade Kotlin to 1.3.71 . [http4k-testing-servirtium] Switch OkHttp client for Apache. [http4k-server-jetty] Made some classes non-internal so they can be easily reused for custom ServerConfig implementations.","title":"v3.240.0"},{"location":"changelog/#v32390","text":"[http4k-client-websocket] [Breaking] Added extra onError handler when creating a non-blocking websocket. [all] Upgrade some dependency versions, including Kotlin to 1.3.70.","title":"v3.239.0"},{"location":"changelog/#v32380","text":"[http4k-security-oauth] Early work on supporting refresh tokens. H/T @tom","title":"v3.238.0"},{"location":"changelog/#v32370","text":"[http4k-core] Fix #377. Added replaceHeaders() method. Thanks to @bastman for the idea. [http4k-contract] Fix nullability of references in OpenApi3","title":"v3.237.0"},{"location":"changelog/#v32360","text":"[http4k-testing-servirtium] Don't pass recording handler into non-test methods as a resolved parameter.","title":"v3.236.0"},{"location":"changelog/#v32350","text":"[http4k-testing-chaos] [Break/Rename] ChaosEngine is now exposed when configuring API. Renamed withChaosEngine() to withChaosApi() , replaced toggle() and update() with enable()/disable()","title":"v3.235.0"},{"location":"changelog/#v32340","text":"[http4k-testing-chaos] [Break] Tweaked API make it simpler to use the ChaosEngine via programmatically (as opposed to REST). [http4k-testing-servirtium] [Tiny break] Tweaks to InteractionOptions to make working with Servirtium tests a bit nicer.","title":"v3.234.0"},{"location":"changelog/#v32330","text":"[http4k-testing-servirtium] Upgrade ServirtiumServer to use OkHttp instead of JavaHttpClient (due to streaming restrictions on MiTM). [http4k-testing-servirtium] [Break] Rename Github to GitHub .","title":"v3.233.0"},{"location":"changelog/#v32320","text":"[http4k-format-kotlinx-serialization] New JSON module! H/T @joscha-alisch for the PR. :) [http4k-testing-servirtium] Work around Kotlin @JvmOverloads problem in ServirtiumServer. [all] Upgrade some dependency versions.","title":"v3.232.0"},{"location":"changelog/#v32310","text":"[http4k-testing-servirtium] Making API a bit more Java-compatible friendly. Ability to vary the Server implementation. [http4k-server-jetty] Fix #362 - Websocket disconnect early causes lateinit reference race condition. H/T @fintara for the report/fix.","title":"v3.231.0"},{"location":"changelog/#v32300","text":"[http4k-aws] Improved efficiency of building AWS credentials (replace String.format). [http4k-testing-servirtium] Making API a bit more Java-compatible friendly. [all] Upgrade some dependency versions.","title":"v3.230.0"},{"location":"changelog/#v32290","text":"[http4k-security-oauth] Allowing for custom authenticate methods when fetching access tokens H/T @tom","title":"v3.229.0"},{"location":"changelog/#v32280","text":"[http4k-testing-servirtium] [Breaking] API is still in beta, so moving to a more composed approach which will increase reuse and allow for running Servirtium infra without a dependency on http4k or Junit. Added loading from GitHub. :) [http4k-security-oauth] [Breaking] Audience on request object is now a list to support multiple audiences. H/T @tom [http4k-security-oauth] Nonce is now also passed through on RequestJwts, so it can be added to request jwts. H/T @tom","title":"v3.228.0"},{"location":"changelog/#v32270","text":"[http4k-core] Implmement #340. Support SameSite cookies. H/T @danielwellman for the contribution. [http4k-format-jackson] Made JacksonJsonPropertyAnnotated Kotlin 1.4 safe (call to superclass might return null). H/T @pyos for spotting this.","title":"v3.227.0"},{"location":"changelog/#v32260","text":"[http4k-testing-servirtium] Moved Servirtium code to new module - was previously [http4k-incubator].","title":"v3.226.0"},{"location":"changelog/#v32250","text":"[http4k-incubator] Rewrote Servirtium code to support manipulations.","title":"v3.225.0"},{"location":"changelog/#v32240","text":"[http4k-security-oauth] Fix issue where AuthRequestWithRequestAuthRequestExtractor doesn't take into account scopes not being nullable correctly. H/T @tom","title":"v3.224.0"},{"location":"changelog/#v32230","text":"[http4k-security-oauth] Adding expiry to RequestObject . H/T @tom [http4k-security-oauth] Fixing issue where unknown fields cause extracting RequestObject from a jwt, fails due to unknown fields. H/T @tom","title":"v3.223.0"},{"location":"changelog/#v32220","text":"[http4k-security-oauth] [Breaking] Error responses in the authorise endpoint now take into account values from the request parameter, this will require a validator for that jwt be implemented. H/T @tom [http4k-security-oauth] [Breaking] State is now its own type, and not just a string, so it can be validated. H/T @tom [http4k-security-oauth] [Breaking] redirectUri on AuthRequest is now nullable as it might come on a request jwt, this is validated to be always be present downstream. H/T @tom [http4k-security-oauth] Allow parsing of request jwt. H/T @tom [http4k-security-oauth] Adding RequestObject to AuthRequest . H/T @tom [http4k-security-oauth] Adding AuthRequestWithRequestAuthRequestExtractor that will extract the request from the jwt, assuming the validator is implemented which can be used instead of just using AuthRequestFromQueryParameters if support for parsing a request jwt is required. H/T @tom","title":"v3.222.0"},{"location":"changelog/#v32210","text":"[all] [Unlikely break from Java only] Make all custom http4k exceptions extend RuntimeException. This helps with Java compatibility so things like LensFailure inside Java Lambdas don't require catching (as they are caught/dealt with by other bits of http4k automatically)","title":"v3.221.0"},{"location":"changelog/#v32200","text":"[http4k-moshi] [Behaviour break] Fix #353 Don't fail by default on unknown properties. This is the expected default behaviour for all JSON implementations. H/T cnusp for the report.","title":"v3.220.0"},{"location":"changelog/#v32190","text":"[http4k-incubator] Next iteration of Servirtium JUnit extensions. Improved API to support multiple storage engines.","title":"v3.219.0"},{"location":"changelog/#v32180","text":"[http4k-incubator] Next iteration of Servirtium JUnit extensions. Correct indexing of interactions. [http4k-security-oauth] Authorisation rendering will now taking into account 'response_mode' of either query or fragment in responses and no longer just use the default fo the 'response_type'. H/T @tom [http4k-security-oauth] [Breaking] Error responses in the authorise endpoint will actually redirect back to 'redirect_uri' assuming the validator correctly validates both the 'client_id' and 'redirect_uri' to be valid. H/T @tom","title":"v3.218.0"},{"location":"changelog/#v32170","text":"[all] Upgrade some dependency versions. [http4k-incubator] Next iteration of Servirtium JUnit extensions. Only check content which is in the contract when replaying.","title":"v3.217.0"},{"location":"changelog/#v32160","text":"[http4k-core] [Breaking] Removed clashing Events then() from deprecated (meaning it cannot be used as there is also another then() in that package). Use the one in org.http4k.events instead. [http4k-security-oauth] Adding nonce to AuthorizationCodeDetails H/T @tom","title":"v3.216.0"},{"location":"changelog/#v32150","text":"[http4k-core] GZip client filters now send correct accept-encoding header. @jshiell [http4k-core] New AcceptGZip client filter allows handling of remote GZip without compressing client requests. @jshiell","title":"v3.215.0"},{"location":"changelog/#v32140","text":"[http4k-core] Fix #344 H/T Streaming GZip encoder loses data. @jshiell","title":"v3.214.0"},{"location":"changelog/#v32130","text":"[http4k-security-oauth] Fixing wrong AuthRequestExtractor passed to AuthRequestTrackingFilter. H/T @tom","title":"v3.213.0"},{"location":"changelog/#v32120","text":"[http4k-security-oauth] allowing additional properties to be stored on auth request, if using additional extractors H/T @tom","title":"v3.212.0"},{"location":"changelog/#v32110","text":"[http4k-core] Fixes for #338 - Gzip filters send content-encoding of gzip even when body is empty. H/T @jshiell [http4k-security-oauth] [Break] OIDC callback urls using the ResponseType 'code id_token' will now have the parameters returned as a fragment not a query as per 3.3.2.5 of the OpenID Connect Core 1.0 spec H/T @tom [http4k-security-oauth] [Break] Initial support of nonce in OIDC requests H/T @tom","title":"v3.211.0"},{"location":"changelog/#v32100","text":"[http4k-core] Support for GZipping response streams. H/T @jshiell [http4k-security-oauth] Adding expires_in to token endpoint response. H/T @tom","title":"v3.210.0"},{"location":"changelog/#v32090","text":"[all] Added Status to auto-marshalling JSON mappings. [http4k-security-oauth] Adding token_type to token endpoint response, and strip out nulls in response. H/T @tom","title":"v3.209.0"},{"location":"changelog/#v32080","text":"[all] Upgrade some dependency versions. [http4k-core] PR #333. Copy zipkin traces across threads. H/T @jshiell for the PR. [http4k-testing-approval] Close Readers when reading from them. [http4k-incubator] Next iteration of Servirtium JUnit extensions for recording and replaying.","title":"v3.208.0"},{"location":"changelog/#v32070","text":"[all] Upgrade some dependency versions [http4k-incubator] Added first cut of Servirtium classes for recording and replaying traffic. Needs validating in the wild [http4k-format-jackson] Fix #320. http4k-format-jackson incompatible with jackson-module-kotlin 2.10.1","title":"v3.207.0"},{"location":"changelog/#v32060","text":"[all] Upgrade some dependency versions. [http4k-contract] Fix #323. Doc generation does not work with multipart lenses. [http4k-format-jackson] Fix #313. Jackson serialization is not working properly with polymorphic types stored in a collection. H/T @alphaho for the PR :) [http4k-core] [Break] Renamed value on ParamMeta to description .","title":"v3.206.0"},{"location":"changelog/#v32050","text":"[all] Upgrade some dependency versions, including Kotlin to 1.3.61 [http4k-security-oauth] allowing setting scopes on AccessToken creation so they are set on the response. H/T @tom","title":"v3.205.0"},{"location":"changelog/#v32040","text":"[http4k-core, http4k-aws] - increase efficiency of Hex implementation for trace ids and HMAC. H/T @time4tea [http4k-cloudnative] Reimplemented Environment to be more efficient. H/T @time4tea for noticing this.","title":"v3.204.0"},{"location":"changelog/#v32030","text":"[http4k-security-oauth] On generating tokens allowing for the client id to be based on the result of validation rather than just the form parameters of the request. To support client assertions. H/T @tom","title":"v3.203.0"},{"location":"changelog/#v32020","text":"[http4k-security-oauth] Adding new errors to support issues with client assertions. H/T @tom","title":"v3.202.0"},{"location":"changelog/#v32010","text":"[http4k-security-oauth] Allowing a scope to be set on AccessToken. Allowing for more low level validation of Authorise and Token Requests, by implementing org.http4k.security.oauth.server.AuthoriseRequestValidator and org.http4k.security.oauth.server.accesstoken.AccessTokenRequestAuthentication respectively. H/T @tom","title":"v3.201.0"},{"location":"changelog/#v32000","text":"[http4k-contract] Support multiple request bodies in OpenApi v3","title":"v3.200.0"},{"location":"changelog/#v31991","text":"[http4k-format-jackson] Fix #313 Part 2 - Revert default behaviour for collections of polymorphic types, but is now overridable by using autoBody() instead of auto() . Reopened #313.","title":"v3.199.1"},{"location":"changelog/#v31990","text":"[http4k-format-jackson] [Breaking] Fix #313 - ConfigurableJackson.autoBody implementation would not work with collections of polymorphic types. This fix has the effect of blowing up auto-json behaviour when classes are defined inside functions (causing nasty java.lang.reflect.GenericSignatureFormatError: Signature Parse error exceptions). To remedy, just move inlined classes outside of the functions that they are defined in. H/T @alphaho for the PR. [all] Update some dependency versions","title":"v3.199.0"},{"location":"changelog/#v31980","text":"[http4k-core] [Breaking] Reworking of ContentType to support multiple directives. directive field is now directives , so just add the extra 's' to fix :) [http4k-security-oauth] Moar options on OAuthProviderConfig . H/T @tom","title":"v3.198.0"},{"location":"changelog/#v31970","text":"[all] Update some dependency versions, including Kotlin to 1.3.60 . [http4k-core] Make Query value optional when setting on a Request . [http4k-core] [Breaking] Fix #316. Optional Query lens handling is more accurate. See issue for details of change in behaviour.","title":"v3.197.0"},{"location":"changelog/#v31960","text":"[all] Update some dependency versions. [http4k-format-jackson, http4k-format-gson] Add support for auto marshalling Throwable in a sensible way. [http4k-cloudnative] Renamed badly named UpstreamRequestFailed to RemoteRequestFailed . Improved error handling.","title":"v3.196.0"},{"location":"changelog/#v31951","text":"[http4k-cloudnative] Fix adding value to overridden environment when using set() . H/T @jippeholwerda for the PR","title":"v3.195.1"},{"location":"changelog/#v31950","text":"[http4k-security-oauth] Tweak to handle Content-Type comparisons (with and without directive). H/T @jippeholwerda for the PR [http4k-multipart] - [Breaking] Added support for setting custom headers in Multipart form fields and files. This has removed the String as the default field type (it is now MultipartFormField . Calls to create lenses using MultipartFormField will now require MultipartFormField.string() instead.","title":"v3.195.0"},{"location":"changelog/#v31940","text":"[http4k-contract] Useful tweaks to the contracts API","title":"v3.194.0"},{"location":"changelog/#v31931","text":"[http4k-cloudnative] Fix #304 - map get() does not respect fallback values in overridden environment.","title":"v3.193.1"},{"location":"changelog/#v31930","text":"[http4k-contract] Marking endpoints as deprecated in OpenApi3","title":"v3.193.0"},{"location":"changelog/#v31920","text":"[http4k-template-jade4j] New module! H/T @RichyHBM for the contribution! :)","title":"v3.192.0"},{"location":"changelog/#v31910","text":"[http4k-contract] Better support for overriding of raw map definition id in JSON schema generation","title":"v3.191.0"},{"location":"changelog/#v31900","text":"[http4k-core] Added method to (immutably) modify status on Response . H/T @brandon-atkinson for the suggestion [http4k-core] Added composite object support to lens system, allowing creation of simple lenses which draw from several different values (of the same location only - e.g Query/EnvironmentKey) [http4k-contract] Support for overriding the entity definition id in JSON schema generation [all] Update some dependency versions.","title":"v3.190.0"},{"location":"changelog/#v31890","text":"[http4k-server-netty] Fix reported port in Netty . H/T @fantayeneh for the PR :) [http4k-security-oauth] Add validateScopes() to ClientValidator . H/T @tom","title":"v3.189.0"},{"location":"changelog/#v31880","text":"[http4k-contract] Support multiple-response models in OpenApi2 and 3. Note that this currently is unsupported in the OpenApi UI due to a bug (which doesn't display the schema for the response correctly). However, the JSON schema is generated correctly in these cases. [all] Update some dependency versions.","title":"v3.188.0"},{"location":"changelog/#v31870","text":"[all] Update some dependency versions, and changes to various APIs involved (Jackson and Resilience4J) [http4k-core] - Add YearMonth support to standard JSON mappings [http4k-format-jackson, http4k-format-gson] [Possible break] - Moved reified NODE.asA() method from JsonLibAutoMarshallingJson down onto the instances of the Json ( ConfigurableJackson / ConfigurableGson ). This is so that we can handle generified classes such as lists and maps correctly. (As per the problems fixed in 3.181.0)","title":"v3.187.0"},{"location":"changelog/#v31860","text":"[http4k-core] - Rollback a couple of places which were using Java9+ APIs (for no good reason).","title":"v3.186.0"},{"location":"changelog/#v31850","text":"[http4k-contract] Improvements to rendering enums as their own objects in JSON Schema.","title":"v3.185.0"},{"location":"changelog/#v31840","text":"[http4k-contract] Add Cookies options to contract DSL","title":"v3.184.0"},{"location":"changelog/#v31830","text":"[http4k-serverless-lambda] Add ability to access Lambda context. H/T @ivoanjo for the PR. [http4k-contract] Fix rendering of OrSecurity when there are more than 2 parts.","title":"v3.183.0"},{"location":"changelog/#v31820","text":"[http4k-core] Rename EventsFilter to EventFilter because sanity. [http4k-format-jackson, http4k-format-gson] Reintroduce autoBody() method","title":"v3.182.0"},{"location":"changelog/#v31810","text":"[http4k-core] Added base events implementations for StructuredLogging. [http4k-core] [Repackage] Events classes are now in org.http4k.events . [http4k-core] [Breaking] EventCategory is no longer a field of Event . To fix, just remove override from your Event classes. [http4k-format-jackson, http4k-format-gson] Fixed problem when attempting to deserialise generic Lists.","title":"v3.181.0"},{"location":"changelog/#v31800","text":"[all] Update various dependencies. [http4k-testing-hamcrest] Improve messages of Hamkrest matchers. H/T @albertlatacz [http4k-cloudnative] Fix #291 - Readiness check result when there are > 2 checks may not report the correct result. H/T @alfi [http4k-security-oauth] [Possibly breaking] Making client_secret optional in AuthorizationCodeAccessTokenRequest to support non client_secret flows. H/T @tom","title":"v3.180.0"},{"location":"changelog/#v31791","text":"[http4k-client-okhttp] Include status description in Response object.","title":"v3.179.1"},{"location":"changelog/#v31790","text":"[http4k-contract] Added OpenApiExtension interface, which allows the definition of extensions that will modify the OpenApi specification JSON. H/T @rgladwell for the inspiration. [http4k-contract] Support composite security models using or() and and() . Once again, H/T @rgladwell :)","title":"v3.179.0"},{"location":"changelog/#v31780","text":"[http4k-security-oauth] [Possibly breaking] Request is passed as a parameter to the ClientValidator. Just pass it in! :) H/T @tom [http4k-contract] [Behaviour change] When specified, individual route security now replaces global security (this is as the security model in the OpenApi spec is specified) as opposed to both being applied.","title":"v3.178.0"},{"location":"changelog/#v31770","text":"[http4k-security-oauth] [Possibly breaking] More support for OIDC, adding state to AuthorizationCodeDetails, and passing it into createForAccessToken on IdTokens. H/T @tom","title":"v3.177.0"},{"location":"changelog/#v31760","text":"[http4k-security-oauth] More support for OIDC. H/T @tom","title":"v3.176.0"},{"location":"changelog/#v31750","text":"[all] Update various dependencies, including Kotlin to 1.3.50. [http4k-security-oauth] Some support for OIDC. H/T @tom","title":"v3.175.0"},{"location":"changelog/#v31740","text":"[all] Update various dependencies, including Jackson for a CVE.","title":"v3.174.0"},{"location":"changelog/#v31730","text":"[http4k-core] Fix #273 - parentSpanId trace incorrectly populated when no previous traces [http4k-contract] [Unlikely Break] Remodelled how Security is rendered, so it's possible that this may break slightly for customer implementations [http4k-contract] Added support for Implicit OAuth flow, with suport for custom googleCloudEndpoints Security. H/T @rgladwell","title":"v3.173.0"},{"location":"changelog/#v31720","text":"[http4k-core] Added uni-directional serialization/deserialization options to JSON lib auto-conversion configuration.","title":"v3.172.0"},{"location":"changelog/#v31710","text":"[http4k-core] [Break (mitigation)] Replaced default resource loader location for singlePageApp() to /public instead of root - this is for safety of NOT serving the root of the classpath by default.","title":"v3.171.0"},{"location":"changelog/#v31700","text":"[http4k-core] Add a warning when static() is used with no package path, thus exposing the contents of the classpath remotely.","title":"v3.170.0"},{"location":"changelog/#v31690","text":"[all] Update various dependencies.","title":"v3.169.0"},{"location":"changelog/#v31680","text":"[http4k-contract] Collect LensFailure causes into a single place when validating.","title":"v3.168.0"},{"location":"changelog/#v31670","text":"[http4k-contract] [Possibly Break] Open out ErrorResponseRenderer interface to take LensFailure instead of the individual failures when rendering badResponse() . To fix, simply wrap the list of failures into a LensFailure.","title":"v3.167.0"},{"location":"changelog/#v31661","text":"[http4k-core] Tweak singlePageApp() routing handler, to correctly apply filters when fallback page is used.","title":"v3.166.1"},{"location":"changelog/#v31660","text":"[http4k-core] Added singlePageApp() routing handler, which matches both static content or falls back to the root path index file","title":"v3.166.0"},{"location":"changelog/#v31650","text":"[http4k-contract] Fix invalid OpenApi2 when root and base path match. H/T @rgladwell [http4k-contract] ContractRoute is now an HttpHandler , so no need to wrap contract routes in a contract {} to test them. H/T @rgladwell for the inspiration. [http4k-contract] Support Host/baseUri values in OpenApi2. H/T @rgladwell [http4k-contract] Optionally add description route to route list H/T @rgladwell","title":"v3.165.0"},{"location":"changelog/#v31640","text":"[all] Update various dependencies, including Kotlin to 1.3.41. [http4k-testing-approval] Upgrade of HTML library from above may have an effect on output of HTML approval tests. [http4k-contract] Support for more Jackson annotations in JSON Schema rendering. H/T @tom for the PR contributing this.","title":"v3.164.0"},{"location":"changelog/#v31630","text":"[http4k-testing-chaos] Add detail to Chaos OpenApi interface.","title":"v3.163.0"},{"location":"changelog/#v31620","text":"[http4k-testing-chaos] Add detail to Chaos OpenApi interface.","title":"v3.162.0"},{"location":"changelog/#v31610","text":"[http4k-cloudnative] Added Forbidden request exception to HandleUpstreamRequestFailed.","title":"v3.161.0"},{"location":"changelog/#v31601","text":"[http4k-testing-chaos] Countdown chaos trigger fixed.","title":"v3.160.1"},{"location":"changelog/#v31600","text":"[http4k-testing-chaos] Slight fix to avoid consuming stream body when setting chaos.","title":"v3.160.0"},{"location":"changelog/#v31590","text":"[all] Update various dependencies. [http4k-client-okhttp] Updated OkHttp to v4.0.0 (Kotlin edition). [http4k-contract] Tweak to JSON Schema rendering to handle recursive objects better.","title":"v3.159.0"},{"location":"changelog/#v31581","text":"[http4k-server-netty] Fix #260 - cannot set multiple response headers with same name [http4k-server-undertow] Fix #260 - cannot set multiple response headers with same name","title":"v3.158.1"},{"location":"changelog/#v31580","text":"[http4k-contract] POSSIBLE BEHAVIOUR CHANGE DUE TO BUG: Fix #259 - Contract blocks do not produce 400s if an external CatchAll is provided. This may have an effect on how errors are generated (a 400 is produced instead of the previous 500 from the CatchAll).","title":"v3.158.0"},{"location":"changelog/#v31571","text":"[http4k-security-oauth] Fix broken deprecation annotation.","title":"v3.157.1"},{"location":"changelog/#v31570","text":"[http4k-security-oauth] Default to JSON format response in Access Token response [http4k-security-oauth] Renamed a couple of classes (AccessTokenContainer -> AccessToken), and removed isValid method from AuthorizationCodes because it doesn't make sense for this to be on the OAuthServer.","title":"v3.157.0"},{"location":"changelog/#v31560","text":"[all] Update Kotlin to 1.3.40 [http4k-contract] Support OAuthSecurity renderer.","title":"v3.156.0"},{"location":"changelog/#v31552","text":"[all] Update various dependencies. [all] Dokka improvements. Does not mitigate #196 as we run the main build on OpenJdk11. H/T @ivoanjo","title":"v3.155.2"},{"location":"changelog/#v31551","text":"DO NOT USE - broken","title":"v3.155.1"},{"location":"changelog/#v31550","text":"DO NOT USE - broken","title":"v3.155.0"},{"location":"changelog/#v31541","text":"[http4k-multipart] Made the multipart header parser case-insensitive. H/T @tenniscp25","title":"v3.154.1"},{"location":"changelog/#v31540","text":"[http4k-contract] Add SchemaModelNamer to allow for custom JSON Schema model names.","title":"v3.154.0"},{"location":"changelog/#v31530","text":"[http4k-contract] OperationIds are generated without illegal characters {} .","title":"v3.153.0"},{"location":"changelog/#v31520","text":"[http4k-contract] Support non-string keys for \"text convertible\" values in maps for Auto-schema generation.","title":"v3.152.0"},{"location":"changelog/#v31510","text":"[http4k-contract] Fixed Auto-schema generation to detect and remove duplicate items from list schemas.","title":"v3.151.0"},{"location":"changelog/#v31500","text":"[http4k-security-oauth] Make authentication mechanism for grant types configurable.","title":"v3.150.0"},{"location":"changelog/#v31490","text":"[http4k-security-oauth] Initial support for client_credentials grant type.","title":"v3.149.0"},{"location":"changelog/#v31480","text":"[http4k-contract] Jackson property searching in OpenApi3 now searches superclasses.","title":"v3.148.0"},{"location":"changelog/#v31470","text":"[http4k-contract] Support custom JsonProperty annotation for OpenAPi3 generation [http4k-cloudnative] New exception type for unuathorised. H/T @tom","title":"v3.147.0"},{"location":"changelog/#v31460","text":"[http4k-contract] Fix #228 - Support Map-based fields in OpenApi 3 Auto-schema generation as additionalProperties . H/T @noahbetzen-wk for the idea.","title":"v3.146.0"},{"location":"changelog/#v31450","text":"[http4k-contract] Reimplement Auto-schema generation using reflection. Added test cases to use the OpenApi generator to create valid code-based OpenApi clients using the OpenApi generator. [http4k-format-jackson] Removed reflective JSON schema creator, since it was not actually OA3 compliant.","title":"v3.145.0"},{"location":"changelog/#v31440","text":"[all] Update various dependencies. [http4k-contract] Improvements to better adhere to OA3 spec. [http4k-security-oauth] Allow injecting OpenID's request parameter into the authorization request. [http4k-security-oauth] Expose request to AuthRequestTracking.","title":"v3.144.0"},{"location":"changelog/#v31431","text":"[http4k-core] Replace RequestContexts with reference to Store . H/T @amcghie [http4k-contract] Added some missing deprecations. [http4k-contract] Fix #243 - Nulls not allowed in OpenApi V3 JSON models.","title":"v3.143.1"},{"location":"changelog/#v31430","text":"[http4k-contract] Fix #239 - OpenApi v3 schemas for raw lists blow up when rendering. [all] Update various dependencies.","title":"v3.143.0"},{"location":"changelog/#v31420","text":"[http4k-contract] Both OpenApi v2 and v3 are now supported, including automatic schema generation. Some classes for OpenApi2 have moved to a new package - Deprecations should provide most alternatives. See module docs for details. For OpenApi v3, optionally include http4k-format-jackson to get JSON schema models based on JVM objects. [http4k-format-jackson] Added reflective JSON schema creator, to be used for generating named models from JVM objects.","title":"v3.142.0"},{"location":"changelog/#v31410","text":"[http4k-core] - Fix #233 - MemoryBody blows up with \"java.nio.ReadOnlyBufferException\" [http4k-core] - Tighten up security on Basic and Bearer auth server filters. H/T @andymoody [http4k-security-oauth] - Add filter to check bearer token is valid access token. H/T @andymoody","title":"v3.141.0"},{"location":"changelog/#v31400","text":"[all] Update dependencies (including Kotlin bump to 1.3.31) [http4k-security-oauth] Handle user rejecting/failing authentication. H/T @andymoody","title":"v3.140.0"},{"location":"changelog/#v31390","text":"[http4k-security-oauth] Allow access token generation to explicitly reject an authorization code already used. H/T @andymoody","title":"v3.139.0"},{"location":"changelog/#v31381","text":"[http4k-security-oauth] Amend error responses from access token generation. H/T @andymoody","title":"v3.138.1"},{"location":"changelog/#v31380","text":"[http4k-contracts] Tweaks to Security model for http4k-contracts . (Renamed) ApiKeySecurity is now a proper class, and added BasicAuthSecurity . You can now also override the security model on a per-route basis. [http4k-contract] Added ability to set the Security on each individual contract route. This overrides any Security set on a contract-level basis.","title":"v3.138.0"},{"location":"changelog/#v31371","text":"[http4k-serverless] Allow invocation of serverless functions locally. H/T @Charlyzzz [http4k-core] Fix #226 - ResourceLoadingHandler not close stream","title":"v3.137.1"},{"location":"changelog/#v31370","text":"[http4k-security-oauth] Rename AuthRequestPersistence to AuthRequestTracking","title":"v3.137.0"},{"location":"changelog/#v31360","text":"[http4k-security-oauth] Allow the http request to be referenced when generating OAuth authorization codes. H/T @andymoody","title":"v3.136.0"},{"location":"changelog/#v31350","text":"[http4k-core] Change mime.types location so it doesn't conflic with other libraries. H/T @benusher and @dgliosca [http4k-testing-chaos] Added SnipRequestBody behaviour. [http4k-core] (Small) Breaking Fixed location of some extension files to be relevant to the particular package that they are referencing. This will require reimporting the new location into your source if you were using the imports.","title":"v3.135.0"},{"location":"changelog/#v31340","text":"[http4k-testing-approval] Made content-type aware approval tests check the content type after the content. This is friendlier for failing tests, as it is more important that the content is correct than the content-type (and often errors don't have content type set so you get an erroneous error message which masks the fact that the content was wrong).","title":"v3.134.0"},{"location":"changelog/#v31330","text":"[http4k-cloudnative] HandleUpstreamRequestFailed client filter now takes a predicate (Response) -> Boolean instead of a boolean. This allows for more fine grained custom control of which Responses are acceptable. [all] Upgrade deps, including Kotlin to 1.3.30 . [http4k-contract] Fix #221 - Contract path fixed segments cannot contain slash characters.","title":"v3.133.0"},{"location":"changelog/#v31320","text":"[http4k-format-jackson] Convert Jackson to use readValue instead of convertValue . This fixes some problems with type conversions.","title":"v3.132.0"},{"location":"changelog/#v31310","text":"[http4k-core] (Possible) Break: Made lense implementations Query, Header etc clear previous values by default instead of appending. This leads to a more consistent behaviour. In order to be able to set multiple values on an object using a lense, use the multi form instead - eg. Header.required(\"foo\") -> Header.multi.required(\"foo\") . We envisage the impact of this change is limited as it's only Queries that generally can have multiple possible values, and in the vast majority of cases a replace rather than append is expected.","title":"v3.131.0"},{"location":"changelog/#v31300","text":"[http4k-contract] Generify contract handling code to allow for custom HttpMessageMeta<XYZ>","title":"v3.130.0"},{"location":"changelog/#v31290","text":"(Slight) Break: Collapsed UpstreamRequestFailed exceptions to contain the status, and thus removing non-special cases like BadRequest and BadGateway . This makes them much easier to use in practice as users have access to the the status. To migrate, simply replace previous classes with UpstreamRequestFailed(Status.XYZ, message) . [http4k-contract] Open up ContractRoute API to facilitate extension when defining a custom ContractRenderer . [all] Upgrade deps.","title":"v3.129.0"},{"location":"changelog/#v31280","text":"[http4k-core] Added base64 to the supported mappings for Query/Headers etc... [http4k-testing-approval] Approver does not write actual output if there is none to write and there is no approved content","title":"v3.128.0"},{"location":"changelog/#v31270","text":"[http4k-testing-approval] Improved Approver interface to more closely match the traditional assert<XYZ> approach - this results in a more discoverable/obvious API. [http4k-testing-hamkrest] Added ability to create a Hamkrest matcher directly from the Approver instance to be combined with other relevant matchers.","title":"v3.127.0"},{"location":"changelog/#v31260","text":"[http4k-testing-approval] Add support for XML and HTML approval tests.","title":"v3.126.0"},{"location":"changelog/#v31250","text":"Added http4k-testing-approval module, which is compatible with JUnit5 tests and integrates with the OkeyDoke approval testing files and IntelliJ plugin. H/T to @jshiell for the inspiration Gist containing the base Junit5 Extension.","title":"v3.125.0"},{"location":"changelog/#v31240","text":"[http4k-security-oauth] Make authentication response available when creating AuthorizationCode.","title":"v3.124.0"},{"location":"changelog/#v31230","text":"[http4k-security-oauth] Introduce OAuthServer to http4k-security-oauth to assist in the creation of authorization servers.","title":"v3.123.0"},{"location":"changelog/#v31220","text":"Generified GenerateXmlDataClasses filter, and added default implementations for http4k-format-jackson-xml and http4k-format-xml modules. (Rename) Break: GenerateXmlDataClasses filter in http4k-format-xml is now GsonGenerateXmlDataClasses Removed superfluous CatchLensFailure filter from http4k-contracts module. This is not required as lens failures are already handled by the main contract handler.","title":"v3.122.0"},{"location":"changelog/#v31210","text":"Moved Jackson XML support to new module http4k-format-jackson-xml . Note that this is for auto-marshalling of data-classes only and does not expose an XML DOM model.","title":"v3.121.0"},{"location":"changelog/#v31200","text":"Deprecated Body.view() lens construction in favour of a Body.viewModel() call which removes the implicitly called toLens() . This allows further mapping from one ViewModel type to another, and brings the view lens construction into line with the rest of the extension functions on Body . Add auto-marshalling XML support to http4k-format-jackson module. Upgrade deps.","title":"v3.120.0"},{"location":"changelog/#v31190","text":"Add UpstreamRequestFailed exceptions and HandleUpstreamRequestFailed filters to http4k-cloudnative . These allow apps to neatly deal with upstream failure in a sensible way.","title":"v3.119.0"},{"location":"changelog/#v31180","text":"Tweak contract() DSL to add remaining options for configuration.","title":"v3.118.0"},{"location":"changelog/#v31170","text":"Renamed ChaosControls (deprecated) to ChaosEngine .","title":"v3.117.0"},{"location":"changelog/#v31160","text":"Added new templating module http4k-templates-freemarker . H/T @amcghie for the PR implementing this http4k-contract has a new DSL for construction of the contract which replaces the old one (now deprecated). This is consistent with the meta DSL used to construct individual contract routes and avoids repetition of the old API. We attempted to implement the standard replace-with deprecation, but IntelliJ didn't like it (too complex maybe), so we've hard coded the warning instead which code which should work. Added PreFlightExtraction to contract module, which adds the ability to disable body-checking for contract routes. This will allow refining of routes or entire contracts to be more efficient. Upgrade deps.","title":"v3.116.0"},{"location":"changelog/#v31151","text":"Fix #217 - Cannot override the definitionId of a top-level array in OpenAPI Upgrade deps","title":"v3.115.1"},{"location":"changelog/#v31150","text":"Chaos now do not blat x-uri-template when used with a RoutingHttpHandler Simplified usage of Once chaos trigger. (Slight break) Consistentified (!) construction of Chaos Behaviours, Stages and Triggers. Replaced singletons with function calls. Eg. Always -> Always()","title":"v3.115.0"},{"location":"changelog/#v31140","text":"(Possible Break): Fix #215 - LensFailure does not always include target object. Only change to the API is that IN generic in Lenses is now bounded by IN : Any . This fix is a actually internally consistent as we could not always include the target otherwise (which is an Any? ). Trim leading and trailing whitespace from extracted EnvironmentKey values. Secret value is now only usable once via the use() function. Upgrade to various deps. Removed deprecations.","title":"v3.114.0"},{"location":"changelog/#v31130","text":"Added some common types for Environmental setup, and equivalent BiDiLens mappings Handle null response in Java Http client. H/T @FredNordin","title":"v3.113.0"},{"location":"changelog/#v31122","text":"Fix #212 - allow null values in HTTP contract definitions. This does mean we lose the type definition for that field, but we don't blow up silently (which was the previous behaviour). H/T @xhanin","title":"v3.112.2"},{"location":"changelog/#v31121","text":"Re-add Path.nonEmptyString() which was accidentally removed.","title":"v3.112.1"},{"location":"changelog/#v31120","text":"Add support for prohibiting String unmarshalling in JSON auto-marshalling configuration. HTTP Contracts now use the underlying ContractRenderer to produce the BadRequest and NotFound responses. Made OpenAPI open so that these responses can be customised.","title":"v3.112.0"},{"location":"changelog/#v31110","text":"Add support for JSON views in Jackson module. H/T @xhanin for the donkey work.","title":"v3.111.0"},{"location":"changelog/#v31100","text":"Breaking: slight rearrangement of RouteMeta receiving/returning methods to provide consistency when defining route contracts.","title":"v3.110.0"},{"location":"changelog/#v31090","text":"Moved the set of predefined String BiDiMapping instances to their own class. Bulked out the auto-mapping configuration options.","title":"v3.109.0"},{"location":"changelog/#v31080","text":"Upgrade to various deps. Extracted out new BiDiMapping type, which encapsulates string <-> type conversions and removes a boatload of duplications. These conversions are now used consistently across all the various places (Lenses, auto-mapping). Improved configurability of AutoMarshallingJson instances.","title":"v3.108.0"},{"location":"changelog/#v31070","text":"Upgrade to various deps. Fix #208 - Xml auto deserialisation incorrectly converting strings to numbers","title":"v3.107.0"},{"location":"changelog/#v31061","text":"Fix #207 - repeating prefixes in static routes are not handled correctly. H/T @ruXlab for the PR to fix.","title":"v3.106.1"},{"location":"changelog/#v31060","text":"Add http4k-server-ktorcio server backend. Note that whilst this module does allow http4k apps to plug into the Ktor-CIO engine, it does not provide fully front-to-back coroutine support.","title":"v3.106.0"},{"location":"changelog/#v31050","text":"Preventing FallbackCacheControl from duplicating existing headers. H/T @leandronunes85 Breaking: Make Body.length nullable instead of throwing exception when value is not available. H/T @zvozin","title":"v3.105.0"},{"location":"changelog/#v31040","text":"Upgrade to various deps. Add session token support to AWS filter, and \"credentials provider\" to allow for rotating AWS sessions. H/T @dhobbs. Breaking: Moved WsClient from org.http4k.testing to org.http4k.websocket .","title":"v3.104.0"},{"location":"changelog/#v31032","text":"Fix access-control-allow-origin returned when server supports multiple origins H/T @johnnorris","title":"v3.103.2"},{"location":"changelog/#v31031","text":"(Properly) Fix #198 - Rewrote OpenApi contract to ensure it stays fixed. H/T @reik-wargaming for the help in tracking this down.","title":"v3.103.1"},{"location":"changelog/#v31030","text":"\"Fix\" #198 - Breaking change made in http4k-contracts to clarify/deconfuse API. Hid body parameter in contract route meta DSL - it is now receiving() . Upgraded some dependencies, including Gradle to v5.0. Breaking: Resilience4j dependency upgrade causes a break when providing custom config. Simply insert the Config type generic to fix: e.g. RetryConfig.custom() -> RetryConfig.custom<RetryConfig>()","title":"v3.103.0"},{"location":"changelog/#v31021","text":"Fix #197 - Swagger spec for form fields had incorrect description.","title":"v3.102.1"},{"location":"changelog/#v31020","text":"Introduce interface for Environment","title":"v3.102.0"},{"location":"changelog/#v31010","text":"Upgrades to dependencies Improved Client-side HTTP status descriptions Lenses now support Durations out of the box Environments now support multi-value keys (comma separated)","title":"v3.101.0"},{"location":"changelog/#v31000","text":"Make Undertow API friendlier Fix to JsonReadinessCheckResultRenderer to actually implement the correct interface","title":"v3.100.0"},{"location":"changelog/#v3990","text":"Enhancement of http4k-cloudnative - now supports extra-health check routes, and provide way to load app configuration via Properties files.","title":"v3.99.0"},{"location":"changelog/#v3980","text":"Add filter allowing Gzipping based on an allowed set of content types. H/T @jshiell Change HttpHandler extending HttpClients to use object invoke() mechanism, as the individual clients have no visible API surface of their own. Introduced DualSyncAsyncHttpHandler interface.","title":"v3.98.0"},{"location":"changelog/#v3970","text":"Webdriver checkbox handling improved. H/T @gypsydave5 upgrade to various versions","title":"v3.97.0"},{"location":"changelog/#v3960","text":"upgrade to Kotlin 1.3.0","title":"v3.96.0"},{"location":"changelog/#v3951","text":"Tweak to K8S port variables.","title":"v3.95.1"},{"location":"changelog/#v3950","text":"(Unlikely break): Change Http4kServer interface to return Unit from stop() . This affects all server implementations. Added DSL function for working with JSON objects (scopes JSON as this ). fun <T> Json<NODE>.invoke(Json<NODE>.() -> T) New module http4k-cloudnative contains classes to help run http4k services inside cloud-native environments, including K8S. Upgrade some dependencies Deprecation: Moved Header.Common fields to main Header object. Extension properties should go there now.","title":"v3.95.0"},{"location":"changelog/#v3941","text":"Use UTC when checking cookie expiry","title":"v3.94.1"},{"location":"changelog/#v3940","text":"Deprecate String.toBody() Fix checkbox behaviour in webdriver","title":"v3.94.0"},{"location":"changelog/#v3394-v3934","text":"Use Jetty latest release version (rather than RC one)","title":"~v3.39.4~ v3.93.4"},{"location":"changelog/#v3393","text":"Fix #189 - Uri toString now omits leading slash if the authority of a Uri is blank. This could be a potential break, but is actually more consistent as a Uri can currently be relative or absolute.","title":"v3.39.3"},{"location":"changelog/#v3392","text":"Extend SetBaseUriFrom to support query parameters","title":"v3.39.2"},{"location":"changelog/#v3391","text":"Added SetBaseUriFrom filter","title":"v3.39.1"},{"location":"changelog/#v3390","text":"(Possible breaking change): Json is now only generified by a single type parameter instead of 2. For most usages, this type would have been identical anyway, but the upgrade of Argo has finally allowed the removal of this dead generic. Simply replace Json<Node, Node> with Json<Node> . Added Offset datetime types to all JSON auto-marshalling libraries Build logic for versioning is now in Kotlin. H/T @jmfayard for the PR Upgrade Kotlin, and various other dependencies","title":"v3.39.0"},{"location":"changelog/#v3381","text":"Fix withChaosControls URL pattern so that it matches sub-routes ok on original handler","title":"v3.38.1"},{"location":"changelog/#v3380","text":"Added BearerAuth and BasicAuth implementations which populate RequestContexts . Plus cookbook example :)","title":"v3.38.0"},{"location":"changelog/#v3371","text":"Fix #177 - Make RequestContexts thread-safe.","title":"v3.37.1"},{"location":"changelog/#v3370","text":"Upgrades to http4k-testing-webdriver . H/T @dickon for the PRs Added ProxyHost request filter which is useful for writing proxy-type apps.","title":"v3.37.0"},{"location":"changelog/#v3361","text":"Fix #168 - Fix rest of hamkrest matchers caused by generics mishap. Upgrade HTTP client dependency versions.","title":"v3.36.1"},{"location":"changelog/#v3360","text":"Added http4k-testing-chaos module, designed to enhance failure-mode testing for http4k apps. Massive H/T to @IgorPerikov for the PR which drove this module's creation. Added http4k-incubator module, for hosting developing projects and other code which might be promoted to top-level modules in the future.","title":"v3.36.0"},{"location":"changelog/#v3352","text":"Fix #167 - Reintroduce hasBody compatibility with common matchers such as containsString() Remove deprecations.","title":"v3.35.2"},{"location":"changelog/#v3351","text":"Fix #165 - AWS auth filter does not replace headers - it sets them (which breaks for request signing) Fix #164 - Webdriver internal state breaks when navigating to a full URL Fix #162 - SetHostFrom doesn't set 'Host' header correctly (missing port). H/T @elifarley","title":"v3.35.1"},{"location":"changelog/#v3350","text":"Added some regex matchers to http4k-testing-hamkrest . Added BearerAuth authentication Server and Client Filters - these work similarly to BasicAuth . Added option for defaulted() lenses to fall back to another supplied lens in the case of missing value. Thanks to @dmcg for the inspiration. :)","title":"v3.35.0"},{"location":"changelog/#v3343","text":"Fix #160 - JavaHttpClient does not copy body stream correctly onto URL connection.","title":"v3.34.3"},{"location":"changelog/#v3342","text":"Fix #159 - Contracts should not have Security applied to the description route by default.","title":"v3.34.2"},{"location":"changelog/#v3341","text":"Fix #158 - Static and contract routes filters are applied in the wrong order.","title":"v3.34.1"},{"location":"changelog/#v3340","text":"Add default SamplingDecision param to ZipkinTraces - defaults to always sample. Fix #150 - StaticRoutingHandler filters being called twice. Fix #151 - POTENTIAL BREAK: Rework of Status objects to fix equality against the Status constant vals when a description has been overridden. This involves the following potential breaking change: The Status class is no longer a data class to tighten up encapsulation - user calls to copy() will have to be replaced.","title":"v3.34.0"},{"location":"changelog/#v3332","text":"Raise SO_BACKLOG in Apache and Netty server implementations. Add PERMANENT_REDIRECT and UNPROCESSABLE_ENTITY Status object.","title":"v3.33.2"},{"location":"changelog/#v3331","text":"No change from 3.33.0. Previous version couldn't be made available to maven central.","title":"v3.33.1"},{"location":"changelog/#v3330","text":"Add convenient way to extract from as a Map from http message. H/T to @dmcg (this version is available in jcenter only)","title":"v3.33.0"},{"location":"changelog/#v3321","text":"Fix #142 - Pebble templates don't load from JAR files.","title":"v3.32.1"},{"location":"changelog/#v3320","text":"Add support for propagation of the Zipkin x-b3-sampled header","title":"v3.32.0"},{"location":"changelog/#v3310","text":"Changes to the Netty factory to enable running http4k on GraalVM. H/T @RichyHBM","title":"v3.31.0"},{"location":"changelog/#v3300","text":"Allow all server implementations to start on port 0 (ie. find a free port) and then report it back as a part of the Http4kServer interface","title":"v3.30.0"},{"location":"changelog/#v3290","text":"Make HTTP clients resilient to unknown host and connection refused exceptions Implemented #134 - Added default (de)serialization for common JDK primitives to all Auto-marshalling JSON modules - eg. date times and UUIDs","title":"v3.29.0"},{"location":"changelog/#v3280","text":"Fix #131 - Uri's created with paths that don't contain leading slashes. Added etag parser filter. H/T @dgliosca for the PR Fix #132 - Ensured that disableDefaultTyping is called in default Jackson implementation. This should be the default anyway, but has been added to ensure that we don't fall foul of CVE-2017-7525 and to surface awareness of this issue.","title":"v3.28.0"},{"location":"changelog/#v3270","text":"OpenAPI now provides example values in the generated schema. H/T @skewwhiffy for the PR.","title":"v3.27.0"},{"location":"changelog/#v3266","text":"Fix #126 - ResourceLoadingHandler can expose mapped resources into the root. <-- We think this is an important update, so please upgrade!","title":"v3.26.6"},{"location":"changelog/#v3265","text":"Fix #125 - ApacheServer implementation now sets content length if present.","title":"v3.26.5"},{"location":"changelog/#v3264","text":"Fix #123 - Multipart Body objects blow up when parsed after being debugged. As with all streams, care should be taken to not blow heap when internalising them for debugging purposes.","title":"v3.26.4"},{"location":"changelog/#v3263","text":"Debugging filter now supports ignoring Multipart streams.","title":"v3.26.3"},{"location":"changelog/#v3262","text":"Tweak: OpenAPI now doesn't return null values in the schema.","title":"v3.26.2"},{"location":"changelog/#v3261","text":"Fix #124 - headers in WebSocket upgrade request are incorrectly joined.","title":"v3.26.1"},{"location":"changelog/#v3260","text":"Removed supportedContentTypes field from OpenApi contract JSON, since this is a legacy field.","title":"v3.26.0"},{"location":"changelog/#v3250","text":"Added option to Undertow to enable HTTP2 from main ServerConfig","title":"v3.25.0"},{"location":"changelog/#v3240","text":"Upgrade various dependencies for Java 10 compatibility. H/T @tom Fix bug with repeated params in Websocket upgrade request. H/T @tom","title":"v3.24.0"},{"location":"changelog/#v3231","text":"Composite LensFailures now capture (at least) the first failing cause (probably the body parameter in the case of an http4k-contract module.","title":"v3.23.1"},{"location":"changelog/#v3230","text":"Fix #116 - Can provide a custom Response creation method for CatchLensFailure . H/T @elifarley for the inspiration!","title":"v3.23.0"},{"location":"changelog/#v3224","text":"Added singleton method for Json.array, since if you pass in a single JsonNode (Jackson), it accidentally iterates over the fields in the node instead of using the object as an entry in the array. Fix #115 - Only add content-length for methods that allow content in AwsAuth filter","title":"v3.22.4"},{"location":"changelog/#v3223","text":"Preserve routing information on request/response manipulation","title":"v3.22.3"},{"location":"changelog/#v3222","text":"http4k-security-oauth module added - with support for OAuth2 Authorization Grant flow Replaced classes reliant on javax.activation package, which allows Java 9+ to not require any external dependencies. \\o/ Fix #112 - ApacheClient incorrectly sets headers on GET requests (this breaks F5 load balancers). H/T @simojenki PR #110 - Websocket client timeouts are incorrectly translated as seconds instead of millis. HT @anorth Core JavaHttpClient does not support streaming due to limitations with HttpURLConnection","title":"v3.22.2"},{"location":"changelog/#v3211","text":"Fix #109 - Jackson treats integer values inconsistently, leading to matching errors when using hamkrest.","title":"v3.21.1"},{"location":"changelog/#v3210","text":"Fix #107 - Killed the x-uri-template header and fixed the ReportHttpTransaction to have access to the routingGroup . Altered ordering of filters in http4k-contract so that the route is identified before pre-filters and security are applied. This allows knowledge of the path to be accessible at the time of application of those filters.","title":"v3.21.0"},{"location":"changelog/#v3200","text":"Introduce JavaHttpClient to http4k-core . It provides a very basic http client without any other 3rd party dependencies.","title":"v3.20.0"},{"location":"changelog/#v3190","text":"PR #104 - Add optional time/date formatters to LensSpecs so you can choose you serialisation format. H/T @elifarley Fix #105 - Swagger API json file: duplicate key in \"definitions\".","title":"v3.19.0"},{"location":"changelog/#v3181","text":"Fixed PR #100 - URI template regex required extra escaping. This only affects Android deployments as IDE shows the regex escaping is redundant. H/T @privatwolke","title":"v3.18.1"},{"location":"changelog/#v3180","text":"Breaking: converted contract pre-security filter to be a post-security filter. This means that all standard filters are applied before the security later, which allows for logging and monitoring and context setup. The previous filter mechanic applied security first, which didn't allow for this. In the unlikely event that post-security filters still need to be applied, use the withPostSecurityFilter() function when building the contract. Docs for contract RouteMeta function parameters, and deprecated some unused functions (missed when we introduced the DSL). PR #99 - Contract routes now support up to 10 path segments. Thanks to @scap1784 for the PR! :)","title":"v3.18.0"},{"location":"changelog/#v3171","text":"Fix #97. Moshi does not fail when deserialise non-nullable fields correctly. Note that GSON still suffers from this problem","title":"v3.17.1"},{"location":"changelog/#v3170","text":"Added a pre-security filter option to contract creation, so that you can explicitly specify behaviour to occur before security kicks in.","title":"v3.17.0"},{"location":"changelog/#v3160","text":"Convert Security (from sealed class) and ApiKey to be interfaces. This allows users to implement their own security models.","title":"v3.16.0"},{"location":"changelog/#v3150","text":"Introduce HttpTransaction and new ReportHttpTransaction filter provide better generic API for reporting, along with the ability to label transactions for this purpose. Breaking: Rework the metrics request counter and timer Filter API. There is now a HttpTransactionLabeller for you to add as many labels as required to the transaction. Each of these labels will be used to tag the metric.","title":"v3.15.0"},{"location":"changelog/#v3141","text":"Fix #95 - Filters are now applied to \"route not found\" responses","title":"v3.14.1"},{"location":"changelog/#v3140","text":"Fix #93 - Apache server doesn't like content-length or transfer-encoding headers present in http4k response. Add ability to \"name\" input and output contract body definitions in an OpenAPI JSON doc. This applies to only the top level entity. If no override is passed, the objects are named according to their hashcode.","title":"v3.14.0"},{"location":"changelog/#3134","text":"Fix #92 - cookie date should always use US locale","title":"3.13.4"},{"location":"changelog/#v3133","text":"Further tweak to Netty. H/T @FredDeschenes","title":"v3.13.3"},{"location":"changelog/#v3132","text":"Fix #91 - large message handli ng in Netty","title":"v3.13.2"},{"location":"changelog/#v3131","text":"Upgrade to Kotlin 1.2.20","title":"v3.13.1"},{"location":"changelog/#v3130","text":"Support for operationId in OpenApi route metadata. H/T @danschultz for the PR. Removed previously deprecated methods.","title":"v3.13.0"},{"location":"changelog/#v3120","text":"New client module http4k-client-jetty , which supports both sync and async models.","title":"v3.12.0"},{"location":"changelog/#v3111","text":"Fix #84. OPTIONS requests are not detected by contract routes. Added option to NOT authorise OPTIONS requests in ApiKey security filter. Added support for Async HTTP clients and added new AsyncHttpClient interface, which is obviously used for HTTP clients only**, and not server-side calls. :) New client module http4k-client-apache-async . New metrics gathering module http4k-metrics-micrometer . Big H/T to @kirderf for the PR. Added support for async to OkHttp client module.","title":"v3.11.1"},{"location":"changelog/#v3100","text":"P/R 81 - adding headers and timeout to websocket client.","title":"v3.10.0"},{"location":"changelog/#v390","text":"Added compactify and prettify to Json implementations Added Json.hasBody Hamkrest matchers for comparing bodies. Note these are extension methods and need to be referenced/imported as such.","title":"v3.9.0"},{"location":"changelog/#v380","text":"Added facility for non-blocking websocket client to react to onConnect event. This API is the same as the inbound, server-side API - ie. there are no explicit connection event handlers. H/T @tom for the idea.","title":"v3.8.0"},{"location":"changelog/#v370","text":"P/R #13 Create extension methods for Response to add caching headers. H/T @k0zakinio.","title":"v3.7.0"},{"location":"changelog/#v361","text":"Fix #78. Serialisation of raw lists using Moshi fails in the same way as the Jackson auto-conversions do. Added convenience methods to get around this.","title":"v3.6.1"},{"location":"changelog/#v360","text":"Added http4k-format-moshi to support the Square auto-marshalling library.","title":"v3.6.0"},{"location":"changelog/#v351","text":"Fix #76 - encoding of path segments to use URI encoding instead of URL form encoding.","title":"v3.5.1"},{"location":"changelog/#v350","text":"Added support for multiple HotReload template directories in HandlebarsTemplates . H/T @TomShacham Fix #74 - Request tracing span/parentSpan set too early so was shared between outgoing requests.","title":"v3.5.0"},{"location":"changelog/#v340","text":"New server backend http4k-server-apache . H/T @kirderf for the PR :) We now set the length of the incoming request body when it is available in the incoming request.","title":"v3.4.0"},{"location":"changelog/#v331","text":"Handlebars now uses combination of Class and Template name to cache templates.","title":"v3.3.1"},{"location":"changelog/#v330","text":"Facility to compose TemplateRenderers with then() to provide fallback behaviour.","title":"v3.3.0"},{"location":"changelog/#v323","text":"PR #70: Header order equality for Request/Response - H/T @gypsydave5.","title":"v3.2.3"},{"location":"changelog/#v322","text":"Switched out Status for WsStatus (with proper RFC code set) in Websockets.","title":"v3.2.2"},{"location":"changelog/#v321","text":"Typesafe Websockets! Jetty now supports websockets, using the same style of API in the main http4k routing. (Possible) Breaking change: Because WsHandler (typealias) implements the same inbound interface as HttpHandler , you now cannot declare HttpHandlers without specifying the input type, so any \"anonymous\" handlers will not compile as a result. The required fix is very simple, but manual: `{ Response(OK) } should become { _:Request -> Response(OK) }","title":"v3.2.1"},{"location":"changelog/#v313","text":"Fix Request.form() for streaming requests","title":"v3.1.3"},{"location":"changelog/#v312","text":"Remove possibility of empty message for Path Lens failure.","title":"v3.1.2"},{"location":"changelog/#v311","text":"New (better!) API for http4k-contract module. Old meta DSL has been deprecated.","title":"v3.1.1"},{"location":"changelog/#v301","text":"Fix #63 - Apache Client Connect. timeout exception handling.","title":"v3.0.1"},{"location":"changelog/#v300","text":"Added http4k-serverless-lambda module, allowing http4k applications to be deployed into AWS Lambda and then called from API Gateway. Effectively, the combination of these two services become just another Server back-end supported by the library. \\o/","title":"v3.0.0"},{"location":"changelog/#v2381","text":"RequestContextKey now follow the standardised Lens structure of required, optional, defaulted, and can now be removed (set to null). Replace calls to RequestContextKey.of() with RequestContextKey.required() Removed previously deprecated values. See below for details on replacements.","title":"v2.38.1"},{"location":"changelog/#v2370","text":"Added http4k-resilience4j module, which adds Circuits, RateLimiters, Retrying and Bulkheading. Fix #60 (H/T @michaelhixson for the spot).","title":"v2.37.0"},{"location":"changelog/#v2360","text":"Added a couple of useful ServerFilters . Upgrade various dependency versions. Tidying of Multipart code.","title":"v2.36.0"},{"location":"changelog/#v2351","text":"Fix #57. Static handlers behave oddly when combined with an HTTP verb in the routing tree.","title":"v2.35.1"},{"location":"changelog/#v2350","text":"Fix #56. Altered behaviour of CatchLensFailure to NOT catch errors from unmarshalling Response objects. This was causing BAD_REQUEST to be incorrectly generated. Simplification of generics around LensSpecs. This should not be a breaking change, (there were 3 generics, now the MID has been removed so there are just 2) but could break if signatures are used explicitly.","title":"v2.35.0"},{"location":"changelog/#v2340","text":"Reordered generics in LensInjector to make sense. This should have no effect on most code-bases, but could break if signatures are used explicitly. Just flip the generic types to switch.","title":"v2.34.0"},{"location":"changelog/#v2331","text":"Added support for unsigned AWS requests, which enables streaming content to S3.","title":"v2.33.1"},{"location":"changelog/#v2330","text":"Added BodyMode.Request to configure streaming for clients. ResponseBodyMode is now BodyMode.Response (Breaking change. Fixable with simple find/replace).","title":"v2.33.0"},{"location":"changelog/#v2320","text":"Added ServerFilter.ProcessFiles filter to stream Multipart Files, convert them into references and replace inline in the Form.","title":"v2.32.0"},{"location":"changelog/#v2314","text":"Avoid realising StreamBody unless necessary, which could break common usages of streaming.","title":"v2.31.4"},{"location":"changelog/#v2313","text":"Tweaks to Server backends to improve efficiency.","title":"v2.31.3"},{"location":"changelog/#v2312","text":"Webdriver will keep only the final URI after redirects.","title":"v2.31.2"},{"location":"changelog/#v2311","text":"Increased granularity of Replay.DiskStream and ensure that traffic is returned in exact order on all OSes. Add support for redirects to Webdriver.","title":"v2.31.1"},{"location":"changelog/#v2310","text":"Multipart module tweaked to provide a more consistent API. Fix FollowRedirects for POST/PUT request.","title":"v2.31.0"},{"location":"changelog/#v2300","text":"Multipart form support through new module http4k-multipart . Deprecation: Replaced Swagger with OpenApi and deprecated the former (via typealias). Deprecation: Replaced FormValidator with Validator and deprecated the former (via typealias).","title":"v2.30.0"},{"location":"changelog/#v2294","text":"Refactor release.","title":"v2.29.4"},{"location":"changelog/#v2293","text":"Fix #50 - Webdriver does not normalise relative links correctly.","title":"v2.29.3"},{"location":"changelog/#v2292","text":"Http client modules now catch and convert Socket Timeout exceptions to HTTP 504s (with a custom message)","title":"v2.29.2"},{"location":"changelog/#v2291","text":"Tweaks to how recorded traffic is stored on disk. Thanks to @dkandalov for the PR around this.","title":"v2.29.1"},{"location":"changelog/#v2290","text":"Added TrafficFilters for recording and replaying HTTP traffic. See org.http4k.traffic package for details.","title":"v2.29.0"},{"location":"changelog/#v2280","text":"Added http4k-template-dust for Dust template engine support. Thanks to @npryce for the PR to add this.","title":"v2.28.0"},{"location":"changelog/#v2272","text":"Fix #44 - Use quotes around cookie values","title":"v2.27.2"},{"location":"changelog/#v2271","text":"Raise proper Exception (instead of LensFailure) when RequestContexts are not set up correctly, so we don't accidentally classify developer errors as BadRequests","title":"v2.27.1"},{"location":"changelog/#v2270","text":"Added facility to assign values into a RequestContext which is passed down the Filter chain.","title":"v2.27.0"},{"location":"changelog/#v2263","text":"Fix #44 - Request cookies should not be wrapped in quotes.","title":"v2.26.3"},{"location":"changelog/#v2262","text":"Fix #43 - AWS does not sign binary requests correctly.","title":"v2.26.2"},{"location":"changelog/#v2261","text":"Fix #41 - Sending binary body alters the size of the payload.","title":"v2.26.1"},{"location":"changelog/#v2260","text":"Added \"catch all\" routing option, which matches all methods to a handler.","title":"v2.26.0"},{"location":"changelog/#v2254","text":"Fix #40 - GZip filters now use content-encoding headers instead of transfer-encoding.","title":"v2.25.4"},{"location":"changelog/#v2253","text":"Fix #39 - ResponseBodyMode.Memory properly closes streams (breaks jetty + gzip).","title":"v2.25.3"},{"location":"changelog/#v2252","text":"Ensure that streams are closed properly when consuming from an upstream client.","title":"v2.25.2"},{"location":"changelog/#v2251","text":"Remove Apache client request streaming because it may not release connections properly.","title":"v2.25.1"},{"location":"changelog/#v2250","text":"Add streaming support to HTTP Server and Client modules. Remove CatchLensFailure ClientFilter as it will never be used.","title":"v2.25.0"},{"location":"changelog/#v2240","text":"Added CatchLensFailure for ClientFilters - which catches un-deserializable invalid responses from clients and generates a BAD_GATEWAY error.","title":"v2.24.0"},{"location":"changelog/#v2234","text":"Switch XML generation to Gson over Jackson because Jackson doesn't handle uppercase field names well. Switch native XML parsed type to Document over Node.","title":"v2.23.4"},{"location":"changelog/#v2233","text":"New algorithm for XML data class deserialisation, so un-deprecated XML methods.","title":"v2.23.3"},{"location":"changelog/#v2232","text":"Deprecated methods in XML support due to limitation with underlying Jackson implementation.","title":"v2.23.2"},{"location":"changelog/#v2231","text":"Fixed bug with GenerateXmlDataClasses filter","title":"v2.23.1"},{"location":"changelog/#v2230","text":"Renamed http4k-format-jackson-xml module to http4k-format-xml . Improved XML unmarshalling support.","title":"v2.23.0"},{"location":"changelog/#v2221","text":"Fixed 36: Form entry is too strict with content encoding.","title":"v2.22.1"},{"location":"changelog/#v2220","text":"Added http4k-format-jackson-xml module, with XML parsing support. Upgrade several dependencies","title":"v2.22.0"},{"location":"changelog/#v2212","text":"Fixed Hamkrest matchers to be on HttpMessage and not Http Request.","title":"v2.21.2"},{"location":"changelog/#v2211","text":"Default body Content Negotiation strategy changed to None","title":"v2.21.1"},{"location":"changelog/#v2210","text":"Converted Content-Negotiation strategy from an Enum to an interface, so that users can define their own strategies. We also now check encoding so there are 4-built in strategies to choose from: Strict, StrictNoDirective, NonStrict and None.","title":"v2.21.0"},{"location":"changelog/#v2201","text":"Fixed #31 - Matching of segments in URIs is done after URLs are decoded, which results in not capturing encoded slashes in the path segments.","title":"v2.20.1"},{"location":"changelog/#v2200","text":"Fixed #30 - CachingClasspath template ResourceLoader not working with non-root packages.","title":"v2.20.0"},{"location":"changelog/#v2190","text":"Fixed #29 - webdriver submission of text area. Http clients now use a new instance of the default for each instantiation. Previously there was a shared instance. Add regex body type for parsing values out of bodies, and \"None\" option for content negotiation.","title":"v2.19.0"},{"location":"changelog/#v2183","text":"Fix AWS request signing for requests containing empty path","title":"v2.18.3"},{"location":"changelog/#v2182","text":"Fix AWS request signing for requests containing path with special characters","title":"v2.18.2"},{"location":"changelog/#v2181","text":"Added support for newRequest() in new RouteBinder mechanic.","title":"v2.18.1"},{"location":"changelog/#v2180","text":"Add support for unlimited nesting for routes() blocks. Removed the raw Route object, which can be replaced with Router or RoutingHttpHandler where appropriate. As part of above, rejigged route setup logic. Deprecated old routing structure, so now \"/path\" to GET bind is \"/path\" bind GET to . To fix deprecation, simply switch the calls to \"to\" and \"bind\" in routing setup. Rename of bind() in http4k-contract to be bindContract()","title":"v2.18.0"},{"location":"changelog/#v2172","text":"Added missing eclectic HTTP method. :)","title":"v2.17.2"},{"location":"changelog/#v2171","text":"Added GZip filters to http4k-core to zip request and response bodies.","title":"v2.17.1"},{"location":"changelog/#v2161","text":"Improved messages for http4k-testing-hamkrest matchers.","title":"v2.16.1"},{"location":"changelog/#v2160","text":"Added http4k-testing-hamkrest which contains a set of Hamkrest matchers for Http4k objects.","title":"v2.16.0"},{"location":"changelog/#v2150","text":"More features for http4k-testing-webdriver . Cookie support added.","title":"v2.15.0"},{"location":"changelog/#v2140","text":"More features for http4k-testing-webdriver . We now support Form entry and submission.","title":"v2.14.0"},{"location":"changelog/#v2130","text":"More features for http4k-testing-webdriver .","title":"v2.13.0"},{"location":"changelog/#v2120","text":"Added http4k-testing-webdriver module, an ultralight Selenium WebDriver for http4k apps","title":"v2.12.0"},{"location":"changelog/#v2113","text":"Fix #26 - GenerateDataClasses does not recurse into nested object trees","title":"v2.11.3"},{"location":"changelog/#v2112","text":"Fix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with then(RoutingHttpHandler()","title":"v2.11.2"},{"location":"changelog/#v2111","text":"Fix static routes not defaulting to index.html when in root context","title":"v2.11.1"},{"location":"changelog/#v2110","text":"Added SunHttp server implementation (for development use only)","title":"v2.11.0"},{"location":"changelog/#v2101","text":"Fix cookie parsing when value contains '='","title":"v2.10.1"},{"location":"changelog/#v2100","text":"Add method to set form values in the request","title":"v2.10.0"},{"location":"changelog/#v290","text":"Added PURGE HTTP method as it's used commonly by various caches.","title":"v2.9.0"},{"location":"changelog/#v281","text":"Repackage AWS classes for consistency with rest of project","title":"v2.8.1"},{"location":"changelog/#v271","text":"Alter AWS Auth filter creation. Now use ClientFilters.AwsAuth","title":"v2.7.1"},{"location":"changelog/#v270","text":"Add AWS module","title":"v2.7.0"},{"location":"changelog/#v260","text":"Newly created Zipkin traces are now populated onto incoming request in ServerFilters.","title":"v2.6.0"},{"location":"changelog/#v251","text":"Slight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling","title":"v2.5.1"},{"location":"changelog/#v250","text":"Add Thymeleaf templating support","title":"v2.5.0"},{"location":"changelog/#v240","text":"Add Pebble templating support","title":"v2.4.0"},{"location":"changelog/#v230","text":"Make Route a Router so we can nest them together.","title":"v2.3.0"},{"location":"changelog/#v221","text":"Remove excess \"charset\" from headers in Undertow.","title":"v2.2.1"},{"location":"changelog/#v220","text":"Rename by() to bind() in routing for clarity.","title":"v2.2.0"},{"location":"changelog/#v212","text":"Fix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex.","title":"v2.1.2"},{"location":"changelog/#v210","text":"Added GSON full-auto functions to convert arbitary objects to/from JSON.","title":"v2.1.0"},{"location":"changelog/#v205","text":"Fix #23. Contract now supports multi-part URL params (for hardcoded parts)","title":"v2.0.5"},{"location":"changelog/#v204","text":"Fix #22. Uri template does not parse out correct path params when URL starts with a path part.","title":"v2.0.4"},{"location":"changelog/#v203","text":"toString() implementations to aid debugging","title":"v2.0.3"},{"location":"changelog/#v201","text":"Readded missing default parameter for newRequest() on RouteSpec","title":"v2.0.1"},{"location":"changelog/#v200","text":"Breaking: Inversion of routing API. GET to \"/someUri\" is now \"/someUri\" to GET for consistency across the entire API.","title":"v2.0.0"},{"location":"changelog/#v1331","text":"Reimplementation of http4k-contract API to match main routing API. Contracts are now nestable.","title":"v1.33.1"},{"location":"changelog/#v1322","text":"Fix Filters being applied twice in ContractRoutingHttpHandler","title":"v1.32.2"},{"location":"changelog/#v1321","text":"More work on http4k-contract contract API","title":"v1.32.1"},{"location":"changelog/#v1310","text":"Rework http4k-contract routing to be mounted in the same way as other RoutingHttpHandlers","title":"v1.31.0"},{"location":"changelog/#v1300","text":"Filters are now applied consistently to all Routers","title":"v1.30.0"},{"location":"changelog/#v1290","text":"Tweak to DSL for defining StaticRouters","title":"v1.29.0"},{"location":"changelog/#v1281","text":"Fix for #18: FollowRedirect will now work if location header includes charset information.","title":"v1.28.1"},{"location":"changelog/#v1280","text":"New DSL for defining StaticRouters","title":"v1.28.0"},{"location":"changelog/#v1270","text":"Merged StaticContent and StaticRouter and repackage of contract API into other packages","title":"v1.27.0"},{"location":"changelog/#v1262","text":"Extend fix for #17 to request Cookie header.","title":"v1.26.2"},{"location":"changelog/#v1261","text":"Fix for #17. Cookie can now parse a cookie without attributes and ending in semicolon.","title":"v1.26.1"},{"location":"changelog/#v1260","text":"Added nestable Routers. Merging of Modules and Routers. Router is the new Module ! RouteModule is now ContractRouter , so rename in code will be required.","title":"v1.26.0"},{"location":"changelog/#v1251","text":"Fix for #15. OkHttp client handling of POSTs with no body.","title":"v1.25.1"},{"location":"changelog/#v1250","text":"Can add custom mime types to Static Content GenerateDataClasses is capable of more complex object graphs","title":"v1.25.0"},{"location":"changelog/#v1240","text":"Remove HttpHandler.asServer in favour of HttpHandler.startServer to avoid confusion. Introduce Status.description() .","title":"v1.24.0"},{"location":"changelog/#v1230","text":"Netty sets content-length header.","title":"v1.23.0"},{"location":"changelog/#v1222","text":"Fix for #12. Undertow not constructing response correctly.","title":"v1.22.2"},{"location":"changelog/#v1220","text":"New module with Undertow.io support http4k-server-undertow Jackson implementation now ignores unknown properties in incoming messages Netty implementation tidied up","title":"v1.22.0"},{"location":"changelog/#v1211","text":"Fix for #11. Netty implementation returns incorrect status codes.","title":"v1.21.1"},{"location":"changelog/#v1210","text":"Add synonym methods for Lenses to aid readability. We now have invoke(IN)/extract(IN) and `invoke(IN, TARGET)/inject(IN, TARGET)","title":"v1.21.0"},{"location":"changelog/#v1200","text":"http4k-contracts : Add option to change the route of the module description route","title":"v1.20.0"},{"location":"changelog/#v1191","text":"http4k-contracts : Fix for contract module description routes not being authenticated via security filter","title":"v1.19.1"},{"location":"changelog/#v1190","text":"http4k-contracts : Add Swagger module rendering with JSON schema models for messages.","title":"v1.19.0"},{"location":"changelog/#v1180","text":"Add nonEmptyString() lens type to all request parts.","title":"v1.18.0"},{"location":"changelog/#v1170","text":"General rework","title":"v1.17.0"},{"location":"changelog/#v1160","text":"Further work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios.","title":"v1.16.0"},{"location":"changelog/#v1150","text":"Path lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc. Routes can now create shell Requests for themselves, using route.newRequest()","title":"v1.15.0"},{"location":"changelog/#v1140","text":"Body is now non-nullable (use Body.EMPTY instead) Rename methods BodyLens API for consistency and clarity. required() is now toLens() . to()' binding method is now of().","title":"v1.14.0"},{"location":"changelog/#v1130","text":"New client module: http4k-client-okhttp","title":"v1.13.0"},{"location":"changelog/#v1120","text":"Tidying","title":"v1.12.0"},{"location":"changelog/#v1110","text":"Added option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :)","title":"v1.11.0"},{"location":"changelog/#v1100","text":"Moved Credentials to org.http4k.core package. Add various filters, including SetHostFrom and CatchAll .","title":"v1.10.0"},{"location":"changelog/#v190","text":"Added GenerateDataClasses so you can generate Kotlin data classes from JSON messages.","title":"v1.9.0"},{"location":"changelog/#v180","text":"Added CORs support","title":"v1.8.0"},{"location":"changelog/#v170","text":"Added auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses","title":"v1.7.0"},{"location":"changelog/#v160","text":"Added CachingFilters","title":"v1.6.0"},{"location":"changelog/#v150","text":"Removed static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions. Merge org.http4k.core.Body and org.http4k.lens.Body . Add Request/Response message parsers.","title":"v1.5.0"},{"location":"changelog/#v140","text":"Turn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected.","title":"v1.4.0"},{"location":"changelog/#v130","text":"Removed non-mandatory parameters from Request and Response constructors. This is aid API clarity. and force users to use the API methods for properly constructing the objects. Regex Lens added.","title":"v1.3.0"},{"location":"changelog/#v100","text":"Initial major release.","title":"v1.0.0"},{"location":"contributing/","text":"Contributers' Guide There are many ways in which you can contribute to the development of the library: Give us a Star on Github - you know you want to ;) Questions can be directed towards the Gitter channel, or on Twitter @http4k For issues, please describe giving as much detail as you can - including version and steps to recreate pull requests If there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR. JSON formats: create a new module with an implementation of Json by following the Argo example in the source. Templating engines: create a new module with a Templates implementation by following the HandlebarsTemplates example in the source general guidelines At the moment, PRs should be sent to the master branch - this might change in future so check back everytime! Source/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions PR changes should have test coverage. Note that we use Junit 5 as a test engine - which uses new @Test annotations. All the PRs must pass the Travis CI jobs before merging them https://travis-ci.org/http4k/http4k Testing with default settings is required when push changes: sh ./gradlew check Financial contributions We also welcome financial contributions in full transparency on our open collective . Anyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed. Credits Contributors Thank you to all the people who have already contributed to http4k! Backers Thank you to all our backers! [ Become a backer ] Sponsors Thank you to all our sponsors! (please ask your company to also support this open source project by becoming a sponsor ) Vendor support Many thanks to all of the software vendors who supply tools to help us deliver http4k to it's community: Kotlin IDE Jetbrains kindly supplies the project with an Open Source License for the amazing IntelliJ IDE. JVM Profiling tools YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler , YourKit .NET Profiler , and YourKit YouMonitor .","title":"Contribute/Support http4k"},{"location":"contributing/#pull-requests","text":"If there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR. JSON formats: create a new module with an implementation of Json by following the Argo example in the source. Templating engines: create a new module with a Templates implementation by following the HandlebarsTemplates example in the source","title":"pull requests"},{"location":"contributing/#general-guidelines","text":"At the moment, PRs should be sent to the master branch - this might change in future so check back everytime! Source/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions PR changes should have test coverage. Note that we use Junit 5 as a test engine - which uses new @Test annotations. All the PRs must pass the Travis CI jobs before merging them https://travis-ci.org/http4k/http4k Testing with default settings is required when push changes: sh ./gradlew check","title":"general guidelines"},{"location":"contributing/#financial-contributions","text":"We also welcome financial contributions in full transparency on our open collective . Anyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.","title":"Financial contributions"},{"location":"contributing/#credits","text":"","title":"Credits"},{"location":"contributing/#contributors","text":"Thank you to all the people who have already contributed to http4k!","title":"Contributors"},{"location":"contributing/#backers","text":"Thank you to all our backers! [ Become a backer ]","title":"Backers"},{"location":"contributing/#sponsors","text":"Thank you to all our sponsors! (please ask your company to also support this open source project by becoming a sponsor )","title":"Sponsors"},{"location":"contributing/#vendor-support","text":"Many thanks to all of the software vendors who supply tools to help us deliver http4k to it's community:","title":"Vendor support"},{"location":"contributing/#kotlin-ide","text":"Jetbrains kindly supplies the project with an Open Source License for the amazing IntelliJ IDE.","title":"Kotlin IDE"},{"location":"contributing/#jvm-profiling-tools","text":"YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler , YourKit .NET Profiler , and YourKit YouMonitor .","title":"JVM Profiling tools"},{"location":"cookbook/basic_oauth_authorization_server/","text":"Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.247.0\" For this example, you need to configure OAuthServer instance with the correct implementations of your login pages, generation of authentication codes and access tokens. Code import com.natpryce.Failure import com.natpryce.Success import org.http4k.client.OkHttp import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.format.Jackson import org.http4k.routing.RoutingHttpHandler import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.security.AccessToken import org.http4k.security.InsecureCookieBasedOAuthPersistence import org.http4k.security.OAuthProvider import org.http4k.security.OAuthProviderConfig import org.http4k.security.oauth.server.AccessTokens import org.http4k.security.oauth.server.AuthRequest import org.http4k.security.oauth.server.AuthorizationCode import org.http4k.security.oauth.server.AuthorizationCodeDetails import org.http4k.security.oauth.server.AuthorizationCodes import org.http4k.security.oauth.server.ClientId import org.http4k.security.oauth.server.ClientValidator import org.http4k.security.oauth.server.InsecureCookieBasedAuthRequestTracking import org.http4k.security.oauth.server.OAuthServer import org.http4k.security.oauth.server.TokenRequest import org.http4k.security.oauth.server.UnsupportedGrantType import org.http4k.security.oauth.server.accesstoken.AuthorizationCodeAccessTokenRequest import org.http4k.server.Jetty import org.http4k.server.asServer import java.time.Clock import java.time.temporal.ChronoUnit.DAYS import java.util.UUID fun main () { fun authorizationServer (): RoutingHttpHandler { val server = OAuthServer ( tokenPath = \"/oauth2/token\" , authRequestTracking = InsecureCookieBasedAuthRequestTracking (), clientValidator = InsecureClientValidator (), authorizationCodes = InsecureAuthorizationCodes (), accessTokens = InsecureAccessTokens (), json = Jackson , clock = Clock . systemUTC (), documentationUri = \"See the full API docs at https://example.com/docs/access_token\" ) return routes ( server . tokenRoute , \"/my-login-page\" bind GET to server . authenticationStart . then { Response ( OK ) . body ( \"\"\"<html><form method=\"POST\"><button type=\"submit\">Please authenticate</button></form></html>\"\"\" ) }, \"/my-login-page\" bind POST to server . authenticationComplete ) } fun oAuthClientApp ( tokenClient : HttpHandler ): RoutingHttpHandler { val persistence = InsecureCookieBasedOAuthPersistence ( \"oauthTest\" ) val authorizationServer = Uri . of ( \"http://localhost:9000\" ) val oauthProvider = OAuthProvider ( OAuthProviderConfig ( authorizationServer , \"/my-login-page\" , \"/oauth2/token\" , Credentials ( \"my-app\" , \"somepassword\" ) ), tokenClient , Uri . of ( \"http://localhost:8000/my-callback\" ), listOf ( \"name\" , \"age\" ), persistence ) return routes ( \"/my-callback\" bind GET to oauthProvider . callback , \"/a-protected-resource\" bind GET to oauthProvider . authFilter . then { Response ( OK ) . body ( \"user's protected resource\" ) } ) } oAuthClientApp ( OkHttp ()) . asServer ( Jetty ( 8000 )) . start () authorizationServer () . asServer ( Jetty ( 9000 )) . start () . block () // Go to http : // localhost : 8000 / a - protected - resource to start the authorization flow } // This class allow you to make extra checks about the oauth client during the flow class InsecureClientValidator : ClientValidator { // the client id should be a registered one override fun validateClientId ( request : Request , clientId : ClientId ): Boolean = true // one should only redirect to URLs registered against a particular client override fun validateRedirection ( request : Request , clientId : ClientId , redirectionUri : Uri ): Boolean = true // one should validate the scopes are correct for that client override fun validateScopes ( request : Request , clientId : ClientId , scopes : List < String > ): Boolean = true // certain operations can only be performed by fully authenticated clients ( e . g . generate access tokens ) override fun validateCredentials ( request : Request , clientId : ClientId , clientSecret : String ): Boolean = true } class InsecureAuthorizationCodes : AuthorizationCodes { private val clock = Clock . systemUTC () private val codes = mutableMapOf < AuthorizationCode , AuthorizationCodeDetails > () override fun detailsFor ( code : AuthorizationCode ) = codes [ code ] ? : error ( \"code not stored\" ) // Authorization codes should be associated to a particular user ( who can be identified in the Response ) // so they can be checked in various stages of the authorization flow override fun create ( request : Request , authRequest : AuthRequest , response : Response ) = Success ( AuthorizationCode ( UUID . randomUUID () . toString ()) . also { codes [ it ] = AuthorizationCodeDetails ( authRequest . client , authRequest . redirectUri !! , clock . instant () . plus ( 1 , DAYS ), authRequest . state , authRequest . isOIDC ()) }) } class InsecureAccessTokens : AccessTokens { override fun create ( clientId : ClientId , tokenRequest : TokenRequest ) = Failure ( UnsupportedGrantType ( \"client_credentials\" )) // an access token should be associated with a particular authorization flow // ( i . e . limited to the requested scopes ), and contain an expiration date override fun create ( clientId : ClientId , tokenRequest : AuthorizationCodeAccessTokenRequest , authorizationCode : AuthorizationCode ) = Success ( AccessToken ( UUID . randomUUID () . toString ())) }","title":"Basic OAuth Server configuration"},{"location":"cookbook/basic_oauth_authorization_server/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.247.0\" For this example, you need to configure OAuthServer instance with the correct implementations of your login pages, generation of authentication codes and access tokens.","title":"Gradle setup"},{"location":"cookbook/basic_oauth_authorization_server/#code","text":"import com.natpryce.Failure import com.natpryce.Success import org.http4k.client.OkHttp import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.format.Jackson import org.http4k.routing.RoutingHttpHandler import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.security.AccessToken import org.http4k.security.InsecureCookieBasedOAuthPersistence import org.http4k.security.OAuthProvider import org.http4k.security.OAuthProviderConfig import org.http4k.security.oauth.server.AccessTokens import org.http4k.security.oauth.server.AuthRequest import org.http4k.security.oauth.server.AuthorizationCode import org.http4k.security.oauth.server.AuthorizationCodeDetails import org.http4k.security.oauth.server.AuthorizationCodes import org.http4k.security.oauth.server.ClientId import org.http4k.security.oauth.server.ClientValidator import org.http4k.security.oauth.server.InsecureCookieBasedAuthRequestTracking import org.http4k.security.oauth.server.OAuthServer import org.http4k.security.oauth.server.TokenRequest import org.http4k.security.oauth.server.UnsupportedGrantType import org.http4k.security.oauth.server.accesstoken.AuthorizationCodeAccessTokenRequest import org.http4k.server.Jetty import org.http4k.server.asServer import java.time.Clock import java.time.temporal.ChronoUnit.DAYS import java.util.UUID fun main () { fun authorizationServer (): RoutingHttpHandler { val server = OAuthServer ( tokenPath = \"/oauth2/token\" , authRequestTracking = InsecureCookieBasedAuthRequestTracking (), clientValidator = InsecureClientValidator (), authorizationCodes = InsecureAuthorizationCodes (), accessTokens = InsecureAccessTokens (), json = Jackson , clock = Clock . systemUTC (), documentationUri = \"See the full API docs at https://example.com/docs/access_token\" ) return routes ( server . tokenRoute , \"/my-login-page\" bind GET to server . authenticationStart . then { Response ( OK ) . body ( \"\"\"<html><form method=\"POST\"><button type=\"submit\">Please authenticate</button></form></html>\"\"\" ) }, \"/my-login-page\" bind POST to server . authenticationComplete ) } fun oAuthClientApp ( tokenClient : HttpHandler ): RoutingHttpHandler { val persistence = InsecureCookieBasedOAuthPersistence ( \"oauthTest\" ) val authorizationServer = Uri . of ( \"http://localhost:9000\" ) val oauthProvider = OAuthProvider ( OAuthProviderConfig ( authorizationServer , \"/my-login-page\" , \"/oauth2/token\" , Credentials ( \"my-app\" , \"somepassword\" ) ), tokenClient , Uri . of ( \"http://localhost:8000/my-callback\" ), listOf ( \"name\" , \"age\" ), persistence ) return routes ( \"/my-callback\" bind GET to oauthProvider . callback , \"/a-protected-resource\" bind GET to oauthProvider . authFilter . then { Response ( OK ) . body ( \"user's protected resource\" ) } ) } oAuthClientApp ( OkHttp ()) . asServer ( Jetty ( 8000 )) . start () authorizationServer () . asServer ( Jetty ( 9000 )) . start () . block () // Go to http : // localhost : 8000 / a - protected - resource to start the authorization flow } // This class allow you to make extra checks about the oauth client during the flow class InsecureClientValidator : ClientValidator { // the client id should be a registered one override fun validateClientId ( request : Request , clientId : ClientId ): Boolean = true // one should only redirect to URLs registered against a particular client override fun validateRedirection ( request : Request , clientId : ClientId , redirectionUri : Uri ): Boolean = true // one should validate the scopes are correct for that client override fun validateScopes ( request : Request , clientId : ClientId , scopes : List < String > ): Boolean = true // certain operations can only be performed by fully authenticated clients ( e . g . generate access tokens ) override fun validateCredentials ( request : Request , clientId : ClientId , clientSecret : String ): Boolean = true } class InsecureAuthorizationCodes : AuthorizationCodes { private val clock = Clock . systemUTC () private val codes = mutableMapOf < AuthorizationCode , AuthorizationCodeDetails > () override fun detailsFor ( code : AuthorizationCode ) = codes [ code ] ? : error ( \"code not stored\" ) // Authorization codes should be associated to a particular user ( who can be identified in the Response ) // so they can be checked in various stages of the authorization flow override fun create ( request : Request , authRequest : AuthRequest , response : Response ) = Success ( AuthorizationCode ( UUID . randomUUID () . toString ()) . also { codes [ it ] = AuthorizationCodeDetails ( authRequest . client , authRequest . redirectUri !! , clock . instant () . plus ( 1 , DAYS ), authRequest . state , authRequest . isOIDC ()) }) } class InsecureAccessTokens : AccessTokens { override fun create ( clientId : ClientId , tokenRequest : TokenRequest ) = Failure ( UnsupportedGrantType ( \"client_credentials\" )) // an access token should be associated with a particular authorization flow // ( i . e . limited to the requested scopes ), and contain an expiration date override fun create ( clientId : ClientId , tokenRequest : AuthorizationCodeAccessTokenRequest , authorizationCode : AuthorizationCode ) = Success ( AccessToken ( UUID . randomUUID () . toString ())) }","title":"Code "},{"location":"cookbook/client_as_a_function/","text":"This example demonstrates using http4k as a client, to consume HTTP services. A client is just another HttpHandler. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Code package cookbook . client_as_a_function import org.http4k.client.JavaHttpClient import org.http4k.core.HttpHandler import org.http4k.core.Method import org.http4k.core.Request fun main () { val request = Request ( Method . GET , \"https://xkcd.com/info.0.json\" ) val client : HttpHandler = JavaHttpClient () println ( client ( request )) }","title":"Client as a function"},{"location":"cookbook/client_as_a_function/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/client_as_a_function/#code","text":"package cookbook . client_as_a_function import org.http4k.client.JavaHttpClient import org.http4k.core.HttpHandler import org.http4k.core.Method import org.http4k.core.Request fun main () { val request = Request ( Method . GET , \"https://xkcd.com/info.0.json\" ) val client : HttpHandler = JavaHttpClient () println ( client ( request )) }","title":"Code "},{"location":"cookbook/container_integration/","text":"This example shows how to both how to serve an application HttpHandler using an embedded an HTTP server and to query it using an HTTP client. All server-backend implementations are launched in an identical manner (in 1LOC) using implementations of the ServerConfig interface - and a base implementation of this interface is provided for each server backend. Alternatively, any http4k application can be mounted into any Servlet container using the asServlet() extension method. This is the mechanism used in the Jetty implementation. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.247.0\" Code package cookbook . container_integration import org.http4k.client.ApacheClient import org.http4k.core.Method import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { val app = { request : Request -> Response ( OK ) . body ( \"Hello, ${request.query(\" name \")}!\" ) } val jettyServer = app . asServer ( Jetty ( 9000 )) . start () val request = Request ( Method . GET , \"http://localhost:9000\" ) . query ( \"name\" , \"John Doe\" ) val client = ApacheClient () println ( client ( request )) jettyServer . stop () }","title":"Container integration"},{"location":"cookbook/container_integration/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/container_integration/#code","text":"package cookbook . container_integration import org.http4k.client.ApacheClient import org.http4k.core.Method import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { val app = { request : Request -> Response ( OK ) . body ( \"Hello, ${request.query(\" name \")}!\" ) } val jettyServer = app . asServer ( Jetty ( 9000 )) . start () val request = Request ( Method . GET , \"http://localhost:9000\" ) . query ( \"name\" , \"John Doe\" ) val client = ApacheClient () println ( client ( request )) jettyServer . stop () }","title":"Code "},{"location":"cookbook/custom_json_marshallers/","text":"Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.247.0\" Custom auto-mapping JSON configurations http4k declares an extended set of \"primitive\" types which it can marshall out of the box - this includes the various http4k primitives (Uri, Status), as well as a bunch of common types from the JDK such as the DateTime classes and Exceptions. These primitives types cannot be marshalled as top-level JSON structures on their own so should be contained in a custom wrapper class before transmission. You can declare your own custom marshaller by reimplementing the Json instance and adding mappings for your own types - either uni or bi-directional. This ability to render custom types through different JSON marshallers allows API users to provide different \"views\" for different purposes - for example we may wish to hide the values of some fields in the output, as below: Code package cookbook . custom_json_marshallers import com.fasterxml.jackson.databind.DeserializationFeature import com.fasterxml.jackson.module.kotlin.KotlinModule // this import is important so you don 't pick up the standard auto method! import cookbook.custom_json_marshallers.MyJackson.auto import org.http4k.core.Body import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.format.ConfigurableJackson import org.http4k.format.asConfigurable import org.http4k.format.text import org.http4k.format.withStandardMappings object MyJackson : ConfigurableJackson ( KotlinModule () . asConfigurable () . withStandardMappings () // declare custom mapping for our own types - this one represents our type as a simple String . text (:: PublicType , PublicType :: value ) // ... and this one shows a masked value and cannot be deserialised ( as the mapping is only one way ) . text ( SecretType :: toString ) . done () . deactivateDefaultTyping () . configure ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES , false ) ) data class PublicType ( val value : String ) data class SecretType ( val value : String ) { override fun toString (): String { return \"****\" } } data class MyType ( val public : PublicType , val hidden : SecretType ) fun main () { println ( Response ( OK ) . with ( Body . auto < MyType > () . toLens () of MyType ( PublicType ( \"hello\" ), SecretType ( \"secret\" ))) ) /** Prints : HTTP / 1.1 200 OK content - type : application / json ; charset = utf - 8 { \"public\" : \"hello\" , \"hidden\" : \"****\" } */ }","title":"Custom JSON marshallers"},{"location":"cookbook/custom_json_marshallers/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/custom_json_marshallers/#custom-auto-mapping-json-configurations","text":"http4k declares an extended set of \"primitive\" types which it can marshall out of the box - this includes the various http4k primitives (Uri, Status), as well as a bunch of common types from the JDK such as the DateTime classes and Exceptions. These primitives types cannot be marshalled as top-level JSON structures on their own so should be contained in a custom wrapper class before transmission. You can declare your own custom marshaller by reimplementing the Json instance and adding mappings for your own types - either uni or bi-directional. This ability to render custom types through different JSON marshallers allows API users to provide different \"views\" for different purposes - for example we may wish to hide the values of some fields in the output, as below:","title":"Custom auto-mapping JSON configurations"},{"location":"cookbook/custom_json_marshallers/#code","text":"package cookbook . custom_json_marshallers import com.fasterxml.jackson.databind.DeserializationFeature import com.fasterxml.jackson.module.kotlin.KotlinModule // this import is important so you don 't pick up the standard auto method! import cookbook.custom_json_marshallers.MyJackson.auto import org.http4k.core.Body import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.format.ConfigurableJackson import org.http4k.format.asConfigurable import org.http4k.format.text import org.http4k.format.withStandardMappings object MyJackson : ConfigurableJackson ( KotlinModule () . asConfigurable () . withStandardMappings () // declare custom mapping for our own types - this one represents our type as a simple String . text (:: PublicType , PublicType :: value ) // ... and this one shows a masked value and cannot be deserialised ( as the mapping is only one way ) . text ( SecretType :: toString ) . done () . deactivateDefaultTyping () . configure ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES , false ) ) data class PublicType ( val value : String ) data class SecretType ( val value : String ) { override fun toString (): String { return \"****\" } } data class MyType ( val public : PublicType , val hidden : SecretType ) fun main () { println ( Response ( OK ) . with ( Body . auto < MyType > () . toLens () of MyType ( PublicType ( \"hello\" ), SecretType ( \"secret\" ))) ) /** Prints : HTTP / 1.1 200 OK content - type : application / json ; charset = utf - 8 { \"public\" : \"hello\" , \"hidden\" : \"****\" } */ }","title":"Code "},{"location":"cookbook/custom_oauth_provider/","text":"It is very easy to configure http4k to integrate with any OAuth2 provider who supports the Authorisation Code Grant. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.247.0\" For this example, simply reconfigure the OAuthProvider instance with the correct details, and provide custom logic for persisting and retrieving the CSRF and AccessToken. Code package cookbook . custom_oauth_provider import org.http4k.client.ApacheClient import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ServerFilters import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.security.AccessToken import org.http4k.security.CrossSiteRequestForgeryToken import org.http4k.security.OAuthPersistence import org.http4k.security.OAuthProvider import org.http4k.security.OAuthProviderConfig import org.http4k.security.openid.Nonce import org.http4k.server.SunHttp import org.http4k.server.asServer // this example shows how to configure a custom provider for the OAuth2 Auth Code Grant flow fun main () { val port = 9000 // the callback uri which is configured in our OAuth provider val callbackUri = Uri . of ( \"http://localhost:$port/callback\" ) // custom OAuth2 provider configuration val oauthProvider = OAuthProvider ( OAuthProviderConfig ( Uri . of ( \"https://auth.chatroulette.com\" ), \"/oauth2/auth\" , \"/oauth2/token\" , Credentials ( \"username\" , \"somepassword\" ), Uri . of ( \"https://api.chatroulette.com\" )), ApacheClient (), callbackUri , listOf ( \"emailScope\" , \"nameScope\" , \"familyScope\" ), CustomOAuthPersistence () ) val app : HttpHandler = routes ( callbackUri . path bind GET to oauthProvider . callback , \"/\" bind GET to oauthProvider . authFilter . then { Response ( OK ) . body ( \"hello!\" ) } ) ServerFilters . CatchAll () . then ( app ) . asServer ( SunHttp ( port )) . start () . block () } // this interface allows us to provide custom logic for storing and verifying the CSRF and AccessTokens . // to be maximally secure , never let the end - user see the access token ! class CustomOAuthPersistence : OAuthPersistence { var nonce : Nonce ? = null var csrf : CrossSiteRequestForgeryToken ? = null var accessToken : AccessToken ? = null override fun retrieveCsrf ( request : Request ): CrossSiteRequestForgeryToken ? = csrf override fun assignCsrf ( redirect : Response , csrf : CrossSiteRequestForgeryToken ): Response { this . csrf = csrf return redirect . header ( \"action\" , \"assignCsrf\" ) } override fun assignNonce ( redirect : Response , nonce : Nonce ): Response { this . nonce = nonce return redirect . header ( \"action\" , \"assignNonce\" ) } override fun retrieveNonce ( request : Request ): Nonce ? = nonce override fun retrieveToken ( request : Request ): AccessToken ? = accessToken override fun assignToken ( request : Request , redirect : Response , accessToken : AccessToken ): Response { this . accessToken = accessToken return redirect . header ( \"action\" , \"assignToken\" ) } }","title":"Custom OAuth Provider configuration"},{"location":"cookbook/custom_oauth_provider/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.247.0\" For this example, simply reconfigure the OAuthProvider instance with the correct details, and provide custom logic for persisting and retrieving the CSRF and AccessToken.","title":"Gradle setup"},{"location":"cookbook/custom_oauth_provider/#code","text":"package cookbook . custom_oauth_provider import org.http4k.client.ApacheClient import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ServerFilters import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.security.AccessToken import org.http4k.security.CrossSiteRequestForgeryToken import org.http4k.security.OAuthPersistence import org.http4k.security.OAuthProvider import org.http4k.security.OAuthProviderConfig import org.http4k.security.openid.Nonce import org.http4k.server.SunHttp import org.http4k.server.asServer // this example shows how to configure a custom provider for the OAuth2 Auth Code Grant flow fun main () { val port = 9000 // the callback uri which is configured in our OAuth provider val callbackUri = Uri . of ( \"http://localhost:$port/callback\" ) // custom OAuth2 provider configuration val oauthProvider = OAuthProvider ( OAuthProviderConfig ( Uri . of ( \"https://auth.chatroulette.com\" ), \"/oauth2/auth\" , \"/oauth2/token\" , Credentials ( \"username\" , \"somepassword\" ), Uri . of ( \"https://api.chatroulette.com\" )), ApacheClient (), callbackUri , listOf ( \"emailScope\" , \"nameScope\" , \"familyScope\" ), CustomOAuthPersistence () ) val app : HttpHandler = routes ( callbackUri . path bind GET to oauthProvider . callback , \"/\" bind GET to oauthProvider . authFilter . then { Response ( OK ) . body ( \"hello!\" ) } ) ServerFilters . CatchAll () . then ( app ) . asServer ( SunHttp ( port )) . start () . block () } // this interface allows us to provide custom logic for storing and verifying the CSRF and AccessTokens . // to be maximally secure , never let the end - user see the access token ! class CustomOAuthPersistence : OAuthPersistence { var nonce : Nonce ? = null var csrf : CrossSiteRequestForgeryToken ? = null var accessToken : AccessToken ? = null override fun retrieveCsrf ( request : Request ): CrossSiteRequestForgeryToken ? = csrf override fun assignCsrf ( redirect : Response , csrf : CrossSiteRequestForgeryToken ): Response { this . csrf = csrf return redirect . header ( \"action\" , \"assignCsrf\" ) } override fun assignNonce ( redirect : Response , nonce : Nonce ): Response { this . nonce = nonce return redirect . header ( \"action\" , \"assignNonce\" ) } override fun retrieveNonce ( request : Request ): Nonce ? = nonce override fun retrieveToken ( request : Request ): AccessToken ? = accessToken override fun assignToken ( request : Request , redirect : Response , accessToken : AccessToken ): Response { this . accessToken = accessToken return redirect . header ( \"action\" , \"assignToken\" ) } }","title":"Code "},{"location":"cookbook/generating_data_classes/","text":"On the web... This Heroku app demonstrates how to use JSON and XML automarshalling to communicate using typesafe Body lenses. Or manually using a filter... This example show the usage of the GenerateDataClasses to generate Kotlin data class code for JSON messages from a remote endpoint. When used in conjunction with the \"auto body-marshalling\" functionality available with JSON libraries such as Jackson and GSON, this provides a super-fast way to integrate with upstream remote APIs in a typesafe way. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"3.247.0\" Code package cookbook . generating_data_classes import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.GenerateDataClasses import org.http4k.format.Jackson fun main () { val request = Request ( GET , \"http://api.icndb.com/jokes/random/3\" ) GenerateDataClasses ( Jackson , System . out ) . then ( ApacheClient ()) . invoke ( request ) }","title":"Generating data classes for messages"},{"location":"cookbook/generating_data_classes/#on-the-web","text":"This Heroku app demonstrates how to use JSON and XML automarshalling to communicate using typesafe Body lenses.","title":"On the web..."},{"location":"cookbook/generating_data_classes/#or-manually-using-a-filter","text":"This example show the usage of the GenerateDataClasses to generate Kotlin data class code for JSON messages from a remote endpoint. When used in conjunction with the \"auto body-marshalling\" functionality available with JSON libraries such as Jackson and GSON, this provides a super-fast way to integrate with upstream remote APIs in a typesafe way.","title":"Or manually using a filter..."},{"location":"cookbook/generating_data_classes/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/generating_data_classes/#code","text":"package cookbook . generating_data_classes import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.GenerateDataClasses import org.http4k.format.Jackson fun main () { val request = Request ( GET , \"http://api.icndb.com/jokes/random/3\" ) GenerateDataClasses ( Jackson , System . out ) . then ( ApacheClient ()) . invoke ( request ) }","title":"Code "},{"location":"cookbook/html_forms/","text":"HTML form support is provided on 2 levels: Through the use of form() extension methods on Request to get/set String values. Using the Lens system, which adds the facility to define form fields in a typesafe way, and to validate form contents (in either a strict (400) or \"feedback\" mode). Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Standard (non-typesafe) API package cookbook . html_forms import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.body.form import org.http4k.core.getFirst import org.http4k.core.toParametersMap import org.junit.jupiter.api.Assertions.assertEquals import org.junit.jupiter.api.Assertions.assertNull fun main () { val request = Request ( GET , \"/\" ) . form ( \"name\" , \"rita\" ) . form ( \"age\" , \"55\" ) // reparses body every invocation assertEquals ( \"rita\" , request . form ( \"name\" )) assertEquals ( \"55\" , request . form ( \"age\" )) assertNull ( request . form ( \"height\" )) // toParametersMap () gives form as map val parameters : Map < String , List < String ? >> = request . form () . toParametersMap () assertEquals ( \"rita\" , parameters . getFirst ( \"name\" )) assertEquals ( listOf ( \"55\" ), parameters [ \"age\" ]) assertNull ( parameters [ \"height\" ]) } Lens (typesafe, validating) API package cookbook . html_forms import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.with import org.http4k.lens.FormField import org.http4k.lens.Header import org.http4k.lens.LensFailure import org.http4k.lens.Validator import org.http4k.lens.WebForm import org.http4k.lens.int import org.http4k.lens.webForm data class Name ( val value : String ) fun main () { // define fields using the standard lens syntax val ageField = FormField . int () . required ( \"age\" ) val nameField = FormField . map (:: Name , Name :: value ) . optional ( \"name\" ) // add fields to a form definition , along with a validator val strictFormBody = Body . webForm ( Validator . Strict , nameField , ageField ) . toLens () val feedbackFormBody = Body . webForm ( Validator . Feedback , nameField , ageField ) . toLens () val invalidRequest = Request ( GET , \"/\" ) . with ( Header . CONTENT_TYPE of ContentType . APPLICATION_FORM_URLENCODED ) // the \"strict\" form rejects ( throws a LensFailure ) because \"age\" is required try { strictFormBody ( invalidRequest ) } catch ( e : LensFailure ) { println ( e . message ) } // the \"feedback\" form doesn 't throw, but collects errors to be reported later val invalidForm = feedbackFormBody ( invalidRequest ) println ( invalidForm . errors ) // creating valid form using \"with()\" and setting it onto the request val webForm = WebForm () . with ( ageField of 55 , nameField of Name ( \"rita\" )) val validRequest = Request ( GET , \"/\" ) . with ( strictFormBody of webForm ) // to extract the contents , we first extract the form and then extract the fields from it using the lenses val validForm = strictFormBody ( validRequest ) val age = ageField ( validForm ) println ( age ) }","title":"HTML forms"},{"location":"cookbook/html_forms/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/html_forms/#standard-non-typesafe-api","text":"package cookbook . html_forms import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.body.form import org.http4k.core.getFirst import org.http4k.core.toParametersMap import org.junit.jupiter.api.Assertions.assertEquals import org.junit.jupiter.api.Assertions.assertNull fun main () { val request = Request ( GET , \"/\" ) . form ( \"name\" , \"rita\" ) . form ( \"age\" , \"55\" ) // reparses body every invocation assertEquals ( \"rita\" , request . form ( \"name\" )) assertEquals ( \"55\" , request . form ( \"age\" )) assertNull ( request . form ( \"height\" )) // toParametersMap () gives form as map val parameters : Map < String , List < String ? >> = request . form () . toParametersMap () assertEquals ( \"rita\" , parameters . getFirst ( \"name\" )) assertEquals ( listOf ( \"55\" ), parameters [ \"age\" ]) assertNull ( parameters [ \"height\" ]) }","title":"Standard (non-typesafe) API "},{"location":"cookbook/html_forms/#lens-typesafe-validating-api","text":"package cookbook . html_forms import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.with import org.http4k.lens.FormField import org.http4k.lens.Header import org.http4k.lens.LensFailure import org.http4k.lens.Validator import org.http4k.lens.WebForm import org.http4k.lens.int import org.http4k.lens.webForm data class Name ( val value : String ) fun main () { // define fields using the standard lens syntax val ageField = FormField . int () . required ( \"age\" ) val nameField = FormField . map (:: Name , Name :: value ) . optional ( \"name\" ) // add fields to a form definition , along with a validator val strictFormBody = Body . webForm ( Validator . Strict , nameField , ageField ) . toLens () val feedbackFormBody = Body . webForm ( Validator . Feedback , nameField , ageField ) . toLens () val invalidRequest = Request ( GET , \"/\" ) . with ( Header . CONTENT_TYPE of ContentType . APPLICATION_FORM_URLENCODED ) // the \"strict\" form rejects ( throws a LensFailure ) because \"age\" is required try { strictFormBody ( invalidRequest ) } catch ( e : LensFailure ) { println ( e . message ) } // the \"feedback\" form doesn 't throw, but collects errors to be reported later val invalidForm = feedbackFormBody ( invalidRequest ) println ( invalidForm . errors ) // creating valid form using \"with()\" and setting it onto the request val webForm = WebForm () . with ( ageField of 55 , nameField of Name ( \"rita\" )) val validRequest = Request ( GET , \"/\" ) . with ( strictFormBody of webForm ) // to extract the contents , we first extract the form and then extract the fields from it using the lenses val validForm = strictFormBody ( validRequest ) val age = ageField ( validForm ) println ( age ) }","title":"Lens (typesafe, validating) API "},{"location":"cookbook/monitoring/","text":"Measuring performance of application estate is crucial in today's microservice world - it is crucial that dev-ops enabled teams can monitor, react and scale dynamically to changes in the runtime environment. However, because of the plethora of monitoring tools on the market, and because http4k is a toolkit and not a complete \"batteries included\" framework, it provides a number of integration points to enable monitoring systems to be plugged in as required. Additionally, it is envisaged that users will probably want to provide their own implementations of the http4k ServerConfig classes ( Jetty , Undertow etc..) so that tweaking and tuning to their exact requirements is accessible, instead of http4k attempting to provide some generic configuration API to achieve it. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-metrics-micrometer\", version: \"3.247.0\" Metrics (Micrometer) http4k provides module support for monitoring application endpoints using the micrometer metrics abstraction library, which currently enables support for libraries such as Graphite, StatsD, Prometheus and Netflix Atlas. This also provides drop-in classes to record stats such as JVM performance, GC and thread usage. package cookbook . monitoring import io.micrometer.core.instrument.simple.SimpleMeterRegistry import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.MetricFilters import org.http4k.routing.bind import org.http4k.routing.routes fun main () { // this is a micrometer registry used mostly for testing - substitute the correct implementation . val registry = SimpleMeterRegistry () val server = routes ( \"/metrics/{name}\" bind GET to { Response ( OK ) }) // apply filters to a server ... val app = MetricFilters . Server . RequestCounter ( registry ) . then ( MetricFilters . Server . RequestTimer ( registry )) . then ( server ) // ... or to a client val client = MetricFilters . Client . RequestCounter ( registry ) . then ( MetricFilters . Client . RequestTimer ( registry )) . then ( ApacheClient ()) // make some calls ( 0. . 10 ) . forEach { app ( Request ( GET , \"/metrics/$it\" )) client ( Request ( GET , \"https://http4k.org\" )) } // see some results registry . forEachMeter { println ( \"${it.id} ${it.measure().joinToString(\" , \")}\" ) } } Metrics (other APIs) Alternatively, it's very easy to use a standard Filter to report on stats: package cookbook . monitoring import org.http4k.core.HttpHandler import org.http4k.core.HttpTransaction import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.HttpTransactionLabeller import org.http4k.filter.ResponseFilters import org.http4k.routing.bind import org.http4k.routing.routes import java.time.Duration fun main () { val app = routes ( \"foo/{name}\" bind { _ : Request -> Response ( OK ) }) fun metricConsumer ( name : String , time : Duration ) = println ( \"$name ${time.toMillis()}ms\" ) // this is a general use filter for reporting on http transactions val standardFilter = ResponseFilters . ReportHttpTransaction { tx : HttpTransaction -> metricConsumer ( \"txLabels are: ${tx.labels}\" , tx . duration ) metricConsumer ( \"uri is: ${tx.request.uri}\" , tx . duration ) } val addCustomLabels : HttpTransactionLabeller = { tx : HttpTransaction -> tx . label ( \"status\" , tx . response . status . code . toString ()) } val withCustomLabels = ResponseFilters . ReportHttpTransaction ( transactionLabeller = addCustomLabels ) { tx : HttpTransaction -> // send metrics to some custom system here ... println ( \"custom txLabels are: ${tx.labels} ${tx.duration}\" ) } // this filter provides an anonymous identifier of the route val identifiedRouteFilter = ResponseFilters . ReportRouteLatency { requestGroup : String , duration : Duration -> metricConsumer ( \"requestGroup is: \" + requestGroup , duration ) } val monitoredApp : HttpHandler = standardFilter . then ( withCustomLabels ) . then ( identifiedRouteFilter ) . then ( app ) monitoredApp ( Request ( GET , \"/foo/bob\" )) // prints ... // requestGroup is : GET . foo_ { name } . 2 xx . 200 7 ms // custom txLabels are : { routingGroup = foo / { name }, status = 200 } PT0 . 05 S // txLabels are : { routingGroup = foo / { name }} 51 ms // uri is : / foo / bob 51 ms } Logging This is trivial to achieve by using a Filter: package cookbook . monitoring import org.http4k.core.HttpHandler import org.http4k.core.HttpTransaction import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResponseFilters import org.http4k.routing.bind import org.http4k.routing.routes import java.time.Clock fun main () { val app = routes ( \"/{name}\" bind { _ : Request -> Response ( OK ) }) fun logger ( message : String ) = println ( \"${Clock.systemUTC().instant()} $message\" ) val audit = ResponseFilters . ReportHttpTransaction { tx : HttpTransaction -> logger ( \"my call to ${tx.request.uri} returned ${tx.response.status} and took ${tx.duration.toMillis()}\" ) } val monitoredApp : HttpHandler = audit . then ( app ) monitoredApp ( Request ( GET , \"/foo\" )) // prints ... // 2017 - 12 - 04 T08 : 38 : 27.499 Z my call to / foo returned 200 OK and took 5 } Distributed tracing This allows a chain of application calls to be tied together and is generally done through the setting of HTTP headers on each call. http4k supports the OpenZipkin standard for achieving this and provides both Server-side and Client-side Filters for this purpose. This example shows a chain of two proxies and an endpoint - run it to observe the changes to the tracing headers as the request flows through the system: package cookbook . monitoring import org.http4k.client.ApacheClient import org.http4k.core.HttpHandler import org.http4k.core.HttpMessage import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters import org.http4k.filter.ResponseFilters import org.http4k.filter.ServerFilters import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { fun HttpMessage . logHeader ( name : String ) = \" \\n\\t\\t $name=${header(name)}\" fun HttpMessage . traces () = logHeader ( \"x-b3-traceid\" ) + logHeader ( \"x-b3-spanid\" ) + logHeader ( \"x-b3-parentspanid\" ) fun audit ( name : String ) = ResponseFilters . ReportHttpTransaction { tx -> println ( \"$name: ${tx.request.uri} \\n\\t request:${tx.request.traces()} \\n\\t response:${tx.response.traces()}\" ) } // a simple proxy to another app fun proxy ( name : String , port : Int ): HttpHandler { val proxyClient = ClientFilters . RequestTracing () . then ( ClientFilters . SetHostFrom ( Uri . of ( \"http://localhost:$port\" ))) . then ( audit ( \"$name-client\" )) . then ( ApacheClient ()) return ServerFilters . RequestTracing () . then ( audit ( \"$name-server\" )) . then { proxyClient ( Request ( GET , it . uri )) } } // provides a simple ping fun ping (): HttpHandler = ServerFilters . RequestTracing () . then ( audit ( \"ping-server\" )) . then { Response ( OK ) . body ( \"pong\" ) } val proxy1 = proxy ( \"proxy1\" , 8001 ) . asServer ( SunHttp ( 8000 )) . start () val proxy2 = proxy ( \"proxy2\" , 8002 ) . asServer ( SunHttp ( 8001 )) . start () val server3 = ping () . asServer ( SunHttp ( 8002 )) . start () audit ( \"client\" ) . then ( ApacheClient ())( Request ( GET , \"http://localhost:8000/ping\" )) proxy1 . stop () proxy2 . stop () server3 . stop () } Debugging Easily wrap an HttpHandler in a debugging filter to check out what is going on under the covers: package cookbook . monitoring import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.DebuggingFilters fun main () { val app = { _ : Request -> Response ( OK ) . body ( \"hello there you look nice today\" ) } val debuggedApp = DebuggingFilters . PrintRequestAndResponse () . then ( app ) debuggedApp ( Request ( GET , \"/foobar\" ) . header ( \"Accepted\" , \"my-great-content/type\" )) }","title":"Monitoring http4k"},{"location":"cookbook/monitoring/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-metrics-micrometer\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/monitoring/#metrics-micrometer","text":"http4k provides module support for monitoring application endpoints using the micrometer metrics abstraction library, which currently enables support for libraries such as Graphite, StatsD, Prometheus and Netflix Atlas. This also provides drop-in classes to record stats such as JVM performance, GC and thread usage. package cookbook . monitoring import io.micrometer.core.instrument.simple.SimpleMeterRegistry import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.MetricFilters import org.http4k.routing.bind import org.http4k.routing.routes fun main () { // this is a micrometer registry used mostly for testing - substitute the correct implementation . val registry = SimpleMeterRegistry () val server = routes ( \"/metrics/{name}\" bind GET to { Response ( OK ) }) // apply filters to a server ... val app = MetricFilters . Server . RequestCounter ( registry ) . then ( MetricFilters . Server . RequestTimer ( registry )) . then ( server ) // ... or to a client val client = MetricFilters . Client . RequestCounter ( registry ) . then ( MetricFilters . Client . RequestTimer ( registry )) . then ( ApacheClient ()) // make some calls ( 0. . 10 ) . forEach { app ( Request ( GET , \"/metrics/$it\" )) client ( Request ( GET , \"https://http4k.org\" )) } // see some results registry . forEachMeter { println ( \"${it.id} ${it.measure().joinToString(\" , \")}\" ) } }","title":"Metrics (Micrometer) "},{"location":"cookbook/monitoring/#metrics-other-apis","text":"Alternatively, it's very easy to use a standard Filter to report on stats: package cookbook . monitoring import org.http4k.core.HttpHandler import org.http4k.core.HttpTransaction import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.HttpTransactionLabeller import org.http4k.filter.ResponseFilters import org.http4k.routing.bind import org.http4k.routing.routes import java.time.Duration fun main () { val app = routes ( \"foo/{name}\" bind { _ : Request -> Response ( OK ) }) fun metricConsumer ( name : String , time : Duration ) = println ( \"$name ${time.toMillis()}ms\" ) // this is a general use filter for reporting on http transactions val standardFilter = ResponseFilters . ReportHttpTransaction { tx : HttpTransaction -> metricConsumer ( \"txLabels are: ${tx.labels}\" , tx . duration ) metricConsumer ( \"uri is: ${tx.request.uri}\" , tx . duration ) } val addCustomLabels : HttpTransactionLabeller = { tx : HttpTransaction -> tx . label ( \"status\" , tx . response . status . code . toString ()) } val withCustomLabels = ResponseFilters . ReportHttpTransaction ( transactionLabeller = addCustomLabels ) { tx : HttpTransaction -> // send metrics to some custom system here ... println ( \"custom txLabels are: ${tx.labels} ${tx.duration}\" ) } // this filter provides an anonymous identifier of the route val identifiedRouteFilter = ResponseFilters . ReportRouteLatency { requestGroup : String , duration : Duration -> metricConsumer ( \"requestGroup is: \" + requestGroup , duration ) } val monitoredApp : HttpHandler = standardFilter . then ( withCustomLabels ) . then ( identifiedRouteFilter ) . then ( app ) monitoredApp ( Request ( GET , \"/foo/bob\" )) // prints ... // requestGroup is : GET . foo_ { name } . 2 xx . 200 7 ms // custom txLabels are : { routingGroup = foo / { name }, status = 200 } PT0 . 05 S // txLabels are : { routingGroup = foo / { name }} 51 ms // uri is : / foo / bob 51 ms }","title":"Metrics (other APIs) "},{"location":"cookbook/monitoring/#logging","text":"This is trivial to achieve by using a Filter: package cookbook . monitoring import org.http4k.core.HttpHandler import org.http4k.core.HttpTransaction import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResponseFilters import org.http4k.routing.bind import org.http4k.routing.routes import java.time.Clock fun main () { val app = routes ( \"/{name}\" bind { _ : Request -> Response ( OK ) }) fun logger ( message : String ) = println ( \"${Clock.systemUTC().instant()} $message\" ) val audit = ResponseFilters . ReportHttpTransaction { tx : HttpTransaction -> logger ( \"my call to ${tx.request.uri} returned ${tx.response.status} and took ${tx.duration.toMillis()}\" ) } val monitoredApp : HttpHandler = audit . then ( app ) monitoredApp ( Request ( GET , \"/foo\" )) // prints ... // 2017 - 12 - 04 T08 : 38 : 27.499 Z my call to / foo returned 200 OK and took 5 }","title":"Logging "},{"location":"cookbook/monitoring/#distributed-tracing","text":"This allows a chain of application calls to be tied together and is generally done through the setting of HTTP headers on each call. http4k supports the OpenZipkin standard for achieving this and provides both Server-side and Client-side Filters for this purpose. This example shows a chain of two proxies and an endpoint - run it to observe the changes to the tracing headers as the request flows through the system: package cookbook . monitoring import org.http4k.client.ApacheClient import org.http4k.core.HttpHandler import org.http4k.core.HttpMessage import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters import org.http4k.filter.ResponseFilters import org.http4k.filter.ServerFilters import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { fun HttpMessage . logHeader ( name : String ) = \" \\n\\t\\t $name=${header(name)}\" fun HttpMessage . traces () = logHeader ( \"x-b3-traceid\" ) + logHeader ( \"x-b3-spanid\" ) + logHeader ( \"x-b3-parentspanid\" ) fun audit ( name : String ) = ResponseFilters . ReportHttpTransaction { tx -> println ( \"$name: ${tx.request.uri} \\n\\t request:${tx.request.traces()} \\n\\t response:${tx.response.traces()}\" ) } // a simple proxy to another app fun proxy ( name : String , port : Int ): HttpHandler { val proxyClient = ClientFilters . RequestTracing () . then ( ClientFilters . SetHostFrom ( Uri . of ( \"http://localhost:$port\" ))) . then ( audit ( \"$name-client\" )) . then ( ApacheClient ()) return ServerFilters . RequestTracing () . then ( audit ( \"$name-server\" )) . then { proxyClient ( Request ( GET , it . uri )) } } // provides a simple ping fun ping (): HttpHandler = ServerFilters . RequestTracing () . then ( audit ( \"ping-server\" )) . then { Response ( OK ) . body ( \"pong\" ) } val proxy1 = proxy ( \"proxy1\" , 8001 ) . asServer ( SunHttp ( 8000 )) . start () val proxy2 = proxy ( \"proxy2\" , 8002 ) . asServer ( SunHttp ( 8001 )) . start () val server3 = ping () . asServer ( SunHttp ( 8002 )) . start () audit ( \"client\" ) . then ( ApacheClient ())( Request ( GET , \"http://localhost:8000/ping\" )) proxy1 . stop () proxy2 . stop () server3 . stop () }","title":"Distributed tracing "},{"location":"cookbook/monitoring/#debugging","text":"Easily wrap an HttpHandler in a debugging filter to check out what is going on under the covers: package cookbook . monitoring import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.DebuggingFilters fun main () { val app = { _ : Request -> Response ( OK ) . body ( \"hello there you look nice today\" ) } val debuggedApp = DebuggingFilters . PrintRequestAndResponse () . then ( app ) debuggedApp ( Request ( GET , \"/foobar\" ) . header ( \"Accepted\" , \"my-great-content/type\" )) }","title":"Debugging "},{"location":"cookbook/multipart_forms/","text":"Multipart form support is provided on 2 levels: Through the creation of a MultipartFormBody which can be set on a Request . Using the Lens system, which adds the facility to define form fields in a typesafe way, and to validate form contents (in either a strict (400) or \"feedback\" mode). Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-multipart\", version: \"3.247.0\" Standard (non-typesafe) API package cookbook . multipart_forms import org.http4k.client.ApacheClient import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.MultipartFormBody import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.lens.MultipartFormField import org.http4k.lens.MultipartFormFile import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { // extract the body from the request and then the fields / files from it val server = { r : Request -> val receivedForm = MultipartFormBody . from ( r ) println ( receivedForm . fieldValues ( \"field\" )) println ( receivedForm . field ( \"field2\" )) println ( receivedForm . files ( \"file\" )) Response ( OK ) } . asServer ( SunHttp ( 8000 )) . start () // add fields and files to the multipart form body val body = MultipartFormBody () . plus ( \"field\" to \"my-value\" ) . plus ( \"field2\" to MultipartFormField ( \"my-value2\" , listOf ( \"my-header\" to \"my-value\" ))) . plus ( \"file\" to MultipartFormFile ( \"image.txt\" , ContentType . OCTET_STREAM , \"somebinarycontent\" . byteInputStream ())) // we need to set both the body AND the correct content type header on the the request val request = Request ( POST , \"http://localhost:8000\" ) . header ( \"content-type\" , \"multipart/form-data; boundary=${body.boundary}\" ) . body ( body ) println ( ApacheClient ()( request )) server . stop () } Lens (typesafe, validating) API - reads ALL contents onto disk/memory package cookbook . multipart_forms import org.http4k.client.ApacheClient import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.MultipartForm import org.http4k.lens.MultipartFormField import org.http4k.lens.MultipartFormFile import org.http4k.lens.Validator import org.http4k.lens.multipartForm import org.http4k.server.SunHttp import org.http4k.server.asServer data class Name ( val value : String ) fun main () { // define fields using the standard lens syntax val nameField = MultipartFormField . string () . map (:: Name , Name :: value ) . required ( \"name\" ) val imageFile = MultipartFormFile . optional ( \"image\" ) // add fields to a form definition , along with a validator val strictFormBody = Body . multipartForm ( Validator . Strict , nameField , imageFile , diskThreshold = 5 ) . toLens () val server = ServerFilters . CatchAll () . then { r : Request -> // to extract the contents , we first extract the form and then extract the fields from it using the lenses // NOTE : we are \"using\" the form body here because we want to close the underlying file streams strictFormBody ( r ) . use { println ( nameField ( it )) println ( imageFile ( it )) } Response ( OK ) } . asServer ( SunHttp ( 8000 )) . start () // creating valid form using \"with()\" and setting it onto the request . The content type and boundary are // taken care of automatically val multipartform = MultipartForm () . with ( nameField of Name ( \"rita\" ), imageFile of MultipartFormFile ( \"image.txt\" , ContentType . OCTET_STREAM , \"somebinarycontent\" . byteInputStream ())) val validRequest = Request ( POST , \"http://localhost:8000\" ) . with ( strictFormBody of multipartform ) println ( ApacheClient ()( validRequest )) server . stop () } Streaming - iterate over Multiparts package cookbook . multipart_forms import org.http4k.client.ApacheClient import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.MultipartEntity import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.multipartIterator import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.MultipartForm import org.http4k.lens.MultipartFormField import org.http4k.lens.MultipartFormFile import org.http4k.lens.Validator import org.http4k.lens.multipartForm import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { val server = ServerFilters . CatchAll () . then { r : Request -> // here we are iterating over the multiparts as we read them out of the input val fields = r . multipartIterator () . asSequence () . fold ( emptyList < MultipartEntity . Field > ()) { memo , next -> when ( next ) { is MultipartEntity . File -> { // do something with the file right here ... like stream it to another server memo } is MultipartEntity . Field -> memo . plus ( next ) } } println ( fields ) Response ( OK ) } . asServer ( SunHttp ( 8000 )) . start () println ( ApacheClient ()( buildMultipartRequest ())) server . stop () } private fun buildMultipartRequest (): Request { // define fields using the standard lens syntax val nameField = MultipartFormField . string () . map (:: Name , Name :: value ) . required ( \"name\" ) val imageFile = MultipartFormFile . optional ( \"image\" ) // add fields to a form definition , along with a validator val strictFormBody = Body . multipartForm ( Validator . Strict , nameField , imageFile , diskThreshold = 5 ) . toLens () val multipartform = MultipartForm () . with ( nameField of Name ( \"rita\" ), imageFile of MultipartFormFile ( \"image.txt\" , ContentType . OCTET_STREAM , \"somebinarycontent\" . byteInputStream ())) val validRequest = Request ( POST , \"http://localhost:8000\" ) . with ( strictFormBody of multipartform ) return validRequest } Processing Files with a Filter and convert to standard form package cookbook . multipart_forms import org.http4k.client.ApacheClient import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.MultipartEntity import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ProcessFiles import org.http4k.filter.ServerFilters import org.http4k.lens.FormField import org.http4k.lens.MultipartForm import org.http4k.lens.MultipartFormField import org.http4k.lens.MultipartFormFile import org.http4k.lens.Validator import org.http4k.lens.multipartForm import org.http4k.lens.webForm import org.http4k.server.SunHttp import org.http4k.server.asServer data class AName ( val value : String ) fun main () { val server = ServerFilters . ProcessFiles { multipartFile : MultipartEntity . File -> // do something with the file right here ... like stream it to another server and return the reference println ( String ( multipartFile . file . content . readBytes ())) multipartFile . file . filename } . then { req : Request -> // this is the web - form definition - it it DIFFERENT to the multipart form definition , // because the fields and content - type have been replaced in the ProcessFiles filter val nameField = FormField . map (:: AName , AName :: value ) . required ( \"name\" ) val imageFile = FormField . optional ( \"image\" ) val body = Body . webForm ( Validator . Strict , nameField , imageFile ) . toLens () println ( body ( req )) Response ( OK ) } . asServer ( SunHttp ( 8000 )) . start () println ( ApacheClient ()( buildValidMultipartRequest ())) server . stop () } private fun buildValidMultipartRequest (): Request { // define fields using the standard lens syntax val nameField = MultipartFormField . string () . map (:: AName , AName :: value ) . required ( \"name\" ) val imageFile = MultipartFormFile . optional ( \"image\" ) // add fields to a form definition , along with a validator val strictFormBody = Body . multipartForm ( Validator . Strict , nameField , imageFile , diskThreshold = 5 ) . toLens () val multipartform = MultipartForm () . with ( nameField of AName ( \"rita\" ), imageFile of MultipartFormFile ( \"image.txt\" , ContentType . OCTET_STREAM , \"somebinarycontent\" . byteInputStream ())) return Request ( POST , \"http://localhost:8000\" ) . with ( strictFormBody of multipartform ) }","title":"Multipart forms"},{"location":"cookbook/multipart_forms/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-multipart\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/multipart_forms/#standard-non-typesafe-api","text":"package cookbook . multipart_forms import org.http4k.client.ApacheClient import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.MultipartFormBody import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.lens.MultipartFormField import org.http4k.lens.MultipartFormFile import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { // extract the body from the request and then the fields / files from it val server = { r : Request -> val receivedForm = MultipartFormBody . from ( r ) println ( receivedForm . fieldValues ( \"field\" )) println ( receivedForm . field ( \"field2\" )) println ( receivedForm . files ( \"file\" )) Response ( OK ) } . asServer ( SunHttp ( 8000 )) . start () // add fields and files to the multipart form body val body = MultipartFormBody () . plus ( \"field\" to \"my-value\" ) . plus ( \"field2\" to MultipartFormField ( \"my-value2\" , listOf ( \"my-header\" to \"my-value\" ))) . plus ( \"file\" to MultipartFormFile ( \"image.txt\" , ContentType . OCTET_STREAM , \"somebinarycontent\" . byteInputStream ())) // we need to set both the body AND the correct content type header on the the request val request = Request ( POST , \"http://localhost:8000\" ) . header ( \"content-type\" , \"multipart/form-data; boundary=${body.boundary}\" ) . body ( body ) println ( ApacheClient ()( request )) server . stop () }","title":"Standard (non-typesafe) API "},{"location":"cookbook/multipart_forms/#lens-typesafe-validating-api-reads-all-contents-onto-diskmemory","text":"package cookbook . multipart_forms import org.http4k.client.ApacheClient import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.MultipartForm import org.http4k.lens.MultipartFormField import org.http4k.lens.MultipartFormFile import org.http4k.lens.Validator import org.http4k.lens.multipartForm import org.http4k.server.SunHttp import org.http4k.server.asServer data class Name ( val value : String ) fun main () { // define fields using the standard lens syntax val nameField = MultipartFormField . string () . map (:: Name , Name :: value ) . required ( \"name\" ) val imageFile = MultipartFormFile . optional ( \"image\" ) // add fields to a form definition , along with a validator val strictFormBody = Body . multipartForm ( Validator . Strict , nameField , imageFile , diskThreshold = 5 ) . toLens () val server = ServerFilters . CatchAll () . then { r : Request -> // to extract the contents , we first extract the form and then extract the fields from it using the lenses // NOTE : we are \"using\" the form body here because we want to close the underlying file streams strictFormBody ( r ) . use { println ( nameField ( it )) println ( imageFile ( it )) } Response ( OK ) } . asServer ( SunHttp ( 8000 )) . start () // creating valid form using \"with()\" and setting it onto the request . The content type and boundary are // taken care of automatically val multipartform = MultipartForm () . with ( nameField of Name ( \"rita\" ), imageFile of MultipartFormFile ( \"image.txt\" , ContentType . OCTET_STREAM , \"somebinarycontent\" . byteInputStream ())) val validRequest = Request ( POST , \"http://localhost:8000\" ) . with ( strictFormBody of multipartform ) println ( ApacheClient ()( validRequest )) server . stop () }","title":"Lens (typesafe, validating) API - reads ALL contents onto disk/memory "},{"location":"cookbook/multipart_forms/#streaming-iterate-over-multiparts","text":"package cookbook . multipart_forms import org.http4k.client.ApacheClient import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.MultipartEntity import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.multipartIterator import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.MultipartForm import org.http4k.lens.MultipartFormField import org.http4k.lens.MultipartFormFile import org.http4k.lens.Validator import org.http4k.lens.multipartForm import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { val server = ServerFilters . CatchAll () . then { r : Request -> // here we are iterating over the multiparts as we read them out of the input val fields = r . multipartIterator () . asSequence () . fold ( emptyList < MultipartEntity . Field > ()) { memo , next -> when ( next ) { is MultipartEntity . File -> { // do something with the file right here ... like stream it to another server memo } is MultipartEntity . Field -> memo . plus ( next ) } } println ( fields ) Response ( OK ) } . asServer ( SunHttp ( 8000 )) . start () println ( ApacheClient ()( buildMultipartRequest ())) server . stop () } private fun buildMultipartRequest (): Request { // define fields using the standard lens syntax val nameField = MultipartFormField . string () . map (:: Name , Name :: value ) . required ( \"name\" ) val imageFile = MultipartFormFile . optional ( \"image\" ) // add fields to a form definition , along with a validator val strictFormBody = Body . multipartForm ( Validator . Strict , nameField , imageFile , diskThreshold = 5 ) . toLens () val multipartform = MultipartForm () . with ( nameField of Name ( \"rita\" ), imageFile of MultipartFormFile ( \"image.txt\" , ContentType . OCTET_STREAM , \"somebinarycontent\" . byteInputStream ())) val validRequest = Request ( POST , \"http://localhost:8000\" ) . with ( strictFormBody of multipartform ) return validRequest }","title":"Streaming - iterate over Multiparts "},{"location":"cookbook/multipart_forms/#processing-files-with-a-filter-and-convert-to-standard-form","text":"package cookbook . multipart_forms import org.http4k.client.ApacheClient import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.MultipartEntity import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ProcessFiles import org.http4k.filter.ServerFilters import org.http4k.lens.FormField import org.http4k.lens.MultipartForm import org.http4k.lens.MultipartFormField import org.http4k.lens.MultipartFormFile import org.http4k.lens.Validator import org.http4k.lens.multipartForm import org.http4k.lens.webForm import org.http4k.server.SunHttp import org.http4k.server.asServer data class AName ( val value : String ) fun main () { val server = ServerFilters . ProcessFiles { multipartFile : MultipartEntity . File -> // do something with the file right here ... like stream it to another server and return the reference println ( String ( multipartFile . file . content . readBytes ())) multipartFile . file . filename } . then { req : Request -> // this is the web - form definition - it it DIFFERENT to the multipart form definition , // because the fields and content - type have been replaced in the ProcessFiles filter val nameField = FormField . map (:: AName , AName :: value ) . required ( \"name\" ) val imageFile = FormField . optional ( \"image\" ) val body = Body . webForm ( Validator . Strict , nameField , imageFile ) . toLens () println ( body ( req )) Response ( OK ) } . asServer ( SunHttp ( 8000 )) . start () println ( ApacheClient ()( buildValidMultipartRequest ())) server . stop () } private fun buildValidMultipartRequest (): Request { // define fields using the standard lens syntax val nameField = MultipartFormField . string () . map (:: AName , AName :: value ) . required ( \"name\" ) val imageFile = MultipartFormFile . optional ( \"image\" ) // add fields to a form definition , along with a validator val strictFormBody = Body . multipartForm ( Validator . Strict , nameField , imageFile , diskThreshold = 5 ) . toLens () val multipartform = MultipartForm () . with ( nameField of AName ( \"rita\" ), imageFile of MultipartFormFile ( \"image.txt\" , ContentType . OCTET_STREAM , \"somebinarycontent\" . byteInputStream ())) return Request ( POST , \"http://localhost:8000\" ) . with ( strictFormBody of multipartform ) }","title":"Processing Files with a Filter and convert to standard form "},{"location":"cookbook/nanoservices/","text":"http4k is a small library with minimal dependencies, but what you can accomplish with just a single line of code is quite remarkable due to a combination of the available modules and the Server as a Function concept. The main code of the following http4k applications (in the appropriately named function) all fit in a tweet (140 characters)... exports excluded ;) Simple Proxy Requires: http4k-core This simple proxy converts HTTP requests to HTTPS. Because of the symmetrical server/client HttpHandler signature, we can simply mount an HTTP client onto a Server, then add a ProxyHost filter to do the protocol conversion. package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.server.SunHttp import org.http4k.server.asServer import java.lang.System.setProperty fun `simple proxy` () = ProxyHost ( Https ) . then ( JavaHttpClient ()) . asServer ( SunHttp ()) . start () fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `simple proxy` () . use { println ( JavaHttpClient ()( Request ( GET , \"http://github.com/\" ))) } } Latency Reporting Proxy Requires: http4k-core Building on the Simple Proxy example, we can simply layer on extra filters to add features to the proxy, in this case reporting the latency of each call. package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.filter.ResponseFilters.ReportRouteLatency import org.http4k.server.SunHttp import org.http4k.server.asServer import java.lang.System.setProperty fun `latency reporting proxy` () = ProxyHost ( Https ) . then ( ReportRouteLatency { req , ms -> println ( \"$req took $ms\" ) }) . then ( JavaHttpClient ()) . asServer ( SunHttp ()) . start () fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `latency reporting proxy` () . use { JavaHttpClient ()( Request ( GET , \"http://github.com/\" )) } } Wire-sniffing Proxy Requires: http4k-core Applying a DebuggingFilter to the HTTP calls in a proxy dumps the entire contents out to StdOut (or other stream). package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.DebuggingFilters.PrintRequestAndResponse import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.server.SunHttp import org.http4k.server.asServer import java.lang.System.setProperty fun `wire sniffing proxy` () = ProxyHost ( Https ) . then ( PrintRequestAndResponse ()) . then ( JavaHttpClient ()) . asServer ( SunHttp ()) . start () fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `wire sniffing proxy` () . use { JavaHttpClient ()( Request ( GET , \"http://github.com/http4k\" )) } } Traffic Recording Proxy & Replayer Requires: http4k-core This example contains two apps. The first is a proxy which captures streams of traffic and records it to a directory on disk. The second app is configured to replay the requests from that disk store at the original server. This kind of traffic capture/replay is very useful for load testing or for tracking down hard-to-diagnose bugs - and it's easy to write other other stores such as an S3 bucket etc. package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.filter.TrafficFilters.RecordTo import org.http4k.server.SunHttp import org.http4k.server.asServer import org.http4k.traffic.ReadWriteStream.Companion.Disk import java.lang.System.setProperty fun `recording traffic to disk proxy` () = ProxyHost ( Https ) . then ( RecordTo ( Disk ( \"store\" ))) . then ( JavaHttpClient ()) . asServer ( SunHttp ()) . start () fun `replay previously recorded traffic from a disk store` () = JavaHttpClient () . let { client -> Disk ( \"store\" ) . requests () . forEach { println ( it ) client ( it ) } } fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `recording traffic to disk proxy` () . use { JavaHttpClient ()( Request ( GET , \"http://github.com/\" )) JavaHttpClient ()( Request ( GET , \"http://github.com/http4k\" )) JavaHttpClient ()( Request ( GET , \"http://github.com/http4k/http4k\" )) } `replay previously recorded traffic from a disk store` () } Static file Server Requires: http4k-core Longer than the Python SimpleHttpServer , but still pretty small! package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.routing.ResourceLoader.Companion.Directory import org.http4k.routing.static import org.http4k.server.SunHttp import org.http4k.server.asServer fun `static file server` () = static ( Directory ()) . asServer ( SunHttp ()) . start () fun main () { `static file server` () . use { // by default , static servers will only serve known file types , or those registered on construction println ( JavaHttpClient ()( Request ( GET , \"http://localhost:8000/version.json\" ))) } } Websocket Clock Requires: http4k-core , http4k-server-jetty Like Http handlers, Websockets in http4k can be modelled as simple functions that can be mounted onto a Server, or combined with path patterns if required. package cookbook . nanoservices import org.http4k.client.WebsocketClient import org.http4k.core.Uri import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.Websocket import org.http4k.websocket.WsMessage import java.time.Instant fun `ticking websocket clock` () = { ws : Websocket -> while ( true ) { ws . send ( WsMessage ( Instant . now () . toString ())) Thread . sleep ( 1000 ) } } . asServer ( Jetty ()) . start () fun main () { `ticking websocket clock` () WebsocketClient . nonBlocking ( Uri . of ( \"http://localhost:8000\" )) . onMessage { println ( it ) } } Chaos Proxy (random latency edition) Requires: http4k-core , http4k-testing-chaos As per the Principles of Chaos , this proxy adds Chaotic behaviour to a remote service, which is useful for modelling how a system might behave under various failure modes. Chaos can be dynamically injected via an OpenApi documented set of RPC endpoints. package cookbook . nanoservices import org.http4k.chaos.ChaosBehaviours.Latency import org.http4k.chaos.ChaosEngine import org.http4k.chaos.withChaosApi import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.server.SunHttp import org.http4k.server.asServer import java.lang.System.setProperty fun `latency injection proxy (between 100ms-500ms)` () = ProxyHost ( Https ) . then ( JavaHttpClient ()) . withChaosApi ( ChaosEngine ( Latency ()) . enable ()) . asServer ( SunHttp ()) . start () fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `latency injection proxy (between 100ms-500ms)` () . use { println ( JavaHttpClient ()( Request ( POST , \"http://localhost:8000/chaos/activate\" ))) println ( JavaHttpClient ()( Request ( GET , \"http://github.com/\" )) . header ( \"X-http4k-chaos\" )) } }","title":"Nanoservices"},{"location":"cookbook/nanoservices/#simple-proxy","text":"Requires: http4k-core This simple proxy converts HTTP requests to HTTPS. Because of the symmetrical server/client HttpHandler signature, we can simply mount an HTTP client onto a Server, then add a ProxyHost filter to do the protocol conversion. package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.server.SunHttp import org.http4k.server.asServer import java.lang.System.setProperty fun `simple proxy` () = ProxyHost ( Https ) . then ( JavaHttpClient ()) . asServer ( SunHttp ()) . start () fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `simple proxy` () . use { println ( JavaHttpClient ()( Request ( GET , \"http://github.com/\" ))) } }","title":"Simple Proxy "},{"location":"cookbook/nanoservices/#latency-reporting-proxy","text":"Requires: http4k-core Building on the Simple Proxy example, we can simply layer on extra filters to add features to the proxy, in this case reporting the latency of each call. package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.filter.ResponseFilters.ReportRouteLatency import org.http4k.server.SunHttp import org.http4k.server.asServer import java.lang.System.setProperty fun `latency reporting proxy` () = ProxyHost ( Https ) . then ( ReportRouteLatency { req , ms -> println ( \"$req took $ms\" ) }) . then ( JavaHttpClient ()) . asServer ( SunHttp ()) . start () fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `latency reporting proxy` () . use { JavaHttpClient ()( Request ( GET , \"http://github.com/\" )) } }","title":"Latency Reporting Proxy "},{"location":"cookbook/nanoservices/#wire-sniffing-proxy","text":"Requires: http4k-core Applying a DebuggingFilter to the HTTP calls in a proxy dumps the entire contents out to StdOut (or other stream). package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.DebuggingFilters.PrintRequestAndResponse import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.server.SunHttp import org.http4k.server.asServer import java.lang.System.setProperty fun `wire sniffing proxy` () = ProxyHost ( Https ) . then ( PrintRequestAndResponse ()) . then ( JavaHttpClient ()) . asServer ( SunHttp ()) . start () fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `wire sniffing proxy` () . use { JavaHttpClient ()( Request ( GET , \"http://github.com/http4k\" )) } }","title":"Wire-sniffing Proxy "},{"location":"cookbook/nanoservices/#traffic-recording-proxy-replayer","text":"Requires: http4k-core This example contains two apps. The first is a proxy which captures streams of traffic and records it to a directory on disk. The second app is configured to replay the requests from that disk store at the original server. This kind of traffic capture/replay is very useful for load testing or for tracking down hard-to-diagnose bugs - and it's easy to write other other stores such as an S3 bucket etc. package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.filter.TrafficFilters.RecordTo import org.http4k.server.SunHttp import org.http4k.server.asServer import org.http4k.traffic.ReadWriteStream.Companion.Disk import java.lang.System.setProperty fun `recording traffic to disk proxy` () = ProxyHost ( Https ) . then ( RecordTo ( Disk ( \"store\" ))) . then ( JavaHttpClient ()) . asServer ( SunHttp ()) . start () fun `replay previously recorded traffic from a disk store` () = JavaHttpClient () . let { client -> Disk ( \"store\" ) . requests () . forEach { println ( it ) client ( it ) } } fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `recording traffic to disk proxy` () . use { JavaHttpClient ()( Request ( GET , \"http://github.com/\" )) JavaHttpClient ()( Request ( GET , \"http://github.com/http4k\" )) JavaHttpClient ()( Request ( GET , \"http://github.com/http4k/http4k\" )) } `replay previously recorded traffic from a disk store` () }","title":"Traffic Recording Proxy &amp; Replayer "},{"location":"cookbook/nanoservices/#static-file-server","text":"Requires: http4k-core Longer than the Python SimpleHttpServer , but still pretty small! package cookbook . nanoservices import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.routing.ResourceLoader.Companion.Directory import org.http4k.routing.static import org.http4k.server.SunHttp import org.http4k.server.asServer fun `static file server` () = static ( Directory ()) . asServer ( SunHttp ()) . start () fun main () { `static file server` () . use { // by default , static servers will only serve known file types , or those registered on construction println ( JavaHttpClient ()( Request ( GET , \"http://localhost:8000/version.json\" ))) } }","title":"Static file Server "},{"location":"cookbook/nanoservices/#websocket-clock","text":"Requires: http4k-core , http4k-server-jetty Like Http handlers, Websockets in http4k can be modelled as simple functions that can be mounted onto a Server, or combined with path patterns if required. package cookbook . nanoservices import org.http4k.client.WebsocketClient import org.http4k.core.Uri import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.Websocket import org.http4k.websocket.WsMessage import java.time.Instant fun `ticking websocket clock` () = { ws : Websocket -> while ( true ) { ws . send ( WsMessage ( Instant . now () . toString ())) Thread . sleep ( 1000 ) } } . asServer ( Jetty ()) . start () fun main () { `ticking websocket clock` () WebsocketClient . nonBlocking ( Uri . of ( \"http://localhost:8000\" )) . onMessage { println ( it ) } }","title":"Websocket Clock "},{"location":"cookbook/nanoservices/#chaos-proxy-random-latency-edition","text":"Requires: http4k-core , http4k-testing-chaos As per the Principles of Chaos , this proxy adds Chaotic behaviour to a remote service, which is useful for modelling how a system might behave under various failure modes. Chaos can be dynamically injected via an OpenApi documented set of RPC endpoints. package cookbook . nanoservices import org.http4k.chaos.ChaosBehaviours.Latency import org.http4k.chaos.ChaosEngine import org.http4k.chaos.withChaosApi import org.http4k.client.JavaHttpClient import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.then import org.http4k.filter.RequestFilters.ProxyHost import org.http4k.filter.RequestFilters.ProxyProtocolMode.Https import org.http4k.server.SunHttp import org.http4k.server.asServer import java.lang.System.setProperty fun `latency injection proxy (between 100ms-500ms)` () = ProxyHost ( Https ) . then ( JavaHttpClient ()) . withChaosApi ( ChaosEngine ( Latency ()) . enable ()) . asServer ( SunHttp ()) . start () fun main () { setProperty ( \"http.proxyHost\" , \"localhost\" ) setProperty ( \"http.proxyPort\" , \"8000\" ) setProperty ( \"http.nonProxyHosts\" , \"localhost\" ) `latency injection proxy (between 100ms-500ms)` () . use { println ( JavaHttpClient ()( Request ( POST , \"http://localhost:8000/chaos/activate\" ))) println ( JavaHttpClient ()( Request ( GET , \"http://github.com/\" )) . header ( \"X-http4k-chaos\" )) } }","title":"Chaos Proxy (random latency edition) "},{"location":"cookbook/nestable_routes/","text":"This is a fairly comprehensive example of the core-routing logic available: Individual HTTP endpoints are represented as HttpHandlers . Binding an HttpHandler to a path and HTTP verb yields a Route . Routes can be combined together into a RoutingHttpHandler , which is both an HttpHandler and a Router . A Router is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next Router in the list. Routers can be combined together to form another HttpHandler Usage of supplied core library Filters Serving of static content using a Classpath resource loader Support for Single Page Applications using a singlePageApp() block - resources loaded from here are loaded from the underlying ResourceLoader or fallback to / (and passed to the SPA code) Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Code package cookbook . nestable_routes import org.http4k.core.Method.DELETE import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.DebuggingFilters.PrintRequestAndResponse import org.http4k.routing.ResourceLoader.Companion.Classpath import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.http4k.routing.singlePageApp import org.http4k.routing.static fun main () { val routesWithFilter = PrintRequestAndResponse () . then ( routes ( \"/get/{name}\" bind GET to { req : Request -> Response ( OK ) . body ( req . path ( \"name\" ) !! ) }, \"/post/{name}\" bind POST to { _ : Request -> Response ( OK ) } ) ) println ( routesWithFilter ( Request ( GET , \"/get/value\" ))) val staticWithFilter = PrintRequestAndResponse () . then ( static ( Classpath ( \"cookbook/nestable_routes\" ))) val app = routes ( \"/bob\" bind routesWithFilter , \"/static\" bind staticWithFilter , \"/rita\" bind routes ( \"/delete/{name}\" bind DELETE to { _ : Request -> Response ( OK ) }, \"/post/{name}\" bind POST to { _ : Request -> Response ( OK ) } ), singlePageApp ( Classpath ( \"cookbook/nestable_routes\" )) ) println ( app ( Request ( GET , \"/bob/get/value\" ))) println ( app ( Request ( GET , \"/static/someStaticFile.txt\" ))) println ( app ( Request ( GET , \"/someSpaResource\" ))) }","title":"Nestable routes"},{"location":"cookbook/nestable_routes/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/nestable_routes/#code","text":"package cookbook . nestable_routes import org.http4k.core.Method.DELETE import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.DebuggingFilters.PrintRequestAndResponse import org.http4k.routing.ResourceLoader.Companion.Classpath import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.http4k.routing.singlePageApp import org.http4k.routing.static fun main () { val routesWithFilter = PrintRequestAndResponse () . then ( routes ( \"/get/{name}\" bind GET to { req : Request -> Response ( OK ) . body ( req . path ( \"name\" ) !! ) }, \"/post/{name}\" bind POST to { _ : Request -> Response ( OK ) } ) ) println ( routesWithFilter ( Request ( GET , \"/get/value\" ))) val staticWithFilter = PrintRequestAndResponse () . then ( static ( Classpath ( \"cookbook/nestable_routes\" ))) val app = routes ( \"/bob\" bind routesWithFilter , \"/static\" bind staticWithFilter , \"/rita\" bind routes ( \"/delete/{name}\" bind DELETE to { _ : Request -> Response ( OK ) }, \"/post/{name}\" bind POST to { _ : Request -> Response ( OK ) } ), singlePageApp ( Classpath ( \"cookbook/nestable_routes\" )) ) println ( app ( Request ( GET , \"/bob/get/value\" ))) println ( app ( Request ( GET , \"/static/someStaticFile.txt\" ))) println ( app ( Request ( GET , \"/someSpaResource\" ))) }","title":"Code "},{"location":"cookbook/principal_lookup/","text":"Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" When authorising requests, it is common to need to store some credentials or a user principal object to be accessible by a further Filter or the eventual HttpHandler. This can be easily achieved by combining the typesafe RequestContext functionality with one of the built-in authorisation Filters: Code package cookbook . principal_lookup import org.http4k.core.Credentials import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.RequestContexts import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ServerFilters.BearerAuth import org.http4k.filter.ServerFilters.InitialiseRequestContext import org.http4k.lens.RequestContextKey fun main () { val contexts = RequestContexts () val credentials = RequestContextKey . required < Credentials > ( contexts ) val app = InitialiseRequestContext ( contexts ) . then ( BearerAuth ( credentials ) { if ( it == \"42\" ) Credentials ( \"user\" , \"pass\" ) else null }) . then { Response ( OK ) . body ( credentials ( it ) . toString ()) } println ( app ( Request ( GET , \"/\" ) . header ( \"Authorization\" , \"Bearer 41\" ))) println ( app ( Request ( GET , \"/\" ) . header ( \"Authorization\" , \"Bearer 42\" ))) }","title":"Principal lookup"},{"location":"cookbook/principal_lookup/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" When authorising requests, it is common to need to store some credentials or a user principal object to be accessible by a further Filter or the eventual HttpHandler. This can be easily achieved by combining the typesafe RequestContext functionality with one of the built-in authorisation Filters:","title":"Gradle setup"},{"location":"cookbook/principal_lookup/#code","text":"package cookbook . principal_lookup import org.http4k.core.Credentials import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.RequestContexts import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ServerFilters.BearerAuth import org.http4k.filter.ServerFilters.InitialiseRequestContext import org.http4k.lens.RequestContextKey fun main () { val contexts = RequestContexts () val credentials = RequestContextKey . required < Credentials > ( contexts ) val app = InitialiseRequestContext ( contexts ) . then ( BearerAuth ( credentials ) { if ( it == \"42\" ) Credentials ( \"user\" , \"pass\" ) else null }) . then { Response ( OK ) . body ( credentials ( it ) . toString ()) } println ( app ( Request ( GET , \"/\" ) . header ( \"Authorization\" , \"Bearer 41\" ))) println ( app ( Request ( GET , \"/\" ) . header ( \"Authorization\" , \"Bearer 42\" ))) }","title":"Code "},{"location":"cookbook/record_and_replay/","text":"A set of classes to provide simple recording/replaying of HTTP traffic. This is perfect for testing purposes, or in short lived, low traffic environments where no proper caches are available. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Caching HTTP Traffic Using Filters it's possible to record traffic and then return recorded content instead of making repeated calls. Note that the provided storage implementations DO NOT have any facility for Cache Control or eviction, or respect any response headers around caching. Requests are indexed in a way optimised for retrieval. Code package cookbook . record_and_replay import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.TrafficFilters import org.http4k.traffic.ReadWriteCache fun main () { // set up storage to cache a set of HTTP traffic . Disk and Memory implementations are provided . val storage = ReadWriteCache . Disk () // wrap any HTTP Handler in a Recording Filter and play traffic through it val withCachedContent = TrafficFilters . ServeCachedFrom ( storage ) . then { Response ( OK ) . body ( \"hello world\" ) } val aRequest = Request ( GET , \"http://localhost:8000/\" ) withCachedContent ( aRequest ) // repeated requests are intercepted by the cache and the responses provided without hitting the original handler println ( withCachedContent ( Request ( GET , \"http://localhost:8000/\" ))) } Recording Streams of HTTP Traffic Using Filters it's possible to record a stream traffic and then replay recorded content instead. Requests are indexed in a way optimised for iteration. Code package cookbook . record_and_replay import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.TrafficFilters import org.http4k.traffic.ReadWriteStream import org.http4k.traffic.Responder fun main () { // set up storage to stash a stream of HTTP traffic . Disk and Memory implementations are provided . val storage = ReadWriteStream . Memory () // wrap any HTTP Handler in a Recording Filter and play traffic through it val recording = TrafficFilters . RecordTo ( storage ) . then { Response ( OK ) . body ( \"hello world\" ) } recording ( Request ( GET , \"http://localhost:8000/\" )) // now set up a responder val handler = Responder . from ( storage ) // the responder will replay the responses in order println ( handler ( Request ( GET , \"http://localhost:8000/\" ))) // we can also replay a series of requests through a real HTTP client val client = ApacheClient () storage . requests () . forEach { println ( client ( it )) } } Concepts The org.http4k.traffic package contains the interfaces which make up the core concepts for traffic capture and replay. These interfaces are: A Sink consumes request/response pairs for storage. A Source provides lookup of pre-stored Response based on an HTTP Request. Replay instances provide streams of HTTP messages as they were received. A ReadWriteCache combines Sink and Source to provide cache-like storage. A ReadWriteStream combines Sink and Replay to provide a stream of traffic which can be replayed. The API has been designed to be modular so API users can provide their own implementations (store in S3 etc..).","title":"Recording/replaying HTTP traffic"},{"location":"cookbook/record_and_replay/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/record_and_replay/#caching-http-traffic","text":"Using Filters it's possible to record traffic and then return recorded content instead of making repeated calls. Note that the provided storage implementations DO NOT have any facility for Cache Control or eviction, or respect any response headers around caching. Requests are indexed in a way optimised for retrieval.","title":"Caching HTTP Traffic"},{"location":"cookbook/record_and_replay/#code","text":"package cookbook . record_and_replay import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.TrafficFilters import org.http4k.traffic.ReadWriteCache fun main () { // set up storage to cache a set of HTTP traffic . Disk and Memory implementations are provided . val storage = ReadWriteCache . Disk () // wrap any HTTP Handler in a Recording Filter and play traffic through it val withCachedContent = TrafficFilters . ServeCachedFrom ( storage ) . then { Response ( OK ) . body ( \"hello world\" ) } val aRequest = Request ( GET , \"http://localhost:8000/\" ) withCachedContent ( aRequest ) // repeated requests are intercepted by the cache and the responses provided without hitting the original handler println ( withCachedContent ( Request ( GET , \"http://localhost:8000/\" ))) }","title":"Code "},{"location":"cookbook/record_and_replay/#recording-streams-of-http-traffic","text":"Using Filters it's possible to record a stream traffic and then replay recorded content instead. Requests are indexed in a way optimised for iteration.","title":"Recording Streams of HTTP Traffic"},{"location":"cookbook/record_and_replay/#code_1","text":"package cookbook . record_and_replay import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.TrafficFilters import org.http4k.traffic.ReadWriteStream import org.http4k.traffic.Responder fun main () { // set up storage to stash a stream of HTTP traffic . Disk and Memory implementations are provided . val storage = ReadWriteStream . Memory () // wrap any HTTP Handler in a Recording Filter and play traffic through it val recording = TrafficFilters . RecordTo ( storage ) . then { Response ( OK ) . body ( \"hello world\" ) } recording ( Request ( GET , \"http://localhost:8000/\" )) // now set up a responder val handler = Responder . from ( storage ) // the responder will replay the responses in order println ( handler ( Request ( GET , \"http://localhost:8000/\" ))) // we can also replay a series of requests through a real HTTP client val client = ApacheClient () storage . requests () . forEach { println ( client ( it )) } }","title":"Code "},{"location":"cookbook/record_and_replay/#concepts","text":"The org.http4k.traffic package contains the interfaces which make up the core concepts for traffic capture and replay. These interfaces are: A Sink consumes request/response pairs for storage. A Source provides lookup of pre-stored Response based on an HTTP Request. Replay instances provide streams of HTTP messages as they were received. A ReadWriteCache combines Sink and Source to provide cache-like storage. A ReadWriteStream combines Sink and Replay to provide a stream of traffic which can be replayed. The API has been designed to be modular so API users can provide their own implementations (store in S3 etc..).","title":"Concepts"},{"location":"cookbook/request_context/","text":"A RequestContext makes it possible to attach objects to a request whilst it is being passed down through the layers of an application. The basic concept is that there is a global shared object which holds a bag of state (indexed by Request). This state can be modified in Filters and then that state accessed inside other Filters or the terminating HttpHandler. There are 2 available choices for manipulating this data: Using simple Strings to represent the keys. Using RequestContextKey s and the Lens mechanism from the http4k-core module. Whilst the first method looks technically simpler, the use of simple Strings does not provide the type-safety of the second, which uses unique shared Key objects to guarantee non-clashing of keys and type-safety of the state. Regardless of which of the above mechanisms are used, an instance of the ServerFilters.InitialiseRequestContext Filter must wrap the HttpHandler(s) to activate the shared bag of state for each request, and to remove the state after the request is complete. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" String-based keys package cookbook . request_context import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.RequestContexts import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ServerFilters fun main () { data class SharedState ( val message : String ) fun AddState ( contexts : RequestContexts ) = Filter { next -> { contexts [ it ][ \"myKey\" ] = SharedState ( \"hello there\" ) next ( it ) } } fun PrintState ( contexts : RequestContexts ): HttpHandler = { request -> val message : SharedState ? = contexts [ request ][ \"myKey\" ] println ( message ) Response ( OK ) } // this is the shared RequestContexts object - it holds the bag of state for each request and // tidies up afterwards val contexts = RequestContexts () // The first Filter is required to initialise the bag of state . // The second Filter modifies the bag // The handler just prints out the state val app = ServerFilters . InitialiseRequestContext ( contexts ) . then ( AddState ( contexts )) . then ( PrintState ( contexts )) app ( Request ( GET , \"/hello\" )) } Lens-based keys package cookbook . request_context import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.RequestContexts import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.RequestContextKey import org.http4k.lens.RequestContextLens fun main () { data class SharedState ( val message : String ) fun AddState ( key : RequestContextLens < SharedState > ) = Filter { next -> { // \"modify\" the request like any other Lens next ( it . with ( key of SharedState ( \"hello there\" ))) } } fun PrintState ( key : RequestContextLens < SharedState > ): HttpHandler = { request -> // we can just extract the Lens state from the request like any other standard Lens println ( key ( request )) Response ( OK ) } // this is the shared RequestContexts object - it holds the bag of state for each request and // tidies up afterwards . val contexts = RequestContexts () // this Lens is the key we use to set and get the type - safe state . By using this , we gain // typesafety and the guarantee that there will be no clash of keys . // RequestContextKeys can be required , optional , or defaulted , as per the standard Lens mechanism . val key = RequestContextKey . required < SharedState > ( contexts ) // The first Filter is required to initialise the bag of state . // The second Filter modifies the bag . // The handler just prints out the state . val app = ServerFilters . InitialiseRequestContext ( contexts ) . then ( AddState ( key )) . then ( PrintState ( key )) app ( Request ( GET , \"/hello\" )) }","title":"Typesafe RequestContexts"},{"location":"cookbook/request_context/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/request_context/#string-based-keys","text":"package cookbook . request_context import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.RequestContexts import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ServerFilters fun main () { data class SharedState ( val message : String ) fun AddState ( contexts : RequestContexts ) = Filter { next -> { contexts [ it ][ \"myKey\" ] = SharedState ( \"hello there\" ) next ( it ) } } fun PrintState ( contexts : RequestContexts ): HttpHandler = { request -> val message : SharedState ? = contexts [ request ][ \"myKey\" ] println ( message ) Response ( OK ) } // this is the shared RequestContexts object - it holds the bag of state for each request and // tidies up afterwards val contexts = RequestContexts () // The first Filter is required to initialise the bag of state . // The second Filter modifies the bag // The handler just prints out the state val app = ServerFilters . InitialiseRequestContext ( contexts ) . then ( AddState ( contexts )) . then ( PrintState ( contexts )) app ( Request ( GET , \"/hello\" )) }","title":"String-based keys "},{"location":"cookbook/request_context/#lens-based-keys","text":"package cookbook . request_context import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.RequestContexts import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.RequestContextKey import org.http4k.lens.RequestContextLens fun main () { data class SharedState ( val message : String ) fun AddState ( key : RequestContextLens < SharedState > ) = Filter { next -> { // \"modify\" the request like any other Lens next ( it . with ( key of SharedState ( \"hello there\" ))) } } fun PrintState ( key : RequestContextLens < SharedState > ): HttpHandler = { request -> // we can just extract the Lens state from the request like any other standard Lens println ( key ( request )) Response ( OK ) } // this is the shared RequestContexts object - it holds the bag of state for each request and // tidies up afterwards . val contexts = RequestContexts () // this Lens is the key we use to set and get the type - safe state . By using this , we gain // typesafety and the guarantee that there will be no clash of keys . // RequestContextKeys can be required , optional , or defaulted , as per the standard Lens mechanism . val key = RequestContextKey . required < SharedState > ( contexts ) // The first Filter is required to initialise the bag of state . // The second Filter modifies the bag . // The handler just prints out the state . val app = ServerFilters . InitialiseRequestContext ( contexts ) . then ( AddState ( key )) . then ( PrintState ( key )) app ( Request ( GET , \"/hello\" )) }","title":"Lens-based keys "},{"location":"cookbook/server_as_a_function/","text":"This example is the simplest possible \"server\" implementation. Note that we are not spinning up a server-backend here - but the entire application(!) is testable by firing HTTP requests at it as if it were. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Code package cookbook . server_as_a_function import org.http4k.core.HttpHandler import org.http4k.core.Method import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status fun main () { val app : HttpHandler = { request : Request -> Response ( Status . OK ) . body ( \"Hello, ${request.query(\" name \")}!\" ) } val request = Request ( Method . GET , \"/\" ) . query ( \"name\" , \"John Doe\" ) val response = app ( request ) println ( response ) }","title":"Server as a function"},{"location":"cookbook/server_as_a_function/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/server_as_a_function/#code","text":"package cookbook . server_as_a_function import org.http4k.core.HttpHandler import org.http4k.core.Method import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status fun main () { val app : HttpHandler = { request : Request -> Response ( Status . OK ) . body ( \"Hello, ${request.query(\" name \")}!\" ) } val request = Request ( Method . GET , \"/\" ) . query ( \"name\" , \"John Doe\" ) val response = app ( request ) println ( response ) }","title":"Code "},{"location":"cookbook/service_virtualisation/","text":"Using the JUnit Extensions package cookbook . service_virtualisation . junit import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.ApacheClient import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters.SetBaseUriFrom import org.http4k.junit.ServirtiumRecording import org.http4k.junit.ServirtiumReplay import org.http4k.server.SunHttp import org.http4k.server.asServer import org.http4k.servirtium.GitHub import org.http4k.servirtium.InteractionStorage.Companion.Disk import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeAll import org.junit.jupiter.api.Disabled import org.junit.jupiter.api.Test import org.junit.jupiter.api.TestInstance import org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS import org.junit.jupiter.api.extension.RegisterExtension import java.io.File import java.nio.file.Paths /** * This client wraps the calls to a remote WordCounter service */ class WordCounterClient ( private val http : HttpHandler ) { fun wordCount ( name : String ): Int = http ( Request ( POST , \"/count\" ) . body ( name )) . bodyString () . toInt () } /** * This is our producing app */ class WordCounterApp : HttpHandler { override fun invoke ( req : Request ) = Response ( OK ) . body ( req . bodyString () . run { if ( isBlank ()) 0 else split ( \" \" ) . size } . toString () ) } /** * Defines the test contract which will be recorded and replayed later . The injected HttpHandler * is provided by the implementations of this interface . */ interface WordCounterContract { @Test @JvmDefault fun `count the number of words` ( handler : HttpHandler ) { assertThat ( WordCounterClient ( handler ) . wordCount ( \"A random string with 6 words\" ), equalTo ( 6 )) } @Test @JvmDefault fun `empty string has zero words` ( handler : HttpHandler ) { assertThat ( WordCounterClient ( handler ) . wordCount ( \"\" ), equalTo ( 0 )) } } /** * For the traditional use - case of a CDC , we use a real Http client to record the traffic against * a running version of the producing service . */ @Disabled class RemoteHttpRecordingWordCounterTest : WordCounterContract { private val app = SetBaseUriFrom ( Uri . of ( \"http://serverundertest:8080\" )) . then ( ApacheClient ()) @JvmField @RegisterExtension val record = ServirtiumRecording ( \"WordCounter\" , app , Disk ( File ( \".\" ))) } /** * In cases where the producing service codebase : * 1. Has access to the wrapping Client and the ClientContract code ( eg . monorepo with several services ) * 2. Is also written in http4k * ... we can have the Producer implement the contract entirely in - memory without a MiTM . */ @Disabled class InMemoryRecordingWordCounterTest : WordCounterContract { private val app = WordCounterApp () @JvmField @RegisterExtension val record = ServirtiumRecording ( \"WordCounter\" , app , Disk ( File ( \".\" ))) @AfterEach fun after ( handler : HttpHandler ) { val name = \"this traffic is not recorded\" println ( name + \": \" + WordCounterClient ( handler ) . wordCount ( name )) } } /** * In cases where the producing service codebase : * 1. Has access to the wrapping Client and the ClientContract code ( eg . monorepo with several services ) * 2. Is * not * written in http4k * ... we can have the Producer implement the contract by starting up the server and with a MiTM . */ @TestInstance ( PER_CLASS ) @Disabled class PortBoundRecordingWordCounterTest : WordCounterContract { @BeforeAll fun start () { // pretend that this is not an http4k service .. :) WordCounterApp () . asServer ( SunHttp ( 8080 )) . start () } private val app = SetBaseUriFrom ( Uri . of ( \"http://localhost:8080\" )) . then ( ApacheClient ()) @JvmField @RegisterExtension val record = ServirtiumRecording ( \"WordCounter\" , app , Disk ( File ( \".\" ))) } @Disabled class ReplayFromDiskTest : WordCounterContract { @JvmField @RegisterExtension val replay = ServirtiumReplay ( \"WordCounter\" , Disk ( File ( \".\" ))) } @Disabled class ReplayFromGitHubTest : WordCounterContract { @JvmField @RegisterExtension val replay = ServirtiumReplay ( \"WordCounter\" , GitHub ( \"http4k\" , \"http4k\" , Credentials ( \"<github user>\" , \"<personal access token>\" ), Paths . get ( \"src/test/resources/cookbook/service_virtualisation\" ) ) ) } Using a MiTM Proxy package cookbook . service_virtualisation . mitm import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.ApacheClient import org.http4k.core.Credentials import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters import org.http4k.filter.ClientFilters.SetBaseUriFrom import org.http4k.filter.HandleRemoteRequestFailed import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.SunHttp import org.http4k.server.asServer import org.http4k.servirtium.GitHub import org.http4k.servirtium.InteractionOptions import org.http4k.servirtium.InteractionStorage.Companion.Disk import org.http4k.servirtium.ServirtiumServer import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Disabled import org.junit.jupiter.api.Test import org.junit.jupiter.api.TestInfo import java.io.File import java.nio.file.Paths /** * This is our producing app */ fun WordCounterApp ( port : Int ): Http4kServer { val app = routes ( \"/count\" bind POST to { req : Request -> Response ( OK ) . body ( req . bodyString () . run { if ( isBlank ()) 0 else split ( \" \" ) . size } . toString () ) }) return app . asServer ( SunHttp ( port )) } /** * This client wraps the calls to a remote WordCounter service */ class WordCounterClient ( baseUri : Uri ) { private val http = SetBaseUriFrom ( baseUri ) . then ( ClientFilters . HandleRemoteRequestFailed ()) . then ( ApacheClient ()) fun wordCount ( name : String ): Int = http ( Request ( POST , \"/count\" ) . body ( name )) . bodyString () . toInt () } /** * Defines the test contract which will be recorded and replayed later . */ interface WordCounterContract { val uri : Uri @Test @JvmDefault fun `count the number of words` () { assertThat ( WordCounterClient ( uri ) . wordCount ( \"A random string with 6 words\" ), equalTo ( 6 )) } @Test @JvmDefault fun `empty string has zero words` () { assertThat ( WordCounterClient ( uri ) . wordCount ( \"\" ), equalTo ( 0 )) } } /** * This calls the server directly */ @Disabled class DirectHttpWordCounterTest : WordCounterContract { override val uri = Uri . of ( \"http://serverundertest:8080\" ) } /** * Proxies traffic to the real service and records it to disk . Both MiTM and Producer start on a random port . */ @Disabled class MiTMRecordingWordCounterTest : WordCounterContract { override val uri get () = Uri . of ( \"http://localhost:${servirtium.port()}\" ) private val app = WordCounterApp ( 0 ) private lateinit var servirtium : Http4kServer @BeforeEach fun start ( info : TestInfo ) { val appPort = app . start () . port () servirtium = ServirtiumServer . Recording ( info . displayName . removeSuffix ( \"()\" ), Uri . of ( \"http://localhost:$appPort\" ), Disk ( File ( \".\" )), object : InteractionOptions { override fun modify ( request : Request ) = request . removeHeader ( \"Host\" ) . removeHeader ( \"User-agent\" ) override fun modify ( response : Response ) = response . removeHeader ( \"Date\" ) } ) . start () } @AfterEach fun stop () { app . stop () servirtium . stop () } } /** * Replays incoming traffic from disk. MiTM starts on a random port. */ @Disabled class MiTMReplayingWordCounterTest : WordCounterContract { override val uri get () = Uri . of ( \"http://localhost:${servirtium.port()}\" ) private lateinit var servirtium : Http4kServer @BeforeEach fun start ( info : TestInfo ) { servirtium = ServirtiumServer . Replay ( info . displayName . removeSuffix ( \"()\" ), Disk ( File ( \".\" )), object : InteractionOptions { override fun modify ( request : Request ) = request . header ( \"Date\" , \"some overridden date\" ) } ) . start () } @AfterEach fun stop () { servirtium . stop () } } /** * Replays incoming traffic from GitHub. MiTM starts on a random port. Requires a github username * and personal access token . */ @Disabled class GitHubReplayingWordCounterTest : WordCounterContract { override val uri get () = Uri . of ( \"http://localhost:${servirtium.port()}\" ) private lateinit var servirtium : Http4kServer @BeforeEach fun start ( info : TestInfo ) { servirtium = ServirtiumServer . Replay ( \"WordCounter.\" + info . displayName . removeSuffix ( \"()\" ), GitHub ( \"http4k\" , \"http4k\" , Credentials ( \"<github user>\" , \"<personal access token>\" ), Paths . get ( \"src/test/resources/cookbook/service_virtualisation\" ) ), object : InteractionOptions { override fun modify ( request : Request ) = request . removeHeader ( \"Accept-encoding\" ) . removeHeader ( \"Connection\" ) . removeHeader ( \"Host\" ) . removeHeader ( \"User-agent\" ) . removeHeader ( \"Content-length\" ) } ) . start () } @AfterEach fun stop () { servirtium . stop () } }","title":"Service Virtualisation with Servirtium"},{"location":"cookbook/service_virtualisation/#using-the-junit-extensions","text":"package cookbook . service_virtualisation . junit import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.ApacheClient import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters.SetBaseUriFrom import org.http4k.junit.ServirtiumRecording import org.http4k.junit.ServirtiumReplay import org.http4k.server.SunHttp import org.http4k.server.asServer import org.http4k.servirtium.GitHub import org.http4k.servirtium.InteractionStorage.Companion.Disk import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeAll import org.junit.jupiter.api.Disabled import org.junit.jupiter.api.Test import org.junit.jupiter.api.TestInstance import org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS import org.junit.jupiter.api.extension.RegisterExtension import java.io.File import java.nio.file.Paths /** * This client wraps the calls to a remote WordCounter service */ class WordCounterClient ( private val http : HttpHandler ) { fun wordCount ( name : String ): Int = http ( Request ( POST , \"/count\" ) . body ( name )) . bodyString () . toInt () } /** * This is our producing app */ class WordCounterApp : HttpHandler { override fun invoke ( req : Request ) = Response ( OK ) . body ( req . bodyString () . run { if ( isBlank ()) 0 else split ( \" \" ) . size } . toString () ) } /** * Defines the test contract which will be recorded and replayed later . The injected HttpHandler * is provided by the implementations of this interface . */ interface WordCounterContract { @Test @JvmDefault fun `count the number of words` ( handler : HttpHandler ) { assertThat ( WordCounterClient ( handler ) . wordCount ( \"A random string with 6 words\" ), equalTo ( 6 )) } @Test @JvmDefault fun `empty string has zero words` ( handler : HttpHandler ) { assertThat ( WordCounterClient ( handler ) . wordCount ( \"\" ), equalTo ( 0 )) } } /** * For the traditional use - case of a CDC , we use a real Http client to record the traffic against * a running version of the producing service . */ @Disabled class RemoteHttpRecordingWordCounterTest : WordCounterContract { private val app = SetBaseUriFrom ( Uri . of ( \"http://serverundertest:8080\" )) . then ( ApacheClient ()) @JvmField @RegisterExtension val record = ServirtiumRecording ( \"WordCounter\" , app , Disk ( File ( \".\" ))) } /** * In cases where the producing service codebase : * 1. Has access to the wrapping Client and the ClientContract code ( eg . monorepo with several services ) * 2. Is also written in http4k * ... we can have the Producer implement the contract entirely in - memory without a MiTM . */ @Disabled class InMemoryRecordingWordCounterTest : WordCounterContract { private val app = WordCounterApp () @JvmField @RegisterExtension val record = ServirtiumRecording ( \"WordCounter\" , app , Disk ( File ( \".\" ))) @AfterEach fun after ( handler : HttpHandler ) { val name = \"this traffic is not recorded\" println ( name + \": \" + WordCounterClient ( handler ) . wordCount ( name )) } } /** * In cases where the producing service codebase : * 1. Has access to the wrapping Client and the ClientContract code ( eg . monorepo with several services ) * 2. Is * not * written in http4k * ... we can have the Producer implement the contract by starting up the server and with a MiTM . */ @TestInstance ( PER_CLASS ) @Disabled class PortBoundRecordingWordCounterTest : WordCounterContract { @BeforeAll fun start () { // pretend that this is not an http4k service .. :) WordCounterApp () . asServer ( SunHttp ( 8080 )) . start () } private val app = SetBaseUriFrom ( Uri . of ( \"http://localhost:8080\" )) . then ( ApacheClient ()) @JvmField @RegisterExtension val record = ServirtiumRecording ( \"WordCounter\" , app , Disk ( File ( \".\" ))) } @Disabled class ReplayFromDiskTest : WordCounterContract { @JvmField @RegisterExtension val replay = ServirtiumReplay ( \"WordCounter\" , Disk ( File ( \".\" ))) } @Disabled class ReplayFromGitHubTest : WordCounterContract { @JvmField @RegisterExtension val replay = ServirtiumReplay ( \"WordCounter\" , GitHub ( \"http4k\" , \"http4k\" , Credentials ( \"<github user>\" , \"<personal access token>\" ), Paths . get ( \"src/test/resources/cookbook/service_virtualisation\" ) ) ) }","title":"Using the JUnit Extensions "},{"location":"cookbook/service_virtualisation/#using-a-mitm-proxy","text":"package cookbook . service_virtualisation . mitm import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.ApacheClient import org.http4k.core.Credentials import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters import org.http4k.filter.ClientFilters.SetBaseUriFrom import org.http4k.filter.HandleRemoteRequestFailed import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.SunHttp import org.http4k.server.asServer import org.http4k.servirtium.GitHub import org.http4k.servirtium.InteractionOptions import org.http4k.servirtium.InteractionStorage.Companion.Disk import org.http4k.servirtium.ServirtiumServer import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Disabled import org.junit.jupiter.api.Test import org.junit.jupiter.api.TestInfo import java.io.File import java.nio.file.Paths /** * This is our producing app */ fun WordCounterApp ( port : Int ): Http4kServer { val app = routes ( \"/count\" bind POST to { req : Request -> Response ( OK ) . body ( req . bodyString () . run { if ( isBlank ()) 0 else split ( \" \" ) . size } . toString () ) }) return app . asServer ( SunHttp ( port )) } /** * This client wraps the calls to a remote WordCounter service */ class WordCounterClient ( baseUri : Uri ) { private val http = SetBaseUriFrom ( baseUri ) . then ( ClientFilters . HandleRemoteRequestFailed ()) . then ( ApacheClient ()) fun wordCount ( name : String ): Int = http ( Request ( POST , \"/count\" ) . body ( name )) . bodyString () . toInt () } /** * Defines the test contract which will be recorded and replayed later . */ interface WordCounterContract { val uri : Uri @Test @JvmDefault fun `count the number of words` () { assertThat ( WordCounterClient ( uri ) . wordCount ( \"A random string with 6 words\" ), equalTo ( 6 )) } @Test @JvmDefault fun `empty string has zero words` () { assertThat ( WordCounterClient ( uri ) . wordCount ( \"\" ), equalTo ( 0 )) } } /** * This calls the server directly */ @Disabled class DirectHttpWordCounterTest : WordCounterContract { override val uri = Uri . of ( \"http://serverundertest:8080\" ) } /** * Proxies traffic to the real service and records it to disk . Both MiTM and Producer start on a random port . */ @Disabled class MiTMRecordingWordCounterTest : WordCounterContract { override val uri get () = Uri . of ( \"http://localhost:${servirtium.port()}\" ) private val app = WordCounterApp ( 0 ) private lateinit var servirtium : Http4kServer @BeforeEach fun start ( info : TestInfo ) { val appPort = app . start () . port () servirtium = ServirtiumServer . Recording ( info . displayName . removeSuffix ( \"()\" ), Uri . of ( \"http://localhost:$appPort\" ), Disk ( File ( \".\" )), object : InteractionOptions { override fun modify ( request : Request ) = request . removeHeader ( \"Host\" ) . removeHeader ( \"User-agent\" ) override fun modify ( response : Response ) = response . removeHeader ( \"Date\" ) } ) . start () } @AfterEach fun stop () { app . stop () servirtium . stop () } } /** * Replays incoming traffic from disk. MiTM starts on a random port. */ @Disabled class MiTMReplayingWordCounterTest : WordCounterContract { override val uri get () = Uri . of ( \"http://localhost:${servirtium.port()}\" ) private lateinit var servirtium : Http4kServer @BeforeEach fun start ( info : TestInfo ) { servirtium = ServirtiumServer . Replay ( info . displayName . removeSuffix ( \"()\" ), Disk ( File ( \".\" )), object : InteractionOptions { override fun modify ( request : Request ) = request . header ( \"Date\" , \"some overridden date\" ) } ) . start () } @AfterEach fun stop () { servirtium . stop () } } /** * Replays incoming traffic from GitHub. MiTM starts on a random port. Requires a github username * and personal access token . */ @Disabled class GitHubReplayingWordCounterTest : WordCounterContract { override val uri get () = Uri . of ( \"http://localhost:${servirtium.port()}\" ) private lateinit var servirtium : Http4kServer @BeforeEach fun start ( info : TestInfo ) { servirtium = ServirtiumServer . Replay ( \"WordCounter.\" + info . displayName . removeSuffix ( \"()\" ), GitHub ( \"http4k\" , \"http4k\" , Credentials ( \"<github user>\" , \"<personal access token>\" ), Paths . get ( \"src/test/resources/cookbook/service_virtualisation\" ) ), object : InteractionOptions { override fun modify ( request : Request ) = request . removeHeader ( \"Accept-encoding\" ) . removeHeader ( \"Connection\" ) . removeHeader ( \"Host\" ) . removeHeader ( \"User-agent\" ) . removeHeader ( \"Content-length\" ) } ) . start () } @AfterEach fun stop () { servirtium . stop () } }","title":"Using a MiTM Proxy "},{"location":"cookbook/simple_routing/","text":"This example shows how to use the simple routing functionality to bind several routes Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Code package cookbook . simple_routing import org.http4k.core.Method.DELETE import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.routing.bind import org.http4k.routing.routes fun main () { val app = routes ( \"bob\" bind GET to { Response ( OK ) . body ( \"you GET bob\" ) }, \"rita\" bind POST to { Response ( OK ) . body ( \"you POST rita\" ) }, \"sue\" bind DELETE to { Response ( OK ) . body ( \"you DELETE sue\" ) } ) println ( app ( Request ( GET , \"/bob\" ))) println ( app ( Request ( POST , \"/bob\" ))) println ( app ( Request ( DELETE , \"/sue\" ))) }","title":"Simple routing"},{"location":"cookbook/simple_routing/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/simple_routing/#code","text":"package cookbook . simple_routing import org.http4k.core.Method.DELETE import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.routing.bind import org.http4k.routing.routes fun main () { val app = routes ( \"bob\" bind GET to { Response ( OK ) . body ( \"you GET bob\" ) }, \"rita\" bind POST to { Response ( OK ) . body ( \"you POST rita\" ) }, \"sue\" bind DELETE to { Response ( OK ) . body ( \"you DELETE sue\" ) } ) println ( app ( Request ( GET , \"/bob\" ))) println ( app ( Request ( POST , \"/bob\" ))) println ( app ( Request ( DELETE , \"/sue\" ))) }","title":"Code "},{"location":"cookbook/structured_logging_with_events/","text":"Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.247.0\" In order to leverage modern log aggregation platforms, we should move away from logging arbitrary strings into the StdOut of our applications, and move towards Structured Logging instead, which allows us to treat logs as data which can be mined to give us better observability of our systems. This also encourages the move for developers to think about which events happening in your apps are actually important and what data is appropriate to be attached to each one. http4k supports Structured Logging using a simple yet powerful concept - an Event is simply a marker interface that can be attached to any class, which we then send to an instance of Events (a \"sink\" for sending Event instances to). As with the HttpHandler , Events is just a typealias of (Event) -> Unit , and similarly to the HttpHandler , an Event can be transformed or decorated with metadata using an EventFilter (modelled as (Events) -> Events )). Support for leveraging auto \"object to JSON\" transformational capabilities is included for the libraries that have it (eg. Jackson and GSON). This allows custom Json instances to be used (for instance) to avoid PII information being spat out to log aggregation platforms where they could be masked using the configuration of the JSON renderer. Attaching metadata to an Event results in (compactified) JSON similar to this: { \"event\" : { \"uri\" : \"/path1\" , \"status\" : 200 , \"duration\" : 16 }, \"metadata\" : { \"timestamp\" : \"2019-11-05T17:32:27.297448Z\" , \"traces\" : { \"traceId\" : \"e35304c95b704c7d\" , \"spanId\" : \"0e46f7b3cb5bcf2e\" , \"parentSpanId\" : null , \"samplingDecision\" : \"1\" }, \"requestCount\" : 1234 } } In harmony with the ethos of http4k there is no need to bring in a custom logging library such as SL4J, although they would be very simple to integrate if required by implementing a custom Events instance. The example below shows a simple application that outputs structured logs to StdOut which can be analysed by an aggregator, along with the attachment of extra Event metadata via a custom EventFilter . Code package cookbook . structured_logging_with_events import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.events.AutoJsonEvents import org.http4k.events.Event import org.http4k.events.EventFilter import org.http4k.events.EventFilters import org.http4k.events.plus import org.http4k.events.then import org.http4k.filter.ResponseFilters import org.http4k.format.Jackson fun main () { // Stack filters for Events in the same way as HttpHandlers to transform or add metadata to the Events . // We use AutoJsonEvents ( here with Jackson ) to handle the final serialisation process . val events = EventFilters . AddTimestamp () . then ( EventFilters . AddZipkinTraces ()) . then ( AddRequestCount ()) . then ( AutoJsonEvents ( Jackson )) val app : HttpHandler = { _ : Request -> Response ( OK ) . body ( \"hello\" ) } val appWithEvents = ResponseFilters . ReportHttpTransaction { // to \"emit\" an event , just invoke () the Events ! events ( IncomingHttpRequest ( it . request . uri , it . response . status . code , it . duration . toMillis ())) } . then ( app ) appWithEvents ( Request ( GET , \"/path1\" )) appWithEvents ( Request ( GET , \"/path2\" )) } // this is our custom event which will be printed in a structured way data class IncomingHttpRequest ( val uri : Uri , val status : Int , val duration : Long ) : Event // here is a new EventFilter that adds custom metadata to the emitted events fun AddRequestCount (): EventFilter { var requestCount = 0 return EventFilter { next -> { next ( it + ( \"requestCount\" to requestCount ++ )) } } }","title":"Structured Logging with Events"},{"location":"cookbook/structured_logging_with_events/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.247.0\" In order to leverage modern log aggregation platforms, we should move away from logging arbitrary strings into the StdOut of our applications, and move towards Structured Logging instead, which allows us to treat logs as data which can be mined to give us better observability of our systems. This also encourages the move for developers to think about which events happening in your apps are actually important and what data is appropriate to be attached to each one. http4k supports Structured Logging using a simple yet powerful concept - an Event is simply a marker interface that can be attached to any class, which we then send to an instance of Events (a \"sink\" for sending Event instances to). As with the HttpHandler , Events is just a typealias of (Event) -> Unit , and similarly to the HttpHandler , an Event can be transformed or decorated with metadata using an EventFilter (modelled as (Events) -> Events )). Support for leveraging auto \"object to JSON\" transformational capabilities is included for the libraries that have it (eg. Jackson and GSON). This allows custom Json instances to be used (for instance) to avoid PII information being spat out to log aggregation platforms where they could be masked using the configuration of the JSON renderer. Attaching metadata to an Event results in (compactified) JSON similar to this: { \"event\" : { \"uri\" : \"/path1\" , \"status\" : 200 , \"duration\" : 16 }, \"metadata\" : { \"timestamp\" : \"2019-11-05T17:32:27.297448Z\" , \"traces\" : { \"traceId\" : \"e35304c95b704c7d\" , \"spanId\" : \"0e46f7b3cb5bcf2e\" , \"parentSpanId\" : null , \"samplingDecision\" : \"1\" }, \"requestCount\" : 1234 } } In harmony with the ethos of http4k there is no need to bring in a custom logging library such as SL4J, although they would be very simple to integrate if required by implementing a custom Events instance. The example below shows a simple application that outputs structured logs to StdOut which can be analysed by an aggregator, along with the attachment of extra Event metadata via a custom EventFilter .","title":"Gradle setup"},{"location":"cookbook/structured_logging_with_events/#code","text":"package cookbook . structured_logging_with_events import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.events.AutoJsonEvents import org.http4k.events.Event import org.http4k.events.EventFilter import org.http4k.events.EventFilters import org.http4k.events.plus import org.http4k.events.then import org.http4k.filter.ResponseFilters import org.http4k.format.Jackson fun main () { // Stack filters for Events in the same way as HttpHandlers to transform or add metadata to the Events . // We use AutoJsonEvents ( here with Jackson ) to handle the final serialisation process . val events = EventFilters . AddTimestamp () . then ( EventFilters . AddZipkinTraces ()) . then ( AddRequestCount ()) . then ( AutoJsonEvents ( Jackson )) val app : HttpHandler = { _ : Request -> Response ( OK ) . body ( \"hello\" ) } val appWithEvents = ResponseFilters . ReportHttpTransaction { // to \"emit\" an event , just invoke () the Events ! events ( IncomingHttpRequest ( it . request . uri , it . response . status . code , it . duration . toMillis ())) } . then ( app ) appWithEvents ( Request ( GET , \"/path1\" )) appWithEvents ( Request ( GET , \"/path2\" )) } // this is our custom event which will be printed in a structured way data class IncomingHttpRequest ( val uri : Uri , val status : Int , val duration : Long ) : Event // here is a new EventFilter that adds custom metadata to the emitted events fun AddRequestCount (): EventFilter { var requestCount = 0 return EventFilter { next -> { next ( it + ( \"requestCount\" to requestCount ++ )) } } }","title":"Code "},{"location":"cookbook/test_driven_apps/","text":"This example shows the various styles of testing endpoints, and requires both the http4k-core and http4k-testing-hamkrest modules: Code package cookbook . test_driven_apps import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.OkHttp import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.NOT_FOUND import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters.SetHostFrom import org.http4k.filter.ServerFilters import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test class AnswerRecorder ( private val httpClient : HttpHandler ) : ( Int ) -> Unit { override fun invoke ( answer : Int ) { httpClient ( Request ( POST , \"/\" + answer . toString ())) } } fun myMathsEndpoint ( fn : ( Int , Int ) -> Int , recorder : ( Int ) -> Unit ): HttpHandler = { req -> val answer = fn ( req . query ( \"first\" ) !! . toInt (), req . query ( \"second\" ) !! . toInt ()) recorder ( answer ) Response ( OK ) . body ( \"the answer is $answer\" ) } class EndpointUnitTest { @Test fun `adds numbers and records answer` () { var answer : Int ? = null val unit = myMathsEndpoint ({ first , second -> first + second }, { answer = it }) val response = unit ( Request ( GET , \"/\" ) . query ( \"first\" , \"123\" ) . query ( \"second\" , \"456\" )) assertThat ( answer , equalTo ( 579 )) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"the answer is 579\" ))) } } fun MyMathsApp ( recorderHttp : HttpHandler ) = ServerFilters . CatchAll () . then ( routes ( \"/add\" bind GET to myMathsEndpoint ({ first , second -> first + second }, AnswerRecorder ( recorderHttp )) )) class FakeRecorderHttp : HttpHandler { val calls = mutableListOf < Int > () private val app = routes ( \"/{answer}\" bind POST to { request -> calls . add ( request . path ( \"answer\" ) !! . toInt ()); Response ( OK ) } ) override fun invoke ( request : Request ): Response = app ( request ) } class FunctionalTest { private val recorderHttp = FakeRecorderHttp () private val app = MyMathsApp ( recorderHttp ) @Test fun `adds numbers` () { val response = app ( Request ( GET , \"/add\" ) . query ( \"first\" , \"123\" ) . query ( \"second\" , \"456\" )) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"the answer is 579\" ))) assertThat ( recorderHttp . calls , equalTo ( listOf ( 579 ))) } @Test fun `not found` () { val response = app ( Request ( GET , \"/nothing\" ) . query ( \"first\" , \"123\" ) . query ( \"second\" , \"456\" )) assertThat ( response , hasStatus ( NOT_FOUND )) } } fun MyMathServer ( port : Int , recorderUri : Uri ): Http4kServer { val recorderHttp = SetHostFrom ( recorderUri ) . then ( OkHttp ()) return MyMathsApp ( recorderHttp ) . asServer ( Jetty ( port )) } class EndToEndTest { private val client = OkHttp () private val recorderHttp = FakeRecorderHttp () private val recorder = recorderHttp . asServer ( Jetty ( 8001 )) private val server = MyMathServer ( 8000 , Uri . of ( \"http://localhost:8001\" )) @BeforeEach fun setup () { recorder . start () server . start () } @AfterEach fun teardown () { server . stop () recorder . stop () } @Test fun `adds numbers` () { val response = client ( Request ( GET , \"http://localhost:8000/add\" ) . query ( \"first\" , \"123\" ) . query ( \"second\" , \"456\" )) println ( response ) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"the answer is 579\" ))) assertThat ( recorderHttp . calls , equalTo ( listOf ( 579 ))) } }","title":"Test driven apps"},{"location":"cookbook/test_driven_apps/#code","text":"package cookbook . test_driven_apps import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.OkHttp import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.NOT_FOUND import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters.SetHostFrom import org.http4k.filter.ServerFilters import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test class AnswerRecorder ( private val httpClient : HttpHandler ) : ( Int ) -> Unit { override fun invoke ( answer : Int ) { httpClient ( Request ( POST , \"/\" + answer . toString ())) } } fun myMathsEndpoint ( fn : ( Int , Int ) -> Int , recorder : ( Int ) -> Unit ): HttpHandler = { req -> val answer = fn ( req . query ( \"first\" ) !! . toInt (), req . query ( \"second\" ) !! . toInt ()) recorder ( answer ) Response ( OK ) . body ( \"the answer is $answer\" ) } class EndpointUnitTest { @Test fun `adds numbers and records answer` () { var answer : Int ? = null val unit = myMathsEndpoint ({ first , second -> first + second }, { answer = it }) val response = unit ( Request ( GET , \"/\" ) . query ( \"first\" , \"123\" ) . query ( \"second\" , \"456\" )) assertThat ( answer , equalTo ( 579 )) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"the answer is 579\" ))) } } fun MyMathsApp ( recorderHttp : HttpHandler ) = ServerFilters . CatchAll () . then ( routes ( \"/add\" bind GET to myMathsEndpoint ({ first , second -> first + second }, AnswerRecorder ( recorderHttp )) )) class FakeRecorderHttp : HttpHandler { val calls = mutableListOf < Int > () private val app = routes ( \"/{answer}\" bind POST to { request -> calls . add ( request . path ( \"answer\" ) !! . toInt ()); Response ( OK ) } ) override fun invoke ( request : Request ): Response = app ( request ) } class FunctionalTest { private val recorderHttp = FakeRecorderHttp () private val app = MyMathsApp ( recorderHttp ) @Test fun `adds numbers` () { val response = app ( Request ( GET , \"/add\" ) . query ( \"first\" , \"123\" ) . query ( \"second\" , \"456\" )) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"the answer is 579\" ))) assertThat ( recorderHttp . calls , equalTo ( listOf ( 579 ))) } @Test fun `not found` () { val response = app ( Request ( GET , \"/nothing\" ) . query ( \"first\" , \"123\" ) . query ( \"second\" , \"456\" )) assertThat ( response , hasStatus ( NOT_FOUND )) } } fun MyMathServer ( port : Int , recorderUri : Uri ): Http4kServer { val recorderHttp = SetHostFrom ( recorderUri ) . then ( OkHttp ()) return MyMathsApp ( recorderHttp ) . asServer ( Jetty ( port )) } class EndToEndTest { private val client = OkHttp () private val recorderHttp = FakeRecorderHttp () private val recorder = recorderHttp . asServer ( Jetty ( 8001 )) private val server = MyMathServer ( 8000 , Uri . of ( \"http://localhost:8001\" )) @BeforeEach fun setup () { recorder . start () server . start () } @AfterEach fun teardown () { server . stop () recorder . stop () } @Test fun `adds numbers` () { val response = client ( Request ( GET , \"http://localhost:8000/add\" ) . query ( \"first\" , \"123\" ) . query ( \"second\" , \"456\" )) println ( response ) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"the answer is 579\" ))) assertThat ( recorderHttp . calls , equalTo ( listOf ( 579 ))) } }","title":"Code "},{"location":"cookbook/typesafe_http_contracts/","text":"This contract example shows: 2 endpoints with typesafe contracts (marshalling of path parameters and bodies) Custom filters (reporting latency) API key security via a typesafe Query parameter (this can be a header or a body parameter as well) OpenApi v3 documentation - Run this example and point a browser here Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-contract\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"3.247.0\" Note: although we use Argo here as our JSON API, you could also switch in any of the http4k-format-xxx JSON modules. Code package cookbook . typesafe_http_contracts import org.http4k.contract.bind import org.http4k.contract.contract import org.http4k.contract.div import org.http4k.contract.meta import org.http4k.contract.openapi.ApiInfo import org.http4k.contract.openapi.v3.OpenApi3 import org.http4k.contract.security.ApiKeySecurity import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_PLAIN import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.HttpTransaction import org.http4k.core.Method.GET import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.CachingFilters.Response.NoCache import org.http4k.filter.CorsPolicy import org.http4k.filter.ResponseFilters import org.http4k.filter.ServerFilters import org.http4k.format.Argo import org.http4k.format.Jackson import org.http4k.lens.Path import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.lens.string import org.http4k.routing.ResourceLoader.Companion.Classpath import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.routing.static import org.http4k.server.Jetty import org.http4k.server.asServer import java.time.Clock fun main () { fun add ( value1 : Int , value2 : Int ): HttpHandler = { Response ( OK ) . with ( Body . string ( TEXT_PLAIN ) . toLens () of ( value1 + value2 ) . toString () ) } val ageQuery = Query . int () . required ( \"age\" ) fun echo ( name : String ): HttpHandler = { Response ( OK ) . with ( Body . string ( TEXT_PLAIN ) . toLens () of \"hello $name you are ${ageQuery(it)}\" ) } val filter : Filter = ResponseFilters . ReportHttpTransaction ( Clock . systemUTC ()) { tx : HttpTransaction -> println ( tx . labels . toString () + \" took \" + tx . duration ) } val mySecurity = ApiKeySecurity ( Query . int () . required ( \"apiKey\" ), { it == 42 }) val contract = contract { renderer = OpenApi3 ( ApiInfo ( \"my great api\" , \"v1.0\" ), Argo ) descriptionPath = \"/docs/swagger.json\" security = mySecurity routes += \"/ping\" meta { summary = \"add\" description = \"Adds 2 numbers together\" returning ( OK to \"The result\" ) } bindContract GET to { Response ( OK ) . body ( \"pong\" ) } routes += \"/add\" / Path . int () . of ( \"value1\" ) / Path . int () . of ( \"value2\" ) meta { summary = \"add\" description = \"Adds 2 numbers together\" returning ( OK to \"The result\" ) } bindContract GET to :: add // note here that the trailing parameter can be ignored - it would simply be the value \"divide\" . routes += Path . int () . of ( \"value1\" ) / Path . int () . of ( \"value2\" ) / \"divide\" meta { summary = \"divide\" description = \"Divides 2 numbers\" returning ( OK to \"The result\" ) } bindContract GET to { first , second , _ -> { Response ( OK ) . body (( first / second ) . toString ()) } } routes += \"/echo\" / Path . of ( \"name\" ) meta { summary = \"echo\" queries += ageQuery } bindContract GET to :: echo } val handler = routes ( \"/context\" bind filter . then ( contract ), \"/static\" bind NoCache () . then ( static ( Classpath ( \"cookbook/nestable_routes\" ))), \"/\" bind contract { renderer = OpenApi3 ( ApiInfo ( \"my great super api\" , \"v1.0\" ), Jackson ) routes += \"/echo\" / Path . of ( \"name\" ) meta { summary = \"echo\" queries += ageQuery } bindContract GET to :: echo } ) ServerFilters . Cors ( CorsPolicy . UnsafeGlobalPermissive ) . then ( handler ) . asServer ( Jetty ( 8000 )) . start () } // Ping ! curl - v \"http://localhost:8000/context/ping?apiKey=42\" // Adding 2 numbers : curl - v \"http://localhost:8000/context/add/123/564?apiKey=42\" // Echo ( fail ): curl - v \"http://localhost:8000/context/echo/myName?age=notANumber&apiKey=42\" // API Key enforcement : curl - v \"http://localhost:8000/context/add/123/564?apiKey=444\" // Static content : curl - v \"http://localhost:8000/static/someStaticFile.txt\" // OpenApi / Swagger documentation : curl - v \"http://localhost:8000/context/docs/swagger.json\" // Echo endpoint ( at root ): curl - v \"http://localhost:8000/echo/hello?age=123\"","title":"Typesafe HTTP contracts"},{"location":"cookbook/typesafe_http_contracts/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-contract\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"3.247.0\" Note: although we use Argo here as our JSON API, you could also switch in any of the http4k-format-xxx JSON modules.","title":"Gradle setup"},{"location":"cookbook/typesafe_http_contracts/#code","text":"package cookbook . typesafe_http_contracts import org.http4k.contract.bind import org.http4k.contract.contract import org.http4k.contract.div import org.http4k.contract.meta import org.http4k.contract.openapi.ApiInfo import org.http4k.contract.openapi.v3.OpenApi3 import org.http4k.contract.security.ApiKeySecurity import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_PLAIN import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.HttpTransaction import org.http4k.core.Method.GET import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.CachingFilters.Response.NoCache import org.http4k.filter.CorsPolicy import org.http4k.filter.ResponseFilters import org.http4k.filter.ServerFilters import org.http4k.format.Argo import org.http4k.format.Jackson import org.http4k.lens.Path import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.lens.string import org.http4k.routing.ResourceLoader.Companion.Classpath import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.routing.static import org.http4k.server.Jetty import org.http4k.server.asServer import java.time.Clock fun main () { fun add ( value1 : Int , value2 : Int ): HttpHandler = { Response ( OK ) . with ( Body . string ( TEXT_PLAIN ) . toLens () of ( value1 + value2 ) . toString () ) } val ageQuery = Query . int () . required ( \"age\" ) fun echo ( name : String ): HttpHandler = { Response ( OK ) . with ( Body . string ( TEXT_PLAIN ) . toLens () of \"hello $name you are ${ageQuery(it)}\" ) } val filter : Filter = ResponseFilters . ReportHttpTransaction ( Clock . systemUTC ()) { tx : HttpTransaction -> println ( tx . labels . toString () + \" took \" + tx . duration ) } val mySecurity = ApiKeySecurity ( Query . int () . required ( \"apiKey\" ), { it == 42 }) val contract = contract { renderer = OpenApi3 ( ApiInfo ( \"my great api\" , \"v1.0\" ), Argo ) descriptionPath = \"/docs/swagger.json\" security = mySecurity routes += \"/ping\" meta { summary = \"add\" description = \"Adds 2 numbers together\" returning ( OK to \"The result\" ) } bindContract GET to { Response ( OK ) . body ( \"pong\" ) } routes += \"/add\" / Path . int () . of ( \"value1\" ) / Path . int () . of ( \"value2\" ) meta { summary = \"add\" description = \"Adds 2 numbers together\" returning ( OK to \"The result\" ) } bindContract GET to :: add // note here that the trailing parameter can be ignored - it would simply be the value \"divide\" . routes += Path . int () . of ( \"value1\" ) / Path . int () . of ( \"value2\" ) / \"divide\" meta { summary = \"divide\" description = \"Divides 2 numbers\" returning ( OK to \"The result\" ) } bindContract GET to { first , second , _ -> { Response ( OK ) . body (( first / second ) . toString ()) } } routes += \"/echo\" / Path . of ( \"name\" ) meta { summary = \"echo\" queries += ageQuery } bindContract GET to :: echo } val handler = routes ( \"/context\" bind filter . then ( contract ), \"/static\" bind NoCache () . then ( static ( Classpath ( \"cookbook/nestable_routes\" ))), \"/\" bind contract { renderer = OpenApi3 ( ApiInfo ( \"my great super api\" , \"v1.0\" ), Jackson ) routes += \"/echo\" / Path . of ( \"name\" ) meta { summary = \"echo\" queries += ageQuery } bindContract GET to :: echo } ) ServerFilters . Cors ( CorsPolicy . UnsafeGlobalPermissive ) . then ( handler ) . asServer ( Jetty ( 8000 )) . start () } // Ping ! curl - v \"http://localhost:8000/context/ping?apiKey=42\" // Adding 2 numbers : curl - v \"http://localhost:8000/context/add/123/564?apiKey=42\" // Echo ( fail ): curl - v \"http://localhost:8000/context/echo/myName?age=notANumber&apiKey=42\" // API Key enforcement : curl - v \"http://localhost:8000/context/add/123/564?apiKey=444\" // Static content : curl - v \"http://localhost:8000/static/someStaticFile.txt\" // OpenApi / Swagger documentation : curl - v \"http://localhost:8000/context/docs/swagger.json\" // Echo endpoint ( at root ): curl - v \"http://localhost:8000/echo/hello?age=123\"","title":"Code "},{"location":"cookbook/typesafe_http_requests_with_lenses/","text":"Example showing how to create and apply lenses to requests and responses to both extract and inject typesafe values out of and into HTTP messages. Note that since the http4k Request/Response objects are immutable, all injection occurs via copy. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Standard (exception based) approach Errors in extracting Lenses are propagated as exceptions which are caught and handled by the CatchLensFailure Filter. package cookbook . typesafe_http_requests_with_lenses import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_PLAIN import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.Header import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.lens.string fun main () { data class Child ( val name : String ) val nameHeader = Header . required ( \"name\" ) val ageQuery = Query . int () . optional ( \"age\" ) val childrenBody = Body . string ( TEXT_PLAIN ) . map ({ it . split ( \",\" ) . map (:: Child ) }, { it . map { it . name } . joinToString () }) . toLens () val endpoint = { request : Request -> val name : String = nameHeader ( request ) val age : Int ? = ageQuery ( request ) val children : List < Child > = childrenBody ( request ) val msg = \"$name is ${age ?: \" unknown \"} years old and has \" + \"${children.size} children (${children.map { it.name }.joinToString()})\" Response ( OK ) . with ( Body . string ( TEXT_PLAIN ) . toLens () of msg ) } val app = ServerFilters . CatchLensFailure . then ( endpoint ) val goodRequest = Request ( GET , \"http://localhost:9000\" ) . with ( nameHeader of \"Jane Doe\" , ageQuery of 25 , childrenBody of listOf ( Child ( \"Rita\" ), Child ( \"Sue\" ))) println ( listOf ( \"\" , \"Request:\" , goodRequest , app ( goodRequest )) . joinToString ( \" \\n \" )) val badRequest = Request ( GET , \"http://localhost:9000\" ) . with ( nameHeader of \"Jane Doe\" ) . query ( \"age\" , \"some illegal age!\" ) println ( listOf ( \"\" , \"Request:\" , badRequest , app ( badRequest )) . joinToString ( \" \\n \" )) } Using custom \"Result\" ADTs An alternative approach to using Exceptions to automatically produce BadRequests is to use an Either-type structure, and this would be easy to implement - but the lack of an in-built Result/Either type in the standard Kotlin library means that we don't have a single representation to use without shackling ourselves to another Either-containing library such as Arrow or Result4k. Additionally, the lack of Higher Kinded Types in Kotlin means that we are unable to provide a generic method for converting standard lenses. However, it is easy to implement an extension method to use in specific use cases. Below is an example which uses a custom Result ADT - this will work for all extraction Lenses that you define: Code package cookbook . typesafe_http_requests_with_lenses import com.fasterxml.jackson.databind.JsonNode import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.format.Jackson.json import org.http4k.lens.LensExtractor import org.http4k.lens.LensFailure import org.http4k.lens.Query import org.http4k.lens.int // This is our custom Result / Either ADT , although it could be anything , like a Result4k Result ( which has map () etc ) sealed class Result < out T > data class Succeeded < out T > ( val value : T ) : Result < T > () data class Failed < out T > ( val e : Exception ) : Result < T > () // This simple extension method can be used to convert all Lenses to return our custom Result type instead of the standard exception fun < IN , OUT > LensExtractor < IN , OUT >. toResult (): LensExtractor < IN , Result < OUT >> = object : LensExtractor < IN , Result < OUT >> { override fun invoke ( target : IN ): Result < OUT > = try { Succeeded ( this @toResult.invoke ( target )) } catch ( e : LensFailure ) { Failed ( e ) } } // examples of using the above extension function fun main () { val queryResultLens = Query . int () . required ( \"foo\" ) . toResult () val intResult : Result < Int > = queryResultLens ( Request ( GET , \"/?foo=123\" )) println ( intResult ) val jsonResultLens = Body . json () . toLens () . toResult () val jsonResult : Result < JsonNode > = jsonResultLens ( Request ( GET , \"/foo\" )) println ( jsonResult ) }","title":"Typesafe HTTP requests with lenses"},{"location":"cookbook/typesafe_http_requests_with_lenses/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/typesafe_http_requests_with_lenses/#standard-exception-based-approach","text":"Errors in extracting Lenses are propagated as exceptions which are caught and handled by the CatchLensFailure Filter. package cookbook . typesafe_http_requests_with_lenses import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_PLAIN import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.Header import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.lens.string fun main () { data class Child ( val name : String ) val nameHeader = Header . required ( \"name\" ) val ageQuery = Query . int () . optional ( \"age\" ) val childrenBody = Body . string ( TEXT_PLAIN ) . map ({ it . split ( \",\" ) . map (:: Child ) }, { it . map { it . name } . joinToString () }) . toLens () val endpoint = { request : Request -> val name : String = nameHeader ( request ) val age : Int ? = ageQuery ( request ) val children : List < Child > = childrenBody ( request ) val msg = \"$name is ${age ?: \" unknown \"} years old and has \" + \"${children.size} children (${children.map { it.name }.joinToString()})\" Response ( OK ) . with ( Body . string ( TEXT_PLAIN ) . toLens () of msg ) } val app = ServerFilters . CatchLensFailure . then ( endpoint ) val goodRequest = Request ( GET , \"http://localhost:9000\" ) . with ( nameHeader of \"Jane Doe\" , ageQuery of 25 , childrenBody of listOf ( Child ( \"Rita\" ), Child ( \"Sue\" ))) println ( listOf ( \"\" , \"Request:\" , goodRequest , app ( goodRequest )) . joinToString ( \" \\n \" )) val badRequest = Request ( GET , \"http://localhost:9000\" ) . with ( nameHeader of \"Jane Doe\" ) . query ( \"age\" , \"some illegal age!\" ) println ( listOf ( \"\" , \"Request:\" , badRequest , app ( badRequest )) . joinToString ( \" \\n \" )) }","title":"Standard (exception based) approach "},{"location":"cookbook/typesafe_http_requests_with_lenses/#using-custom-result-adts","text":"An alternative approach to using Exceptions to automatically produce BadRequests is to use an Either-type structure, and this would be easy to implement - but the lack of an in-built Result/Either type in the standard Kotlin library means that we don't have a single representation to use without shackling ourselves to another Either-containing library such as Arrow or Result4k. Additionally, the lack of Higher Kinded Types in Kotlin means that we are unable to provide a generic method for converting standard lenses. However, it is easy to implement an extension method to use in specific use cases. Below is an example which uses a custom Result ADT - this will work for all extraction Lenses that you define:","title":"Using custom \"Result\" ADTs"},{"location":"cookbook/typesafe_http_requests_with_lenses/#code","text":"package cookbook . typesafe_http_requests_with_lenses import com.fasterxml.jackson.databind.JsonNode import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.format.Jackson.json import org.http4k.lens.LensExtractor import org.http4k.lens.LensFailure import org.http4k.lens.Query import org.http4k.lens.int // This is our custom Result / Either ADT , although it could be anything , like a Result4k Result ( which has map () etc ) sealed class Result < out T > data class Succeeded < out T > ( val value : T ) : Result < T > () data class Failed < out T > ( val e : Exception ) : Result < T > () // This simple extension method can be used to convert all Lenses to return our custom Result type instead of the standard exception fun < IN , OUT > LensExtractor < IN , OUT >. toResult (): LensExtractor < IN , Result < OUT >> = object : LensExtractor < IN , Result < OUT >> { override fun invoke ( target : IN ): Result < OUT > = try { Succeeded ( this @toResult.invoke ( target )) } catch ( e : LensFailure ) { Failed ( e ) } } // examples of using the above extension function fun main () { val queryResultLens = Query . int () . required ( \"foo\" ) . toResult () val intResult : Result < Int > = queryResultLens ( Request ( GET , \"/?foo=123\" )) println ( intResult ) val jsonResultLens = Body . json () . toLens () . toResult () val jsonResult : Result < JsonNode > = jsonResultLens ( Request ( GET , \"/foo\" )) println ( jsonResult ) }","title":"Code "},{"location":"cookbook/using_templates/","text":"Example showing how to use the Templating modules - in this case Handlebars, both by standard response manipulation and via a typesafe view lens. Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"3.247.0\" Code package cookbook . using_templates import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_HTML import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.template.HandlebarsTemplates import org.http4k.template.ViewModel import org.http4k.template.viewModel // this view has the default template path of : cookbook / using_templates / Person . hbs , although that is overridable by // setting the template property from ViewModel data class Person ( val name : String , val age : Int ) : ViewModel fun main () { val renderer = HandlebarsTemplates () . HotReload ( \"src/docs\" ) val view = Body . viewModel ( renderer , TEXT_HTML ) . toLens () val app : HttpHandler = { val viewModel = Person ( \"Bob\" , 45 ) Response ( OK ) . body ( renderer ( viewModel )) // OR : Response ( OK ) . with ( view of viewModel ) } println ( app ( Request ( GET , \"/someUrl\" ))) }","title":"Templating engines"},{"location":"cookbook/using_templates/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"3.247.0\"","title":"Gradle setup"},{"location":"cookbook/using_templates/#code","text":"package cookbook . using_templates import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_HTML import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.template.HandlebarsTemplates import org.http4k.template.ViewModel import org.http4k.template.viewModel // this view has the default template path of : cookbook / using_templates / Person . hbs , although that is overridable by // setting the template property from ViewModel data class Person ( val name : String , val age : Int ) : ViewModel fun main () { val renderer = HandlebarsTemplates () . HotReload ( \"src/docs\" ) val view = Body . viewModel ( renderer , TEXT_HTML ) . toLens () val app : HttpHandler = { val viewModel = Person ( \"Bob\" , 45 ) Response ( OK ) . body ( renderer ( viewModel )) // OR : Response ( OK ) . with ( view of viewModel ) } println ( app ( Request ( GET , \"/someUrl\" ))) }","title":"Code "},{"location":"cookbook/websockets/","text":"Gradle setup compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-client-websocket\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.247.0\" http4k provides Websocket support using a simple, consistent, typesafe, and testable API on supported server backends (see above). Websocket communication consists of 3 main concepts: WsHandler - represented as a typealias: WsHandler = (Request) -> WsConsumer? . This is responsible for matching an HTTP request to a websocket. WsConsumer - represented as a typealias: WsConsumer = (WebSocket) -> Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket. WsMessage - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the http4k HTTP message model, WsMessages are immutable data classes. Websocket as a Function The simplest possible Websocket can be mounted as a WsConsumer function onto a server with: { ws : Websocket -> ws . send ( WsMessage ( \"hello\" )) }. asServer ( Jetty ( 9000 )). start () Mixing HTTP and Websocket services Both Websockets and Http handlers in http4k are routed using a similar path-based API. We combine them into a single PolyHandler which can handle both http:// and ws:// , and then convert to a Server as usual: package cookbook . websockets import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.PolyHandler import org.http4k.websocket.Websocket import org.http4k.websocket.WsMessage fun main () { val namePath = Path . of ( \"name\" ) val ws = websockets ( \"/{name}\" bind { ws : Websocket -> val name = namePath ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) ws . onMessage { ws . send ( WsMessage ( \"$name is responding\" )) } ws . onClose { println ( \"$name is closing\" ) } } ) val http = { _ : Request -> Response ( OK ) . body ( \"hiya world\" ) } PolyHandler ( http , ws ) . asServer ( Jetty ( 9000 )) . start () } Automarshalling Websockets messages Using the standard Lens API, we can auto-convert Websocket messages on and off the wire. This example uses the Jackson for the marshalling: package cookbook . websockets import org.http4k.client.WebsocketClient import org.http4k.core.Uri import org.http4k.format.Jackson.auto import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.Websocket import org.http4k.websocket.WsMessage data class Person ( val name : String , val age : Int ) fun main () { // a lens that will marshall the Person object on and off the wire val personLens = WsMessage . auto < Person > () . toLens () val server = websockets ( \"/ageMe\" bind { ws : Websocket -> ws . onMessage { val person = personLens ( it ) ws . send ( personLens . create ( person . copy ( age = person . age + 10 ))) ws . close () } } ) . asServer ( Jetty ( 8000 )) . start () val client = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/ageMe\" )) // send a message in \"native form\" - we could also use the Lens here to auto - marshall client . send ( WsMessage ( \"\"\"{ \"name\":\"bob\", \"age\": 25 }\"\"\" )) // read all of the messages from the socket until it is closed ( by the server ) . // we expect to get one message back before the stream is closed . client . received () . toList () . forEach (:: println ) server . stop () } Testing Websockets http4k provides Websockets that are both typesafe (via the Lens API), and testable. Both WsHandlers and PolyHandlers are convertible to a WsClient which provides a synchronous API for testing reactions to Websocket events in an offline environment. In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. http4k provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic: package cookbook . websockets import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.WebsocketClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Uri import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.testing.testWsClient import org.http4k.websocket.Websocket import org.http4k.websocket.WsClient import org.http4k.websocket.WsHandler import org.http4k.websocket.WsMessage import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test val namePath = Path . of ( \"name\" ) // here is our websocket app - it uses dynamic path binding and lenses val testApp : WsHandler = websockets ( \"/{name}\" bind { ws : Websocket -> val name = namePath ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) } ) // this is the abstract contract that defines the behaviour to be tested abstract class WebsocketContract { // subclasses only have to supply a blocking WsClient abstract fun client (): WsClient @Test fun `echoes back connected name` () { assertThat ( client () . received () . take ( 1 ) . toList (), equalTo ( listOf ( WsMessage ( \"hello bob\" )))) } } // a unit test version of the contract - it connects to the websocket in memory with no network class WebsocketUnitTest : WebsocketContract () { override fun client () = testApp . testWsClient ( Request ( GET , \"/bob\" )) !! } // a integration test version of the contract - it starts a server and connects to the websocket over the network class WebsocketServerTest : WebsocketContract () { override fun client () = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/bob\" )) private val server = testApp . asServer ( Jetty ( 8000 )) @BeforeEach fun before () { server . start () } @AfterEach fun after () { server . stop () } }","title":"Websockets"},{"location":"cookbook/websockets/#gradle-setup","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-client-websocket\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.247.0\" http4k provides Websocket support using a simple, consistent, typesafe, and testable API on supported server backends (see above). Websocket communication consists of 3 main concepts: WsHandler - represented as a typealias: WsHandler = (Request) -> WsConsumer? . This is responsible for matching an HTTP request to a websocket. WsConsumer - represented as a typealias: WsConsumer = (WebSocket) -> Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket. WsMessage - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the http4k HTTP message model, WsMessages are immutable data classes.","title":"Gradle setup"},{"location":"cookbook/websockets/#websocket-as-a-function","text":"The simplest possible Websocket can be mounted as a WsConsumer function onto a server with: { ws : Websocket -> ws . send ( WsMessage ( \"hello\" )) }. asServer ( Jetty ( 9000 )). start ()","title":"Websocket as a Function"},{"location":"cookbook/websockets/#mixing-http-and-websocket-services","text":"Both Websockets and Http handlers in http4k are routed using a similar path-based API. We combine them into a single PolyHandler which can handle both http:// and ws:// , and then convert to a Server as usual: package cookbook . websockets import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.PolyHandler import org.http4k.websocket.Websocket import org.http4k.websocket.WsMessage fun main () { val namePath = Path . of ( \"name\" ) val ws = websockets ( \"/{name}\" bind { ws : Websocket -> val name = namePath ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) ws . onMessage { ws . send ( WsMessage ( \"$name is responding\" )) } ws . onClose { println ( \"$name is closing\" ) } } ) val http = { _ : Request -> Response ( OK ) . body ( \"hiya world\" ) } PolyHandler ( http , ws ) . asServer ( Jetty ( 9000 )) . start () }","title":"Mixing HTTP and Websocket services "},{"location":"cookbook/websockets/#automarshalling-websockets-messages","text":"Using the standard Lens API, we can auto-convert Websocket messages on and off the wire. This example uses the Jackson for the marshalling: package cookbook . websockets import org.http4k.client.WebsocketClient import org.http4k.core.Uri import org.http4k.format.Jackson.auto import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.Websocket import org.http4k.websocket.WsMessage data class Person ( val name : String , val age : Int ) fun main () { // a lens that will marshall the Person object on and off the wire val personLens = WsMessage . auto < Person > () . toLens () val server = websockets ( \"/ageMe\" bind { ws : Websocket -> ws . onMessage { val person = personLens ( it ) ws . send ( personLens . create ( person . copy ( age = person . age + 10 ))) ws . close () } } ) . asServer ( Jetty ( 8000 )) . start () val client = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/ageMe\" )) // send a message in \"native form\" - we could also use the Lens here to auto - marshall client . send ( WsMessage ( \"\"\"{ \"name\":\"bob\", \"age\": 25 }\"\"\" )) // read all of the messages from the socket until it is closed ( by the server ) . // we expect to get one message back before the stream is closed . client . received () . toList () . forEach (:: println ) server . stop () }","title":"Automarshalling Websockets messages "},{"location":"cookbook/websockets/#testing-websockets","text":"http4k provides Websockets that are both typesafe (via the Lens API), and testable. Both WsHandlers and PolyHandlers are convertible to a WsClient which provides a synchronous API for testing reactions to Websocket events in an offline environment. In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. http4k provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic: package cookbook . websockets import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.WebsocketClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Uri import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.testing.testWsClient import org.http4k.websocket.Websocket import org.http4k.websocket.WsClient import org.http4k.websocket.WsHandler import org.http4k.websocket.WsMessage import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test val namePath = Path . of ( \"name\" ) // here is our websocket app - it uses dynamic path binding and lenses val testApp : WsHandler = websockets ( \"/{name}\" bind { ws : Websocket -> val name = namePath ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) } ) // this is the abstract contract that defines the behaviour to be tested abstract class WebsocketContract { // subclasses only have to supply a blocking WsClient abstract fun client (): WsClient @Test fun `echoes back connected name` () { assertThat ( client () . received () . take ( 1 ) . toList (), equalTo ( listOf ( WsMessage ( \"hello bob\" )))) } } // a unit test version of the contract - it connects to the websocket in memory with no network class WebsocketUnitTest : WebsocketContract () { override fun client () = testApp . testWsClient ( Request ( GET , \"/bob\" )) !! } // a integration test version of the contract - it starts a server and connects to the websocket over the network class WebsocketServerTest : WebsocketContract () { override fun client () = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/bob\" )) private val server = testApp . asServer ( Jetty ( 8000 )) @BeforeEach fun before () { server . start () } @AfterEach fun after () { server . stop () } }","title":"Testing Websockets "},{"location":"faq/","text":"Find here answers to the most common questions that we get asked about http4k General Q. Is http4k a library or a framework? A. Although it has many of the features of a framework, we consider http4k to be a library which adds a common HTTP routing layer. It is incredibly unopinionated and has been designed to not enforce design decisions on the API user. We use http4k for applications both large and small, using no DI framework. Q. Is http4k currently used in production? A. Absolutely! Whilst overall stats are obviously hard to come by, the biggest known usage of the library is serving the global site traffic (rank ~700 globally) for a large academic publisher, easily serving 10s of millions of requests per day on a few nodes. Additionally judging from the download stats and interest in the Slack channel indicate that take-up is increasing nicely. http4k also appears in the Thoughtworks Tech Radar , which covers useful and upcoming technologies used in Thoughtworks-delivered projects. If you're running http4k in production and would like to be listed on the site as an adopter, please get in touch. Q. Does http4k support an Async model? I need webscale! A. Not at the moment. Adding Async support is a decision that we are thinking about carefully so that we don't end up complicating the API. When we do add it, it'll use co-routines model so we also want to ensure that the integrations with the various backends and clients are solid, as well as supporting essential features that currently rely on Threads, such as Zipkin Request Tracing and Resilience4j support. As for the scaling arguments, see the above answer relating to production usage, or checkout the benchmark results to see how http4k compares to other JVM-based sync and async web libraries. API Q. I'm attempting to build HTTP messages using the API, but changes don't affect the object (e.g. calling request.body(\"hello\") )? A. http4k HTTP message objects are immutable , so you need to chain or reassign the value from the method call to get the updated version. Q. Where are all the useful Filters defined? A. Filters are all in the import org.http4k.filter package and are located as methods on a singleton object relevant to their use: org.http4k.filter.CachingFilters.Request & org.http4k.filter.CachingFilters.Response org.http4k.filter.ClientFilters org.http4k.filter.DebuggingFilters org.http4k.filter.ServerFilters org.http4k.filter.TrafficFilters Lenses & Auto-Marshalling Q. I am having a problem with the usage of Jackson or GSON for auto marshalling A. Please see the custom FAQ for JSON handling questions. Q. My application uses Lenses, but when they fail I get an HTTP 500 instead of the promised 400. A. You forgot to add the ServerFilters.CatchLensFailure filter to your Server stack.","title":"FAQ"},{"location":"faq/#general","text":"Q. Is http4k a library or a framework? A. Although it has many of the features of a framework, we consider http4k to be a library which adds a common HTTP routing layer. It is incredibly unopinionated and has been designed to not enforce design decisions on the API user. We use http4k for applications both large and small, using no DI framework. Q. Is http4k currently used in production? A. Absolutely! Whilst overall stats are obviously hard to come by, the biggest known usage of the library is serving the global site traffic (rank ~700 globally) for a large academic publisher, easily serving 10s of millions of requests per day on a few nodes. Additionally judging from the download stats and interest in the Slack channel indicate that take-up is increasing nicely. http4k also appears in the Thoughtworks Tech Radar , which covers useful and upcoming technologies used in Thoughtworks-delivered projects. If you're running http4k in production and would like to be listed on the site as an adopter, please get in touch. Q. Does http4k support an Async model? I need webscale! A. Not at the moment. Adding Async support is a decision that we are thinking about carefully so that we don't end up complicating the API. When we do add it, it'll use co-routines model so we also want to ensure that the integrations with the various backends and clients are solid, as well as supporting essential features that currently rely on Threads, such as Zipkin Request Tracing and Resilience4j support. As for the scaling arguments, see the above answer relating to production usage, or checkout the benchmark results to see how http4k compares to other JVM-based sync and async web libraries.","title":"General"},{"location":"faq/#api","text":"Q. I'm attempting to build HTTP messages using the API, but changes don't affect the object (e.g. calling request.body(\"hello\") )? A. http4k HTTP message objects are immutable , so you need to chain or reassign the value from the method call to get the updated version. Q. Where are all the useful Filters defined? A. Filters are all in the import org.http4k.filter package and are located as methods on a singleton object relevant to their use: org.http4k.filter.CachingFilters.Request & org.http4k.filter.CachingFilters.Response org.http4k.filter.ClientFilters org.http4k.filter.DebuggingFilters org.http4k.filter.ServerFilters org.http4k.filter.TrafficFilters","title":"API"},{"location":"faq/#lenses-auto-marshalling","text":"Q. I am having a problem with the usage of Jackson or GSON for auto marshalling A. Please see the custom FAQ for JSON handling questions. Q. My application uses Lenses, but when they fail I get an HTTP 500 instead of the promised 400. A. You forgot to add the ServerFilters.CatchLensFailure filter to your Server stack.","title":"Lenses &amp; Auto-Marshalling"},{"location":"guide/modules/approvaltests/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-testing-approval\", version: \"3.247.0\" About Approval testing is a form of testing which allows the expected output of a test to be specified in a non-code but still source-controlled format, such as a text file. This is a powerful alternative to traditional assertion-based tests for a number of reasons: It is often inconvenient and/or error prone to attempt to write assertions to cover the entirety of test output - examples of this include JSON, HTML or XML documents. Output may not always be in a format that can be created easily in a test. In case of a mismatch, output can be more efficiently diagnosed by the human eye. The output of a test may change significantly in a short period (this is especially true for HTML content), but we also want to tightly control the contract. The general idea for implementing this style of testing in http4k is based on the excellent okeydoke library, and is centered around the idea of comparing the output of an HTTP operation - this is generally the Response content, but it can also be the Request if we are interested in testing construction of request content. For each test-case, a named <test name>.approved file is committed (under the src/test/resources folder), against which the test output can be compared by an Approver object injected into the test method. In case of a mismatch, an equivalent <test name>.actual file is written. This file can then be verified and if ok, renamed to become the approved file. To make this operation easier in the IDE, we recommend the usage of the IntelliJ OkeyDoke plugin which adds a mouse and keyboard shortcut to rename the file. The http4k-testing-approval module implements this functionality as a JUnit5 extension that will inject the Approver automatically into test methods. Standard Approval tests By using the ApprovalTest extension, an instance of an Approver is injected into each test. Code package guide . modules . approvaltests import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasStatus import org.http4k.testing.ApprovalTest import org.http4k.testing.Approver import org.http4k.testing.assertApproved import org.http4k.testing.hasApprovedContent import org.junit.jupiter.api.Test import org.junit.jupiter.api.extension.ExtendWith @ExtendWith ( ApprovalTest :: class ) class ExampleApprovalTest { private val app : HttpHandler = { Response ( OK ) . body ( \"hello world\" ) } @Test fun `check response content` ( approver : Approver ) { approver . assertApproved ( app ( Request ( GET , \"/url\" ))) } @Test fun `check response content with expected status` ( approver : Approver ) { approver . assertApproved ( app ( Request ( GET , \"/url\" )), OK ) } @Test fun `check request content` ( approver : Approver ) { approver . assertApproved ( Request ( GET , \"/url\" ) . body ( \"foobar\" )) } @Test fun `combine approval with hamkrest matcher` ( approver : Approver ) { assertThat ( app ( Request ( GET , \"/url\" )), hasStatus ( OK ) . and ( approver . hasApprovedContent ())) } } Content-type specific Approval tests Because so many APIs are based around messages with a particular content type, the module also provides Junit 5 extensions that will: Check for the presence of the a particular content-type on the HttpMessage under test and fail if it is not valid. Validate that the HttpMessage actually contains valid content for the content type. Format and compare the approval output as pretty-printed version. Note that by default the http4k format modules use compact printing to conserve message space. The module also provides the following built-in extensions: HtmlApprovalTest JsonApprovalTest XmlApprovalTest Code package guide . modules . approvaltests import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.ContentType.Companion.APPLICATION_JSON import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.hamkrest.hasStatus import org.http4k.lens.Header.CONTENT_TYPE import org.http4k.testing.Approver import org.http4k.testing.JsonApprovalTest import org.http4k.testing.assertApproved import org.http4k.testing.hasApprovedContent import org.junit.jupiter.api.Test import org.junit.jupiter.api.extension.ExtendWith @ExtendWith ( JsonApprovalTest :: class ) class ExampleJsonApprovalTest { private val app : HttpHandler = { Response ( OK ) . with ( CONTENT_TYPE of APPLICATION_JSON ) . body ( \"\"\"{\"message\":\"value\"}\"\"\" ) } @Test fun `check response content` ( approver : Approver ) { approver . assertApproved ( app ( Request ( GET , \"/url\" ))) } @Test fun `check response content with expected status` ( approver : Approver ) { approver . assertApproved ( app ( Request ( GET , \"/url\" )), OK ) } @Test fun `check request content` ( approver : Approver ) { approver . assertApproved ( Request ( GET , \"/url\" ) . with ( CONTENT_TYPE of APPLICATION_JSON ) . body ( \"\"\"{\"message\":\"value\"}\"\"\" ) ) } @Test fun `combine approval with hamkrest matcher` ( approver : Approver ) { assertThat ( app ( Request ( GET , \"/url\" )), hasStatus ( OK ) . and ( approver . hasApprovedContent ())) } } Implementing custom JUnit Extensions As with the rest of http4k , a base implementation, BaseApprovalTest of the Junit5 Extension is provided, allowing API users to implement custom approval schemes or non-FS based approaches for storing the approval files.","title":"Approval Testing"},{"location":"guide/modules/approvaltests/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-testing-approval\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/approvaltests/#about","text":"Approval testing is a form of testing which allows the expected output of a test to be specified in a non-code but still source-controlled format, such as a text file. This is a powerful alternative to traditional assertion-based tests for a number of reasons: It is often inconvenient and/or error prone to attempt to write assertions to cover the entirety of test output - examples of this include JSON, HTML or XML documents. Output may not always be in a format that can be created easily in a test. In case of a mismatch, output can be more efficiently diagnosed by the human eye. The output of a test may change significantly in a short period (this is especially true for HTML content), but we also want to tightly control the contract. The general idea for implementing this style of testing in http4k is based on the excellent okeydoke library, and is centered around the idea of comparing the output of an HTTP operation - this is generally the Response content, but it can also be the Request if we are interested in testing construction of request content. For each test-case, a named <test name>.approved file is committed (under the src/test/resources folder), against which the test output can be compared by an Approver object injected into the test method. In case of a mismatch, an equivalent <test name>.actual file is written. This file can then be verified and if ok, renamed to become the approved file. To make this operation easier in the IDE, we recommend the usage of the IntelliJ OkeyDoke plugin which adds a mouse and keyboard shortcut to rename the file. The http4k-testing-approval module implements this functionality as a JUnit5 extension that will inject the Approver automatically into test methods.","title":"About"},{"location":"guide/modules/approvaltests/#standard-approval-tests","text":"By using the ApprovalTest extension, an instance of an Approver is injected into each test.","title":"Standard Approval tests"},{"location":"guide/modules/approvaltests/#code","text":"package guide . modules . approvaltests import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasStatus import org.http4k.testing.ApprovalTest import org.http4k.testing.Approver import org.http4k.testing.assertApproved import org.http4k.testing.hasApprovedContent import org.junit.jupiter.api.Test import org.junit.jupiter.api.extension.ExtendWith @ExtendWith ( ApprovalTest :: class ) class ExampleApprovalTest { private val app : HttpHandler = { Response ( OK ) . body ( \"hello world\" ) } @Test fun `check response content` ( approver : Approver ) { approver . assertApproved ( app ( Request ( GET , \"/url\" ))) } @Test fun `check response content with expected status` ( approver : Approver ) { approver . assertApproved ( app ( Request ( GET , \"/url\" )), OK ) } @Test fun `check request content` ( approver : Approver ) { approver . assertApproved ( Request ( GET , \"/url\" ) . body ( \"foobar\" )) } @Test fun `combine approval with hamkrest matcher` ( approver : Approver ) { assertThat ( app ( Request ( GET , \"/url\" )), hasStatus ( OK ) . and ( approver . hasApprovedContent ())) } }","title":"Code "},{"location":"guide/modules/approvaltests/#content-type-specific-approval-tests","text":"Because so many APIs are based around messages with a particular content type, the module also provides Junit 5 extensions that will: Check for the presence of the a particular content-type on the HttpMessage under test and fail if it is not valid. Validate that the HttpMessage actually contains valid content for the content type. Format and compare the approval output as pretty-printed version. Note that by default the http4k format modules use compact printing to conserve message space. The module also provides the following built-in extensions: HtmlApprovalTest JsonApprovalTest XmlApprovalTest","title":"Content-type specific Approval tests"},{"location":"guide/modules/approvaltests/#code_1","text":"package guide . modules . approvaltests import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.ContentType.Companion.APPLICATION_JSON import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.hamkrest.hasStatus import org.http4k.lens.Header.CONTENT_TYPE import org.http4k.testing.Approver import org.http4k.testing.JsonApprovalTest import org.http4k.testing.assertApproved import org.http4k.testing.hasApprovedContent import org.junit.jupiter.api.Test import org.junit.jupiter.api.extension.ExtendWith @ExtendWith ( JsonApprovalTest :: class ) class ExampleJsonApprovalTest { private val app : HttpHandler = { Response ( OK ) . with ( CONTENT_TYPE of APPLICATION_JSON ) . body ( \"\"\"{\"message\":\"value\"}\"\"\" ) } @Test fun `check response content` ( approver : Approver ) { approver . assertApproved ( app ( Request ( GET , \"/url\" ))) } @Test fun `check response content with expected status` ( approver : Approver ) { approver . assertApproved ( app ( Request ( GET , \"/url\" )), OK ) } @Test fun `check request content` ( approver : Approver ) { approver . assertApproved ( Request ( GET , \"/url\" ) . with ( CONTENT_TYPE of APPLICATION_JSON ) . body ( \"\"\"{\"message\":\"value\"}\"\"\" ) ) } @Test fun `combine approval with hamkrest matcher` ( approver : Approver ) { assertThat ( app ( Request ( GET , \"/url\" )), hasStatus ( OK ) . and ( approver . hasApprovedContent ())) } }","title":"Code "},{"location":"guide/modules/approvaltests/#implementing-custom-junit-extensions","text":"As with the rest of http4k , a base implementation, BaseApprovalTest of the Junit5 Extension is provided, allowing API users to implement custom approval schemes or non-FS based approaches for storing the approval files.","title":"Implementing custom JUnit Extensions"},{"location":"guide/modules/aws/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-aws\", version: \"3.247.0\" About This module provides super-simple AWS request signing functionality for talking to AWS services. Once configured with the correct keys, the various AWS services are actually really simple to integrate with they're just RESTy-type HTTPS services - the main difficulty is that all requests need to have their contents digitally signed with the AWS credentials to be authorised. http4k provides a Filter which does this request signing process. Just decorate a standard HTTP client and then make the relevant calls: Code package guide . modules . aws import org.http4k.aws.AwsCredentialScope import org.http4k.aws.AwsCredentials import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Method.PUT import org.http4k.core.Request import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.AwsAuth import org.http4k.filter.ClientFilters import java.util.UUID fun main () { val region = \"us-east-1\" val service = \"s3\" val accessKey = \"myGreatAwsAccessKey\" val secretKey = \"myGreatAwsSecretKey\" val client = ClientFilters . AwsAuth ( AwsCredentialScope ( region , service ), AwsCredentials ( accessKey , secretKey )) . then ( ApacheClient ()) // create a bucket val bucketName = UUID . randomUUID () . toString () val bucketUri = Uri . of ( \"https://$bucketName.s3.amazonaws.com/\" ) println ( client ( Request ( PUT , bucketUri ))) // get list of buckets with the new bucket in it println ( client ( Request ( GET , Uri . of ( \"https://s3.amazonaws.com/\" ))) . bodyString ()) // create a key into the bucket val key = UUID . randomUUID () . toString () val keyUri = Uri . of ( \"https://$bucketName.s3.amazonaws.com/$key\" ) println ( client ( Request ( PUT , keyUri ) . body ( \"some amazing content that I want stored on S3\" ))) // get the keys in the bucket println ( client ( Request ( GET , bucketUri ))) // get the contents of the key in the bucket println ( client ( Request ( GET , keyUri ))) // delete the key in the bucket println ( client ( Request ( GET , keyUri ))) // delete the bucket println ( client ( Request ( GET , bucketUri ))) }","title":"AWS"},{"location":"guide/modules/aws/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-aws\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/aws/#about","text":"This module provides super-simple AWS request signing functionality for talking to AWS services. Once configured with the correct keys, the various AWS services are actually really simple to integrate with they're just RESTy-type HTTPS services - the main difficulty is that all requests need to have their contents digitally signed with the AWS credentials to be authorised. http4k provides a Filter which does this request signing process. Just decorate a standard HTTP client and then make the relevant calls:","title":"About"},{"location":"guide/modules/aws/#code","text":"package guide . modules . aws import org.http4k.aws.AwsCredentialScope import org.http4k.aws.AwsCredentials import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Method.PUT import org.http4k.core.Request import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.AwsAuth import org.http4k.filter.ClientFilters import java.util.UUID fun main () { val region = \"us-east-1\" val service = \"s3\" val accessKey = \"myGreatAwsAccessKey\" val secretKey = \"myGreatAwsSecretKey\" val client = ClientFilters . AwsAuth ( AwsCredentialScope ( region , service ), AwsCredentials ( accessKey , secretKey )) . then ( ApacheClient ()) // create a bucket val bucketName = UUID . randomUUID () . toString () val bucketUri = Uri . of ( \"https://$bucketName.s3.amazonaws.com/\" ) println ( client ( Request ( PUT , bucketUri ))) // get list of buckets with the new bucket in it println ( client ( Request ( GET , Uri . of ( \"https://s3.amazonaws.com/\" ))) . bodyString ()) // create a key into the bucket val key = UUID . randomUUID () . toString () val keyUri = Uri . of ( \"https://$bucketName.s3.amazonaws.com/$key\" ) println ( client ( Request ( PUT , keyUri ) . body ( \"some amazing content that I want stored on S3\" ))) // get the keys in the bucket println ( client ( Request ( GET , bucketUri ))) // get the contents of the key in the bucket println ( client ( Request ( GET , keyUri ))) // delete the key in the bucket println ( client ( Request ( GET , keyUri ))) // delete the bucket println ( client ( Request ( GET , bucketUri ))) }","title":"Code "},{"location":"guide/modules/chaos/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-testing-chaos\", version: \"3.247.0\" About The http4k Chaos module provides the facility to statically or dynamically inject failure modes into http4k applications, such as random HTTP failures, killing of processes, and extra latency injection. By modelling these modes, it is possible to plan for mitigation of particular scenarios on a wider scale, resulting either from failures within your system boundary, or those caused by dependent remote HTTP services. The Principles of Chaos Engineering approach was made prominent by Netflix open-sourcing the Simian Army libraries. API concepts To understand the API, these domain-language concepts are important, all modelled as simple Kotlin typealiases and interfaces in order that API users can create their own: Behaviours: typealias Behaviour = Filter A Behaviour applies the failure mode to the HTTP call. This could involve blocking a thread permanently, introducing extra latency into an HTTP service, or even causing a Stack Overflow or Killing the running process. Behaviour function Effect as JSON Latency Adds random latency to a call between the min and max durations {\"type\":\"latency\",\"min\":\"PT0.1S\",\"max\":\"PT0.3S\"} ThrowException Throws an uncaught Exception with the supplied message {\"type\":\"throw\",\"message\":\"foo\"} ReturnStatus Returns an HTTP response with the specified HTTP status code {\"type\":\"status\",\"status\":404} NoBody Completes the call normally, but strips the body content from the response {\"type\":\"body\"} EatMemory Forces an OOM exception {\"type\":\"memory\"} KillProcess Kills the Java process with a 1 error code {\"type\":\"kill\"} StackOverflow Generates a StackOverflow {\"type\":\"overflow\"} BlockThread Permanently blocks the request thread {\"type\":\"block\"} None Requests complete normally {\"type\":\"none\"} Triggers: typealias Trigger = (req: Request) -> Boolean A Trigger is just a predicate which determines if an HTTP call should have an Behaviour applied to it. Triggers can be stateless, based on the request content, or stateful - deadlines or countdowns. Trigger function Activation condition as JSON Deadline After an instant in time {\"type\":\"deadline\",\"endTime\":\"1970-01-01T00:00:00Z\"} Delay After a specified period (since construction) {\"type\":\"delay\",\"period\":\"PT0.1S\"} Countdown For the first n requests only {\"type\":\"countdown\",\"count\":\"1\"} Request If the request meets the criteria set out in the specification. All but method are Regex patterns, and all are optional {\"type\":\"request\",\"method\":\"get\",\"path\":\".*bob\",\"queries\":{\"query\":\".*query\"},\"headers\":{\"header\":\".*header\"},\"body\":\".*body\"} Once For the first request only {\"type\":\"once\"} PercentageBased Applies to a certain (randomly decided) percentage of requests {\"type\":\"percentage\", \"percentage\":100} Always For all requests {\"type\":\"always\"} Stages: interface Stage: (Request) -> Filter? A Stage provides the lifecycle for applying a behaviour, and applies until a Trigger indicates that the stage is complete. Stages can be chained with then() , or can be produced by combining a Behaviour and a Trigger using appliedWhen() . Stage function Lifecycle notes as JSON Wait Does nothing while active {\"type\":\"wait\",\"until\":<insert trigger json>} Repeat Loops through the stages and then repeats {\"type\":\"repeat\",\"stages\":[<insert stage json elements>],\"until\":<insert trigger json>} (Triggered) Combines a Trigger and a Behaviour {\"type\":\"trigger\",\"behaviour\":{\"type\":\"body\"},\"trigger\":<insert trigger json>,\"until\":<insert trigger json>}} Manually injecting Chaos For use in automated test suites, it is simple to define the Chaos behaviour programmatically using the API and then use the ChaosEngine to add it onto an existing application. Code package guide . modules . chaos import org.http4k.chaos.ChaosBehaviours.ReturnStatus import org.http4k.chaos.ChaosEngine import org.http4k.chaos.ChaosStages.Wait import org.http4k.chaos.ChaosTriggers.PercentageBased import org.http4k.chaos.appliedWhen import org.http4k.chaos.then import org.http4k.chaos.until import org.http4k.client.OkHttp import org.http4k.core.HttpHandler import org.http4k.core.Method import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.INTERNAL_SERVER_ERROR import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.server.SunHttp import org.http4k.server.asServer val client = OkHttp () fun main () { // chaos is split into \"stages\" , which can be triggered by specific request or time - based criteria val doNothingStage = Wait . until { tx : Request -> tx . method == POST } val errorStage = ReturnStatus ( INTERNAL_SERVER_ERROR ) . appliedWhen ( PercentageBased ( 50 )) // chain the stages together with then () and create the Chaos Engine ( activated ) val engine = ChaosEngine ( doNothingStage . then ( errorStage )) . enable () val svc : HttpHandler = { Response ( OK ) . body ( \"A normal response\" ) } engine . then ( svc ) . asServer ( SunHttp ( 9000 )) . start () . use { repeat ( 10 ) { performA ( GET ) } // this triggers the change in behaviour performA ( POST ) repeat ( 10 ) { performA ( GET ) } // disable the chaos engine . disable () repeat ( 10 ) { performA ( GET ) } } } fun performA ( method : Method ) = println ( method . name + \" got a \" + client ( Request ( method , \"http://localhost:9000\" )) . status ) Dynamic behaviour injection using Chaos Controls For use in deployed environments or when experimenting with the reaction of systems to failure, there is the need to vary (and otherwise control) the Chaos behaviour that an application or downstream fake exhibits, in order to simulate periods of failures and then observe the after-effects. The module contains a simple extension method HttpHandler.withChaosEngine() that decorates an existing http4k application with the ability to dynamically inject Chaos behaviour using a set of RPC-style endpoints. This API is presented via an OpenAPI specification, which allows it to be controlled by a simple Swagger client. Apart from being able to turn the Chaos on/off and check the status, the most powerful endpoint in ChaosEngine lives at /activate/new . By POSTing a JSON definition of the required behaviour, this JSON is deserialised into actual Chaos behaviours which can be then activated in the application. The supported JSON formats of the various Chaos concepts are defined above, but by way of an example, POSTing this piece of JSON would: Wait for 100 seconds Always return an HTTP 404 (Not Found) status for 10 requests Repeat the above until Big Ben strikes in the New Year 2020. [ { \"type\" : \"repeat\" , \"stages\" : [ { \"type\" : \"wait\" , \"until\" : { \"type\" : \"delay\" , \"period\" : \"PT100S\" } }, { \"type\" : \"trigger\" , \"behaviour\" : { \"type\" : \"status\" , \"status\" : 404 }, \"trigger\" : { \"type\" : \"always\" }, \"until\" : { \"type\" : \"countdown\" , \"count\" : \"10\" } } ], \"until\" : { \"type\" : \"deadline\" , \"endTime\" : \"2020-01-01T00:00:00Z\" } } ] Code package guide . modules . chaos import org.http4k.chaos.withChaosApi import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.CorsPolicy.Companion.UnsafeGlobalPermissive import org.http4k.filter.ServerFilters import org.http4k.filter.ServerFilters.Cors import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { Cors ( UnsafeGlobalPermissive ) . then ( ServerFilters . CatchAll ()) . then { Response ( OK ) . body ( \"A normal response\" ) } . withChaosApi () . asServer ( SunHttp ( 9000 )) . start () . also { println ( \"Visit the app at http://localhost:9000 or see the OpenApi at https://www.http4k.org/openapi3/?url=http://localhost:9000/chaos\" ) } } Interacting with ChaosEngine using an HTTP client Code package guide . modules . chaos import org.http4k.chaos.ChaosBehaviours.ReturnStatus import org.http4k.chaos.ChaosEngine import org.http4k.chaos.withChaosApi import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.NOT_FOUND import org.http4k.core.Status.Companion.OK import org.http4k.routing.bind import org.http4k.routing.routes fun main () { val app = routes ( \"/\" bind routes ( \"/\" bind GET to { Response ( OK ) . body ( \"hello!\" ) })) val appWithChaos = app . withChaosApi ( ChaosEngine ( ReturnStatus ( NOT_FOUND ))) println ( \">>chaos is deactivated by default\" ) println ( appWithChaos ( Request ( GET , \"/chaos/status\" )) . bodyString ()) println ( appWithChaos ( Request ( GET , \"/\" )) . status ) println ( \">>activate the default chaos\" ) println ( appWithChaos ( Request ( POST , \"/chaos/activate\" )) . bodyString ()) println ( appWithChaos ( Request ( GET , \"/\" )) . status ) println ( \">>deactivate the default chaos\" ) println ( appWithChaos ( Request ( POST , \"/chaos/deactivate\" )) . bodyString ()) println ( appWithChaos ( Request ( GET , \"/\" )) . status ) println ( \">>set the chaos dynamically\" ) val alwaysReturn418 = \"\"\"[ { \"type\": \"trigger\", \"behaviour\": { \"type\": \"status\", \"status\": 418 }, \"trigger\": { \"type\": \"always\" } }] \"\"\" . trimIndent () println ( appWithChaos ( Request ( POST , \"/chaos/activate/new\" ) . body ( alwaysReturn418 )) . bodyString ()) println ( appWithChaos ( Request ( GET , \"/\" )) . status ) }","title":"Chaos Testing"},{"location":"guide/modules/chaos/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-testing-chaos\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/chaos/#about","text":"The http4k Chaos module provides the facility to statically or dynamically inject failure modes into http4k applications, such as random HTTP failures, killing of processes, and extra latency injection. By modelling these modes, it is possible to plan for mitigation of particular scenarios on a wider scale, resulting either from failures within your system boundary, or those caused by dependent remote HTTP services. The Principles of Chaos Engineering approach was made prominent by Netflix open-sourcing the Simian Army libraries.","title":"About"},{"location":"guide/modules/chaos/#api-concepts","text":"To understand the API, these domain-language concepts are important, all modelled as simple Kotlin typealiases and interfaces in order that API users can create their own:","title":"API concepts"},{"location":"guide/modules/chaos/#behaviours-typealias-behaviour-filter","text":"A Behaviour applies the failure mode to the HTTP call. This could involve blocking a thread permanently, introducing extra latency into an HTTP service, or even causing a Stack Overflow or Killing the running process. Behaviour function Effect as JSON Latency Adds random latency to a call between the min and max durations {\"type\":\"latency\",\"min\":\"PT0.1S\",\"max\":\"PT0.3S\"} ThrowException Throws an uncaught Exception with the supplied message {\"type\":\"throw\",\"message\":\"foo\"} ReturnStatus Returns an HTTP response with the specified HTTP status code {\"type\":\"status\",\"status\":404} NoBody Completes the call normally, but strips the body content from the response {\"type\":\"body\"} EatMemory Forces an OOM exception {\"type\":\"memory\"} KillProcess Kills the Java process with a 1 error code {\"type\":\"kill\"} StackOverflow Generates a StackOverflow {\"type\":\"overflow\"} BlockThread Permanently blocks the request thread {\"type\":\"block\"} None Requests complete normally {\"type\":\"none\"}","title":"Behaviours: typealias Behaviour = Filter"},{"location":"guide/modules/chaos/#triggers-typealias-trigger-req-request-boolean","text":"A Trigger is just a predicate which determines if an HTTP call should have an Behaviour applied to it. Triggers can be stateless, based on the request content, or stateful - deadlines or countdowns. Trigger function Activation condition as JSON Deadline After an instant in time {\"type\":\"deadline\",\"endTime\":\"1970-01-01T00:00:00Z\"} Delay After a specified period (since construction) {\"type\":\"delay\",\"period\":\"PT0.1S\"} Countdown For the first n requests only {\"type\":\"countdown\",\"count\":\"1\"} Request If the request meets the criteria set out in the specification. All but method are Regex patterns, and all are optional {\"type\":\"request\",\"method\":\"get\",\"path\":\".*bob\",\"queries\":{\"query\":\".*query\"},\"headers\":{\"header\":\".*header\"},\"body\":\".*body\"} Once For the first request only {\"type\":\"once\"} PercentageBased Applies to a certain (randomly decided) percentage of requests {\"type\":\"percentage\", \"percentage\":100} Always For all requests {\"type\":\"always\"}","title":"Triggers: typealias Trigger = (req: Request) -&gt; Boolean"},{"location":"guide/modules/chaos/#stages-interface-stage-request-filter","text":"A Stage provides the lifecycle for applying a behaviour, and applies until a Trigger indicates that the stage is complete. Stages can be chained with then() , or can be produced by combining a Behaviour and a Trigger using appliedWhen() . Stage function Lifecycle notes as JSON Wait Does nothing while active {\"type\":\"wait\",\"until\":<insert trigger json>} Repeat Loops through the stages and then repeats {\"type\":\"repeat\",\"stages\":[<insert stage json elements>],\"until\":<insert trigger json>} (Triggered) Combines a Trigger and a Behaviour {\"type\":\"trigger\",\"behaviour\":{\"type\":\"body\"},\"trigger\":<insert trigger json>,\"until\":<insert trigger json>}}","title":"Stages: interface Stage: (Request) -&gt; Filter?"},{"location":"guide/modules/chaos/#manually-injecting-chaos","text":"For use in automated test suites, it is simple to define the Chaos behaviour programmatically using the API and then use the ChaosEngine to add it onto an existing application.","title":"Manually injecting Chaos"},{"location":"guide/modules/chaos/#code","text":"package guide . modules . chaos import org.http4k.chaos.ChaosBehaviours.ReturnStatus import org.http4k.chaos.ChaosEngine import org.http4k.chaos.ChaosStages.Wait import org.http4k.chaos.ChaosTriggers.PercentageBased import org.http4k.chaos.appliedWhen import org.http4k.chaos.then import org.http4k.chaos.until import org.http4k.client.OkHttp import org.http4k.core.HttpHandler import org.http4k.core.Method import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.INTERNAL_SERVER_ERROR import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.server.SunHttp import org.http4k.server.asServer val client = OkHttp () fun main () { // chaos is split into \"stages\" , which can be triggered by specific request or time - based criteria val doNothingStage = Wait . until { tx : Request -> tx . method == POST } val errorStage = ReturnStatus ( INTERNAL_SERVER_ERROR ) . appliedWhen ( PercentageBased ( 50 )) // chain the stages together with then () and create the Chaos Engine ( activated ) val engine = ChaosEngine ( doNothingStage . then ( errorStage )) . enable () val svc : HttpHandler = { Response ( OK ) . body ( \"A normal response\" ) } engine . then ( svc ) . asServer ( SunHttp ( 9000 )) . start () . use { repeat ( 10 ) { performA ( GET ) } // this triggers the change in behaviour performA ( POST ) repeat ( 10 ) { performA ( GET ) } // disable the chaos engine . disable () repeat ( 10 ) { performA ( GET ) } } } fun performA ( method : Method ) = println ( method . name + \" got a \" + client ( Request ( method , \"http://localhost:9000\" )) . status )","title":"Code "},{"location":"guide/modules/chaos/#dynamic-behaviour-injection-using-chaos-controls","text":"For use in deployed environments or when experimenting with the reaction of systems to failure, there is the need to vary (and otherwise control) the Chaos behaviour that an application or downstream fake exhibits, in order to simulate periods of failures and then observe the after-effects. The module contains a simple extension method HttpHandler.withChaosEngine() that decorates an existing http4k application with the ability to dynamically inject Chaos behaviour using a set of RPC-style endpoints. This API is presented via an OpenAPI specification, which allows it to be controlled by a simple Swagger client. Apart from being able to turn the Chaos on/off and check the status, the most powerful endpoint in ChaosEngine lives at /activate/new . By POSTing a JSON definition of the required behaviour, this JSON is deserialised into actual Chaos behaviours which can be then activated in the application. The supported JSON formats of the various Chaos concepts are defined above, but by way of an example, POSTing this piece of JSON would: Wait for 100 seconds Always return an HTTP 404 (Not Found) status for 10 requests Repeat the above until Big Ben strikes in the New Year 2020. [ { \"type\" : \"repeat\" , \"stages\" : [ { \"type\" : \"wait\" , \"until\" : { \"type\" : \"delay\" , \"period\" : \"PT100S\" } }, { \"type\" : \"trigger\" , \"behaviour\" : { \"type\" : \"status\" , \"status\" : 404 }, \"trigger\" : { \"type\" : \"always\" }, \"until\" : { \"type\" : \"countdown\" , \"count\" : \"10\" } } ], \"until\" : { \"type\" : \"deadline\" , \"endTime\" : \"2020-01-01T00:00:00Z\" } } ]","title":"Dynamic behaviour injection using Chaos Controls"},{"location":"guide/modules/chaos/#code_1","text":"package guide . modules . chaos import org.http4k.chaos.withChaosApi import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.CorsPolicy.Companion.UnsafeGlobalPermissive import org.http4k.filter.ServerFilters import org.http4k.filter.ServerFilters.Cors import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { Cors ( UnsafeGlobalPermissive ) . then ( ServerFilters . CatchAll ()) . then { Response ( OK ) . body ( \"A normal response\" ) } . withChaosApi () . asServer ( SunHttp ( 9000 )) . start () . also { println ( \"Visit the app at http://localhost:9000 or see the OpenApi at https://www.http4k.org/openapi3/?url=http://localhost:9000/chaos\" ) } }","title":"Code "},{"location":"guide/modules/chaos/#interacting-with-chaosengine-using-an-http-client","text":"","title":"Interacting with ChaosEngine using an HTTP client"},{"location":"guide/modules/chaos/#code_2","text":"package guide . modules . chaos import org.http4k.chaos.ChaosBehaviours.ReturnStatus import org.http4k.chaos.ChaosEngine import org.http4k.chaos.withChaosApi import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.NOT_FOUND import org.http4k.core.Status.Companion.OK import org.http4k.routing.bind import org.http4k.routing.routes fun main () { val app = routes ( \"/\" bind routes ( \"/\" bind GET to { Response ( OK ) . body ( \"hello!\" ) })) val appWithChaos = app . withChaosApi ( ChaosEngine ( ReturnStatus ( NOT_FOUND ))) println ( \">>chaos is deactivated by default\" ) println ( appWithChaos ( Request ( GET , \"/chaos/status\" )) . bodyString ()) println ( appWithChaos ( Request ( GET , \"/\" )) . status ) println ( \">>activate the default chaos\" ) println ( appWithChaos ( Request ( POST , \"/chaos/activate\" )) . bodyString ()) println ( appWithChaos ( Request ( GET , \"/\" )) . status ) println ( \">>deactivate the default chaos\" ) println ( appWithChaos ( Request ( POST , \"/chaos/deactivate\" )) . bodyString ()) println ( appWithChaos ( Request ( GET , \"/\" )) . status ) println ( \">>set the chaos dynamically\" ) val alwaysReturn418 = \"\"\"[ { \"type\": \"trigger\", \"behaviour\": { \"type\": \"status\", \"status\": 418 }, \"trigger\": { \"type\": \"always\" } }] \"\"\" . trimIndent () println ( appWithChaos ( Request ( POST , \"/chaos/activate/new\" ) . body ( alwaysReturn418 )) . bodyString ()) println ( appWithChaos ( Request ( GET , \"/\" )) . status ) }","title":"Code "},{"location":"guide/modules/clients/","text":"Installation (Gradle) Java (for development only): compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Apache (Sync): compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"3.247.0\" Apache (Async): compile group: \"org.http4k\", name: \"http4k-client-apache-async\", version: \"3.247.0\" Jetty (Sync + Async): compile group: \"org.http4k\", name: \"http4k-client-jetty\", version: \"3.247.0\" OkHttp (Sync + Async): compile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"3.247.0\" Websocket: compile group: \"org.http4k\", name: \"http4k-client-websocket\", version: \"3.247.0\" HTTP Supported HTTP client adapter APIs are wrapped to provide an HttpHandler interface in 1 LOC. Activate streaming mode by passing a BodyMode (default is non-streaming). These examples are for the Apache HTTP client, but the API is similar for the others: Code package guide . modules . clients import org.apache.http.client.config.CookieSpecs import org.apache.http.client.config.RequestConfig import org.apache.http.impl.client.HttpClients import org.http4k.client.ApacheAsyncClient import org.http4k.client.ApacheClient import org.http4k.core.BodyMode import org.http4k.core.Method.GET import org.http4k.core.Request import kotlin.concurrent.thread fun main () { // standard client val client = ApacheClient () val request = Request ( GET , \"http://httpbin.org/get\" ) . query ( \"location\" , \"John Doe\" ) val response = client ( request ) println ( \"SYNC\" ) println ( response . status ) println ( response . bodyString ()) // streaming client val streamingClient = ApacheClient ( responseBodyMode = BodyMode . Stream ) val streamingRequest = Request ( GET , \"http://httpbin.org/stream/100\" ) println ( \"STREAM\" ) println ( streamingClient ( streamingRequest ) . bodyString ()) // async supporting clients can be passed a callback ... val asyncClient = ApacheAsyncClient () asyncClient ( Request ( GET , \"http://httpbin.org/stream/5\" )) { println ( \"ASYNC\" ) println ( it . status ) println ( it . bodyString ()) } // ... but must be closed thread { Thread . sleep ( 500 ) asyncClient . close () } // custom configured client val customClient = ApacheClient ( client = HttpClients . custom () . setDefaultRequestConfig ( RequestConfig . custom () . setRedirectsEnabled ( false ) . setCookieSpec ( CookieSpecs . IGNORE_COOKIES ) . build ()) . build () ) } Additionally, all HTTP client adapter modules allow for custom configuration of the relevant underlying client. Async-supporting clients implement the AsyncHttpClient interface can be passed a callback. Websocket http4k supplies both blocking and non-blocking Websocket clients. The former is perfect for integration testing purposes, and as it uses the same interface WsClient as the in-memory test client ( WsHandler.testWsClient() ) it is simple to write unit tests which can then be reused as system tests by virtue of swapping out the client. Code package guide . modules . clients import org.http4k.client.WebsocketClient import org.http4k.core.Uri import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.Websocket import org.http4k.websocket.WsMessage fun main () { // a standard websocket app val server = websockets ( \"/bob\" bind { ws : Websocket -> ws . send ( WsMessage ( \"bob\" )) ws . onMessage { println ( \"server received: \" + it ) ws . send ( it ) } } ) . asServer ( Jetty ( 8000 )) . start () // blocking client - connection is done on construction val blockingClient = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/bob\" )) blockingClient . send ( WsMessage ( \"server sent on connection\" )) blockingClient . received () . take ( 2 ) . forEach { println ( \"blocking client received: \" + it ) } blockingClient . close () // non - blocking client - exposes a Websocket interface for attaching listeners , // and connection is done on construction , but doesn 't block - the (optional) handler // passed to the construction is called on connection . val nonBlockingClient = WebsocketClient . nonBlocking ( Uri . of ( \"ws://localhost:8000/bob\" )) { it . run { send ( WsMessage ( \"client sent on connection\" )) } } nonBlockingClient . onMessage { println ( \"non-blocking client received:\" + it ) } nonBlockingClient . onClose { println ( \"non-blocking client closing\" ) } Thread . sleep ( 100 ) server . stop () }","title":"HTTP & Websocket clients"},{"location":"guide/modules/clients/#installation-gradle","text":"Java (for development only): compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" Apache (Sync): compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"3.247.0\" Apache (Async): compile group: \"org.http4k\", name: \"http4k-client-apache-async\", version: \"3.247.0\" Jetty (Sync + Async): compile group: \"org.http4k\", name: \"http4k-client-jetty\", version: \"3.247.0\" OkHttp (Sync + Async): compile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"3.247.0\" Websocket: compile group: \"org.http4k\", name: \"http4k-client-websocket\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/clients/#http","text":"Supported HTTP client adapter APIs are wrapped to provide an HttpHandler interface in 1 LOC. Activate streaming mode by passing a BodyMode (default is non-streaming). These examples are for the Apache HTTP client, but the API is similar for the others:","title":"HTTP"},{"location":"guide/modules/clients/#code","text":"package guide . modules . clients import org.apache.http.client.config.CookieSpecs import org.apache.http.client.config.RequestConfig import org.apache.http.impl.client.HttpClients import org.http4k.client.ApacheAsyncClient import org.http4k.client.ApacheClient import org.http4k.core.BodyMode import org.http4k.core.Method.GET import org.http4k.core.Request import kotlin.concurrent.thread fun main () { // standard client val client = ApacheClient () val request = Request ( GET , \"http://httpbin.org/get\" ) . query ( \"location\" , \"John Doe\" ) val response = client ( request ) println ( \"SYNC\" ) println ( response . status ) println ( response . bodyString ()) // streaming client val streamingClient = ApacheClient ( responseBodyMode = BodyMode . Stream ) val streamingRequest = Request ( GET , \"http://httpbin.org/stream/100\" ) println ( \"STREAM\" ) println ( streamingClient ( streamingRequest ) . bodyString ()) // async supporting clients can be passed a callback ... val asyncClient = ApacheAsyncClient () asyncClient ( Request ( GET , \"http://httpbin.org/stream/5\" )) { println ( \"ASYNC\" ) println ( it . status ) println ( it . bodyString ()) } // ... but must be closed thread { Thread . sleep ( 500 ) asyncClient . close () } // custom configured client val customClient = ApacheClient ( client = HttpClients . custom () . setDefaultRequestConfig ( RequestConfig . custom () . setRedirectsEnabled ( false ) . setCookieSpec ( CookieSpecs . IGNORE_COOKIES ) . build ()) . build () ) } Additionally, all HTTP client adapter modules allow for custom configuration of the relevant underlying client. Async-supporting clients implement the AsyncHttpClient interface can be passed a callback.","title":"Code "},{"location":"guide/modules/clients/#websocket","text":"http4k supplies both blocking and non-blocking Websocket clients. The former is perfect for integration testing purposes, and as it uses the same interface WsClient as the in-memory test client ( WsHandler.testWsClient() ) it is simple to write unit tests which can then be reused as system tests by virtue of swapping out the client.","title":"Websocket"},{"location":"guide/modules/clients/#code_1","text":"package guide . modules . clients import org.http4k.client.WebsocketClient import org.http4k.core.Uri import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.websocket.Websocket import org.http4k.websocket.WsMessage fun main () { // a standard websocket app val server = websockets ( \"/bob\" bind { ws : Websocket -> ws . send ( WsMessage ( \"bob\" )) ws . onMessage { println ( \"server received: \" + it ) ws . send ( it ) } } ) . asServer ( Jetty ( 8000 )) . start () // blocking client - connection is done on construction val blockingClient = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/bob\" )) blockingClient . send ( WsMessage ( \"server sent on connection\" )) blockingClient . received () . take ( 2 ) . forEach { println ( \"blocking client received: \" + it ) } blockingClient . close () // non - blocking client - exposes a Websocket interface for attaching listeners , // and connection is done on construction , but doesn 't block - the (optional) handler // passed to the construction is called on connection . val nonBlockingClient = WebsocketClient . nonBlocking ( Uri . of ( \"ws://localhost:8000/bob\" )) { it . run { send ( WsMessage ( \"client sent on connection\" )) } } nonBlockingClient . onMessage { println ( \"non-blocking client received:\" + it ) } nonBlockingClient . onClose { println ( \"non-blocking client closing\" ) } Thread . sleep ( 100 ) server . stop () }","title":"Code "},{"location":"guide/modules/cloud_native/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-cloudnative\", version: \"3.247.0\" http4k applications are naturally at home operating in distributed, Cloud Native environments. Whilst simple to create, this module provides requisite tooling to get apps up and running with the minimum of effort to enable the following operational aspects: Quick start Because http4k does not use reflection or annotation process for application startup, all of the supported Server-backends start up and shutdown very quickly - this is crucial for cloud-based environments where an orchestration framework might move instances around to redistribute load or avoid problematic server/rack/DCs. Configuration All application configuration should be injected via environmental variables. http4k provides an Environment object, along with typesafe variable binding using the in-built Lenses mechanism. This typesafe API is consistent with the other usages of Lenses throughout http4k, so should have a near-zero learning curve. Also provided are a set of extension methods for retrieving standard environmental config for service ports from Kubernetes. Observability Orchestration software such as Kubernetes and CloudFoundry regularly query a set of diagnostic endpoints to monitor the state of an application. This module provides standardised HttpHandler implementations to model the following endpoints: Liveness - used to determine if the application is actually alive. Readiness - used to determine if the application is available to receive production traffic from the cloud Load Balancer. This endpoint performs a series of diagnostic checks against it's dependencies (such as database connectivity) and collates the results to report back to the orchestrator. http4k provides the ReadinessCheck interface which can be implementaed as required and plugged into the endpoint. In Kubernetes, this set of endpoints is generally hosted on a second port to avoid the API clashes, so http4k provides the machinery to easily start these services on a different port to the main application API via the Http4kK8sServer object. Code package guide . modules . cloud_native import org.http4k.client.JavaHttpClient import org.http4k.cloudnative.Http4kK8sServer import org.http4k.cloudnative.asK8sServer import org.http4k.cloudnative.env.Environment import org.http4k.cloudnative.env.EnvironmentKey import org.http4k.cloudnative.env.Secret import org.http4k.cloudnative.health.Completed import org.http4k.cloudnative.health.Health import org.http4k.cloudnative.health.ReadinessCheck import org.http4k.cloudnative.health.ReadinessCheckResult import org.http4k.core.Filter import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters import org.http4k.filter.DebuggingFilters import org.http4k.lens.Lens import org.http4k.lens.secret import org.http4k.routing.bind import org.http4k.server.SunHttp import org.http4k.server.asServer import kotlin.random.Random // the entire k8s application consists of 2 servers - the main and the health object App { // settings private val otherServiceUri : Lens < Environment , Uri > = EnvironmentKey . k8s . serviceUriFor ( \"otherservice\" ) private val dbRole = EnvironmentKey . required ( \"database.user.role\" ) private val dbPassword = EnvironmentKey . secret () . required ( \"database.user.password\" ) operator fun invoke ( env : Environment ): Http4kK8sServer { // define the main app API - it proxies to the \"other\" service val mainApp = ClientFilters . SetHostFrom ( otherServiceUri ( env )) . then ( rewriteUriToLocalhostAsWeDoNotHaveDns ) // this line only here to make the example work ! . then ( JavaHttpClient ()) // define the health app API val healthApp = Health ( \"/config\" bind GET to { Response ( OK ) . body ( env . toString ()) }, checks = listOf ( DatabaseCheck ( RandomlyFailingDatabase ( dbRole ( env ), dbPassword ( env ) ))) ) return mainApp . asK8sServer (:: SunHttp , env , healthApp ) } private val rewriteUriToLocalhostAsWeDoNotHaveDns = Filter { next -> { println ( \"Rewriting ${it.uri} so we can proxy properly\" ) next ( it . uri ( it . uri . authority ( \"localhost:9000\" ))) } } } // this is a database client that we are going to health check class RandomlyFailingDatabase ( private val user : String , password : Secret ) { init { // the secret is a single - shot value whose value will be discarded after use password . use { println ( \"setting up the database connection with creds: $user/$it\" ) } } fun insertARecord () { if ( Random ( 1 ) . nextBoolean ()) throw Exception ( \"oh no! $user has no access\" ) } } // implements the check which will determine if this service is ready to go class DatabaseCheck ( private val db : RandomlyFailingDatabase ) : ReadinessCheck { override val name = \"database\" override fun invoke (): ReadinessCheckResult { db . insertARecord () return Completed ( name ) } } /** file app . properties contains database . user . role = admin database . user . password = myPassword */ fun main () { val defaultConfig = Environment . defaults ( EnvironmentKey . k8s . SERVICE_PORT of 8000 , EnvironmentKey . k8s . HEALTH_PORT of 8001 , EnvironmentKey . k8s . serviceUriFor ( \"otherservice\" ) of Uri . of ( \"https://localhost:8000\" ) ) // standard chaining order for properties is local file -> JVM -> Environment -> defaults -> boom ! val k8sPodEnv = Environment . fromResource ( \"app.properties\" ) overrides Environment . JVM_PROPERTIES overrides Environment . ENV overrides defaultConfig // the end - server that we will proxy to val upstream = { _ : Request -> Response ( OK ) . body ( \"HELLO!\" ) } . asServer ( SunHttp ( 9000 )) . start () val server = App ( k8sPodEnv ) . start () performHealthChecks () server . stop () upstream . stop () } private fun performHealthChecks () { val client = DebuggingFilters . PrintResponse () . then ( JavaHttpClient ()) // health checks client ( Request ( GET , \"http://localhost:8001/liveness\" )) client ( Request ( GET , \"http://localhost:8001/readiness\" )) client ( Request ( GET , \"http://localhost:8001/config\" )) // proxied call client ( Request ( GET , \"http://localhost:8000\" )) }","title":"Cloud native Configuration"},{"location":"guide/modules/cloud_native/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-cloudnative\", version: \"3.247.0\" http4k applications are naturally at home operating in distributed, Cloud Native environments. Whilst simple to create, this module provides requisite tooling to get apps up and running with the minimum of effort to enable the following operational aspects:","title":"Installation (Gradle)"},{"location":"guide/modules/cloud_native/#quick-start","text":"Because http4k does not use reflection or annotation process for application startup, all of the supported Server-backends start up and shutdown very quickly - this is crucial for cloud-based environments where an orchestration framework might move instances around to redistribute load or avoid problematic server/rack/DCs.","title":"Quick start"},{"location":"guide/modules/cloud_native/#configuration","text":"All application configuration should be injected via environmental variables. http4k provides an Environment object, along with typesafe variable binding using the in-built Lenses mechanism. This typesafe API is consistent with the other usages of Lenses throughout http4k, so should have a near-zero learning curve. Also provided are a set of extension methods for retrieving standard environmental config for service ports from Kubernetes.","title":"Configuration"},{"location":"guide/modules/cloud_native/#observability","text":"Orchestration software such as Kubernetes and CloudFoundry regularly query a set of diagnostic endpoints to monitor the state of an application. This module provides standardised HttpHandler implementations to model the following endpoints: Liveness - used to determine if the application is actually alive. Readiness - used to determine if the application is available to receive production traffic from the cloud Load Balancer. This endpoint performs a series of diagnostic checks against it's dependencies (such as database connectivity) and collates the results to report back to the orchestrator. http4k provides the ReadinessCheck interface which can be implementaed as required and plugged into the endpoint. In Kubernetes, this set of endpoints is generally hosted on a second port to avoid the API clashes, so http4k provides the machinery to easily start these services on a different port to the main application API via the Http4kK8sServer object.","title":"Observability"},{"location":"guide/modules/cloud_native/#code","text":"package guide . modules . cloud_native import org.http4k.client.JavaHttpClient import org.http4k.cloudnative.Http4kK8sServer import org.http4k.cloudnative.asK8sServer import org.http4k.cloudnative.env.Environment import org.http4k.cloudnative.env.EnvironmentKey import org.http4k.cloudnative.env.Secret import org.http4k.cloudnative.health.Completed import org.http4k.cloudnative.health.Health import org.http4k.cloudnative.health.ReadinessCheck import org.http4k.cloudnative.health.ReadinessCheckResult import org.http4k.core.Filter import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters import org.http4k.filter.DebuggingFilters import org.http4k.lens.Lens import org.http4k.lens.secret import org.http4k.routing.bind import org.http4k.server.SunHttp import org.http4k.server.asServer import kotlin.random.Random // the entire k8s application consists of 2 servers - the main and the health object App { // settings private val otherServiceUri : Lens < Environment , Uri > = EnvironmentKey . k8s . serviceUriFor ( \"otherservice\" ) private val dbRole = EnvironmentKey . required ( \"database.user.role\" ) private val dbPassword = EnvironmentKey . secret () . required ( \"database.user.password\" ) operator fun invoke ( env : Environment ): Http4kK8sServer { // define the main app API - it proxies to the \"other\" service val mainApp = ClientFilters . SetHostFrom ( otherServiceUri ( env )) . then ( rewriteUriToLocalhostAsWeDoNotHaveDns ) // this line only here to make the example work ! . then ( JavaHttpClient ()) // define the health app API val healthApp = Health ( \"/config\" bind GET to { Response ( OK ) . body ( env . toString ()) }, checks = listOf ( DatabaseCheck ( RandomlyFailingDatabase ( dbRole ( env ), dbPassword ( env ) ))) ) return mainApp . asK8sServer (:: SunHttp , env , healthApp ) } private val rewriteUriToLocalhostAsWeDoNotHaveDns = Filter { next -> { println ( \"Rewriting ${it.uri} so we can proxy properly\" ) next ( it . uri ( it . uri . authority ( \"localhost:9000\" ))) } } } // this is a database client that we are going to health check class RandomlyFailingDatabase ( private val user : String , password : Secret ) { init { // the secret is a single - shot value whose value will be discarded after use password . use { println ( \"setting up the database connection with creds: $user/$it\" ) } } fun insertARecord () { if ( Random ( 1 ) . nextBoolean ()) throw Exception ( \"oh no! $user has no access\" ) } } // implements the check which will determine if this service is ready to go class DatabaseCheck ( private val db : RandomlyFailingDatabase ) : ReadinessCheck { override val name = \"database\" override fun invoke (): ReadinessCheckResult { db . insertARecord () return Completed ( name ) } } /** file app . properties contains database . user . role = admin database . user . password = myPassword */ fun main () { val defaultConfig = Environment . defaults ( EnvironmentKey . k8s . SERVICE_PORT of 8000 , EnvironmentKey . k8s . HEALTH_PORT of 8001 , EnvironmentKey . k8s . serviceUriFor ( \"otherservice\" ) of Uri . of ( \"https://localhost:8000\" ) ) // standard chaining order for properties is local file -> JVM -> Environment -> defaults -> boom ! val k8sPodEnv = Environment . fromResource ( \"app.properties\" ) overrides Environment . JVM_PROPERTIES overrides Environment . ENV overrides defaultConfig // the end - server that we will proxy to val upstream = { _ : Request -> Response ( OK ) . body ( \"HELLO!\" ) } . asServer ( SunHttp ( 9000 )) . start () val server = App ( k8sPodEnv ) . start () performHealthChecks () server . stop () upstream . stop () } private fun performHealthChecks () { val client = DebuggingFilters . PrintResponse () . then ( JavaHttpClient ()) // health checks client ( Request ( GET , \"http://localhost:8001/liveness\" )) client ( Request ( GET , \"http://localhost:8001/readiness\" )) client ( Request ( GET , \"http://localhost:8001/config\" )) // proxied call client ( Request ( GET , \"http://localhost:8000\" )) }","title":"Code "},{"location":"guide/modules/contracts/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-contract\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-<insert json lib>\", version: \"3.247.0\" About The http4k-contract module adds a much more sophisticated routing mechanism to that available in http4k-core . It adds the facility to declare server-side Routes in a completely typesafe way, leveraging the Lens functionality from the core. These Routes are combined into Contracts , which have the following features: Auto-validating - the Route contract is automatically validated on each call for required-fields and type conversions, removing the requirement for any validation code to be written by the API user. Invalid calls result in a HTTP 400 (BAD_REQUEST) response. Self-describing: - a generated endpoint is provided which describes all of the Routes in that module. Implementations include OpenApi v2 & v3/Swagger documentation, including generation of JSON schema . These documents can then be used to generate HTTP client and server code in various languages using the OpenAPI generator . models for messages. Security: to secure the Routes against unauthorised access. Current implementations include ApiKey , BasicAuth , BearerAuth and OAuth . Code package guide . modules . contracts // for this example we 're using Jackson - note that the auto method imported is an extension // function that is defined on the Jackson instance import org.http4k.contract.ContractRoute import org.http4k.contract.bind import org.http4k.contract.contract import org.http4k.contract.div import org.http4k.contract.meta import org.http4k.contract.openapi.ApiInfo import org.http4k.contract.openapi.v3.OpenApi3 import org.http4k.contract.security.ApiKeySecurity import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_PLAIN import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.format.Jackson import org.http4k.format.Jackson.auto import org.http4k.lens.Path import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.lens.string import org.http4k.routing.routes // this route has a dynamic path segment fun greetRoute (): ContractRoute { // these lenses define the dynamic parts of the request that will be used in processing val ageQuery = Query . int () . required ( \"age\" ) val stringBody = Body . string ( TEXT_PLAIN ) . toLens () // this specifies the route contract , with the desired contract of path , headers , queries and body parameters . val spec = \"/greet\" / Path . of ( \"name\" ) meta { summary = \"tells the user hello!\" queries += ageQuery receiving ( stringBody ) } bindContract GET // the this function will dynamically supply a new HttpHandler for each call . The number of parameters // matches the number of dynamic sections in the path ( 1 ) fun greet ( nameFromPath : String ): HttpHandler = { request : Request -> val age = ageQuery ( request ) val sentMessage = stringBody ( request ) Response ( OK ) . with ( stringBody of \"hello $nameFromPath you are $age. You sent $sentMessage\" ) } return spec to :: greet } data class NameAndMessage ( val name : String , val message : String ) // this route uses auto - marshalling to convert the JSON body directly to / from a data class instance fun echoRoute (): ContractRoute { // the body lens here is imported as an extension function from the Jackson instance val body = Body . auto < NameAndMessage > () . toLens () // this specifies the route contract , including examples of the input and output body objects - they will // get exploded into JSON schema in the OpenAPI docs val spec = \"/echo\" meta { summary = \"echoes the name and message sent to it\" receiving ( body to NameAndMessage ( \"jim\" , \"hello!\" )) returning ( OK , body to NameAndMessage ( \"jim\" , \"hello!\" )) } bindContract POST // note that because we don 't have any dynamic parameters, we can use a HttpHandler instance instead of a function val echo : HttpHandler = { request : Request -> val received : NameAndMessage = body ( request ) Response ( OK ) . with ( body of received ) } return spec to echo } // use another Lens to set up the API - key - the answer is 42 ! val mySecurity = ApiKeySecurity ( Query . int () . required ( \"api\" ), { it == 42 }) // Combine the Routes into a contract and bind to a context , defining a renderer ( in this example // OpenApi / Swagger ) and a security model ( in this case an API - Key ): val contract = contract { renderer = OpenApi3 ( ApiInfo ( \"My great API\" , \"v1.0\" ), Jackson ) descriptionPath = \"/swagger.json\" security = mySecurity routes += greetRoute () routes += echoRoute () } val handler : HttpHandler = routes ( \"/api/v1\" bind contract ) // by default , the OpenAPI docs live at the root of the contract context , but we can override it .. fun main () { println ( handler ( Request ( GET , \"/api/v1/swagger.json\" ))) println ( handler ( Request ( POST , \"/api/v1/echo\" ) . query ( \"api\" , \"42\" ) . body ( \"\"\"{\"name\":\"Bob\",\"message\":\"Hello\"}\"\"\" ))) } When launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module. For a more extended example, see the following example apps: TDD'd example application Todo backend (typesafe contract version) Naming of JSON Schema models There are currently 2 options for JSON schema generation. OpenApi v2 & v3: The standard mechanism can be used with any of the supported http4k JSON modules. It generates anonymous JSON schema definition names that are then listed in the schema section of the OpenApi docs. OpenApi3 ( ApiInfo ( \"title\" , \"1.2\" , \"module description\" ), Argo ) ... generates definitions like the following in the schema definitions: { \"components\" : { \"schemas\" : { \"object1283926341\" : { \"type\" : \"object\" , \"properties\" : { \"aString\" : { \"type\" : \"string\" } } } } } } OpenApi v3 only: By including a supported Auto-JSON marshalling module on the classpath (currently only http4k-format-jackson ), the names of the definitions are generated based on the Kotlin class instances provided to the Contract Route DSL. Note that an overloaded OpenApi function automatically provides the default Jackson instance, so we can remove it from the renderer creation: OpenApi3 ( ApiInfo ( \"title\" , \"1.2\" , \"module description\" ), Jackson ) ... generates definitions like the following in the schema definitions: { \"components\" :{ \"schemas\" :{ \"ArbObject\" : { \"properties\" : { \"uri\" : { \"example\" : \"http://foowang\" , \"type\" : \"string\" } }, \"example\" : { \"uri\" : \"http://foowang\" }, \"type\" : \"object\" , \"required\" : [ \"uri\" ] } } } }","title":"Typesafe contracts (OpenAPI3)"},{"location":"guide/modules/contracts/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-contract\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-<insert json lib>\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/contracts/#about","text":"The http4k-contract module adds a much more sophisticated routing mechanism to that available in http4k-core . It adds the facility to declare server-side Routes in a completely typesafe way, leveraging the Lens functionality from the core. These Routes are combined into Contracts , which have the following features: Auto-validating - the Route contract is automatically validated on each call for required-fields and type conversions, removing the requirement for any validation code to be written by the API user. Invalid calls result in a HTTP 400 (BAD_REQUEST) response. Self-describing: - a generated endpoint is provided which describes all of the Routes in that module. Implementations include OpenApi v2 & v3/Swagger documentation, including generation of JSON schema . These documents can then be used to generate HTTP client and server code in various languages using the OpenAPI generator . models for messages. Security: to secure the Routes against unauthorised access. Current implementations include ApiKey , BasicAuth , BearerAuth and OAuth .","title":"About"},{"location":"guide/modules/contracts/#code","text":"package guide . modules . contracts // for this example we 're using Jackson - note that the auto method imported is an extension // function that is defined on the Jackson instance import org.http4k.contract.ContractRoute import org.http4k.contract.bind import org.http4k.contract.contract import org.http4k.contract.div import org.http4k.contract.meta import org.http4k.contract.openapi.ApiInfo import org.http4k.contract.openapi.v3.OpenApi3 import org.http4k.contract.security.ApiKeySecurity import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_PLAIN import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.format.Jackson import org.http4k.format.Jackson.auto import org.http4k.lens.Path import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.lens.string import org.http4k.routing.routes // this route has a dynamic path segment fun greetRoute (): ContractRoute { // these lenses define the dynamic parts of the request that will be used in processing val ageQuery = Query . int () . required ( \"age\" ) val stringBody = Body . string ( TEXT_PLAIN ) . toLens () // this specifies the route contract , with the desired contract of path , headers , queries and body parameters . val spec = \"/greet\" / Path . of ( \"name\" ) meta { summary = \"tells the user hello!\" queries += ageQuery receiving ( stringBody ) } bindContract GET // the this function will dynamically supply a new HttpHandler for each call . The number of parameters // matches the number of dynamic sections in the path ( 1 ) fun greet ( nameFromPath : String ): HttpHandler = { request : Request -> val age = ageQuery ( request ) val sentMessage = stringBody ( request ) Response ( OK ) . with ( stringBody of \"hello $nameFromPath you are $age. You sent $sentMessage\" ) } return spec to :: greet } data class NameAndMessage ( val name : String , val message : String ) // this route uses auto - marshalling to convert the JSON body directly to / from a data class instance fun echoRoute (): ContractRoute { // the body lens here is imported as an extension function from the Jackson instance val body = Body . auto < NameAndMessage > () . toLens () // this specifies the route contract , including examples of the input and output body objects - they will // get exploded into JSON schema in the OpenAPI docs val spec = \"/echo\" meta { summary = \"echoes the name and message sent to it\" receiving ( body to NameAndMessage ( \"jim\" , \"hello!\" )) returning ( OK , body to NameAndMessage ( \"jim\" , \"hello!\" )) } bindContract POST // note that because we don 't have any dynamic parameters, we can use a HttpHandler instance instead of a function val echo : HttpHandler = { request : Request -> val received : NameAndMessage = body ( request ) Response ( OK ) . with ( body of received ) } return spec to echo } // use another Lens to set up the API - key - the answer is 42 ! val mySecurity = ApiKeySecurity ( Query . int () . required ( \"api\" ), { it == 42 }) // Combine the Routes into a contract and bind to a context , defining a renderer ( in this example // OpenApi / Swagger ) and a security model ( in this case an API - Key ): val contract = contract { renderer = OpenApi3 ( ApiInfo ( \"My great API\" , \"v1.0\" ), Jackson ) descriptionPath = \"/swagger.json\" security = mySecurity routes += greetRoute () routes += echoRoute () } val handler : HttpHandler = routes ( \"/api/v1\" bind contract ) // by default , the OpenAPI docs live at the root of the contract context , but we can override it .. fun main () { println ( handler ( Request ( GET , \"/api/v1/swagger.json\" ))) println ( handler ( Request ( POST , \"/api/v1/echo\" ) . query ( \"api\" , \"42\" ) . body ( \"\"\"{\"name\":\"Bob\",\"message\":\"Hello\"}\"\"\" ))) } When launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module. For a more extended example, see the following example apps: TDD'd example application Todo backend (typesafe contract version)","title":"Code "},{"location":"guide/modules/contracts/#naming-of-json-schema-models","text":"There are currently 2 options for JSON schema generation. OpenApi v2 & v3: The standard mechanism can be used with any of the supported http4k JSON modules. It generates anonymous JSON schema definition names that are then listed in the schema section of the OpenApi docs. OpenApi3 ( ApiInfo ( \"title\" , \"1.2\" , \"module description\" ), Argo ) ... generates definitions like the following in the schema definitions: { \"components\" : { \"schemas\" : { \"object1283926341\" : { \"type\" : \"object\" , \"properties\" : { \"aString\" : { \"type\" : \"string\" } } } } } } OpenApi v3 only: By including a supported Auto-JSON marshalling module on the classpath (currently only http4k-format-jackson ), the names of the definitions are generated based on the Kotlin class instances provided to the Contract Route DSL. Note that an overloaded OpenApi function automatically provides the default Jackson instance, so we can remove it from the renderer creation: OpenApi3 ( ApiInfo ( \"title\" , \"1.2\" , \"module description\" ), Jackson ) ... generates definitions like the following in the schema definitions: { \"components\" :{ \"schemas\" :{ \"ArbObject\" : { \"properties\" : { \"uri\" : { \"example\" : \"http://foowang\" , \"type\" : \"string\" } }, \"example\" : { \"uri\" : \"http://foowang\" }, \"type\" : \"object\" , \"required\" : [ \"uri\" ] } } } }","title":"Naming of JSON Schema models"},{"location":"guide/modules/core/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" About Apart from Kotlin StdLib, the core module has ZERO dependencies and provides the following: Immutable versions of the HTTP spec objects (Request, Response, Cookies etc). HTTP handler and filter abstractions which models services as simple, composable functions. Simple routing implementation, plus HttpHandlerServlet to enable plugging into any Servlet engine. Lens mechanism for typesafe destructuring and construction of HTTP messages. Typesafe Request Context operations using Lenses. Abstractions for Servers, Clients, JSON Message formats, Templating, Websockets etc. SunHttp Ultra-fast single-LOC development server-backend Static file-serving capability with Caching and Hot-Reload APIs to record and replay HTTP traffic to disk or memory HttpHandlers In http4k , an HTTP service is just a typealias of a simple function: typealias HttpHandler = ( Request ) -> Response First described in this Twitter paper \"Your Server as a Function\" , this abstraction allows us lots of flexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an HttpHandler , neither do we need to launch a real HTTP container to exercise it: val handler = { request : Request -> Response ( OK ). body ( \"Hello, ${request.query(\" name \")}!\" ) } val get = Request ( Method . GET , \"/\" ). query ( \"name\" , \"John Doe\" ) val response = handler ( get ) println ( response . status ) println ( response . bodyString ()) To mount the HttpHandler in a container, the can simply be converted to a Servlet by calling handler.asServlet() Filters Filters add extra processing to either the Request or Response. In http4k , they are modelled as: interface Filter : ( HttpHandler ) -> HttpHandler Filters are designed to simply compose together (using then() ) , creating reusable stacks of behaviour which can then be applied to any HttpHandler . For example, to add Basic Auth and latency reporting to a service: val handler = { _ : Request -> Response ( OK ) } val myFilter = Filter { next : HttpHandler -> { request : Request -> val start = System . currentTimeMillis () val response = next ( request ) val latency = System . currentTimeMillis () - start println ( \"I took $latency ms\" ) response } } val latencyAndBasicAuth : HttpHandler = ServerFilters . BasicAuth ( \"my realm\" , \"user\" , \"password\" ). then ( myFilter ) val app : HttpHandler = latencyAndBasicAuth . then ( handler ) The http4k-core module comes with a set of handy Filters for application to both Server and Client HttpHandlers , covering common things like: Request tracing headers (x-b3-traceid etc) Basic Auth Cache Control CORS Cookie handling Debugging request and responses Check out the org.http4k.filter package for the exact list. Routers - Nestable, path-based Routing Create a Router using routes() to bind a static or dynamic path to either an HttpHandler, or to another sub-Router. These Routers can be nested infinitely deep and http4k will search for a matching route using a depth-first search algorithm, before falling back finally to a 404: routes ( \"/hello\" bind routes ( \"/{name:.*}\" bind GET to { request : Request -> Response ( OK ). body ( \"Hello, ${request.path(\" name \")}!\" ) } ), \"/fail\" bind POST to { request : Request -> Response ( INTERNAL_SERVER_ERROR ) } ). asServer ( Jetty ( 8000 )). start () Note that the http4k-contract module contains a more typesafe implementation of routing functionality, with runtime-generated live documentation in OpenApi/Swagger format. Typesafe parameter destructuring/construction of HTTP messages with Lenses Getting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. For this purpose, we can use a Lens . A Lens is a bi-directional entity which can be used to either get or set a particular value from/onto an HTTP message. http4k provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional). To utilise a lens, first you have to declare it with the form <Location>.<configuration and mapping operations>.<terminator> . There is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location: Location Starting type Applicable to Multiplicity Requirement terminator Examples Query String Request Singular or multiple Optional or Required Query.optional(\"name\") Query.required(\"name\") Query.int().required(\"name\") Query.localDate().multi.required(\"name\") Query.map(::CustomType, { it.value }).required(\"name\") Header String Request or Response Singular or multiple Optional or Required Header.optional(\"name\") Header.required(\"name\") Header.int().required(\"name\") Header.localDate().multi.required(\"name\") Header.map(::CustomType, { it.value }).required(\"name\") Path String Request Singular Required Path.of(\"name\") Path.int().of(\"name\") Path.map(::CustomType, { it.value }).of(\"name\") FormField String WebForm Singular or multiple Optional or Required FormField.optional(\"name\") FormField.required(\"name\") FormField.int().required(\"name\") FormField.localDate().multi.required(\"name\") FormField.map(::CustomType, { it.value }).required(\"name\") Body ByteBuffer Request or Response Singular Required Body.string(ContentType.TEXT_PLAIN).toLens() Body.json().toLens() Body.webForm(Validator.Strict, FormField.required(\"name\")).toLens() Once the lens is declared, you can use it on a target object to either get or set the value: Retrieving a value: use <lens>.extract(<target>) , or the more concise invoke form: <lens>(<target>) Setting a value: use <lens>.inject(<value>, <target>) , or the more concise invoke form: <lens>(<value>, <target>) Code package guide . modules . core import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.Header import org.http4k.lens.Path import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.lens.localDate import org.http4k.lens.nonEmptyString import org.http4k.lens.string import org.http4k.routing.RoutingHttpHandler import org.http4k.routing.bind import org.http4k.routing.routes import java.time.LocalDate val pathLocalDate = Path . localDate () . of ( \"date\" ) val requiredQuery = Query . required ( \"myQueryName\" ) val nonEmptyQuery = Query . nonEmptyString () . required ( \"myNonEmptyQuery\" ) val optionalHeader = Header . int () . optional ( \"Content-Length\" ) val responseBody = Body . string ( ContentType . TEXT_PLAIN ) . toLens () // Most of the useful common JDK types are covered . However , if we want to use our own types , we can just use `map()` data class CustomType ( val value : String ) val requiredCustomQuery = Query . map (:: CustomType , { it . value }) . required ( \"myCustomType\" ) // To use the Lens , simply `invoke() or extract()` it using an HTTP message to extract the value , or alternatively `invoke() or inject()` it with the value if we are modifying ( via copy ) the message : val handler : RoutingHttpHandler = routes ( \"/hello/{date:.*}\" bind GET to { request : Request -> val pathDate : LocalDate = pathLocalDate ( request ) // SAME AS : // val pathDate : LocalDate = pathLocalDate . extract ( request ) val customType : CustomType = requiredCustomQuery ( request ) val anIntHeader : Int ? = optionalHeader ( request ) val baseResponse = Response ( OK ) val responseWithHeader = optionalHeader ( anIntHeader , baseResponse ) // SAME AS : // val responseWithHeader = optionalHeader . inject ( anIntHeader , baseResponse ) responseBody ( \"you sent $pathDate and $customType\" , responseWithHeader ) } ) // With the addition of the `CatchLensFailure` filter , no other validation is required when using Lenses , as http4k will handle invalid requests by returning a BAD_REQUEST ( 400 ) response . val app = ServerFilters . CatchLensFailure . then ( handler )( Request ( GET , \"/hello/2000-01-01?myCustomType=someValue\" )) // More conveniently for construction of HTTP messages , multiple lenses can be used at once to modify a message , which is useful for properly building both requests and responses in a typesafe way without resorting to string values ( especially in URLs which should never be constructed using String concatenation ): val modifiedRequest : Request = Request ( GET , \"http://google.com/{pathLocalDate}\" ) . with ( pathLocalDate of LocalDate . now (), requiredQuery of \"myAmazingString\" , optionalHeader of 123 ) Serving static assets For serving static assets, just bind a path to a Static block as below, using either a Classpath or Directory (Hot reloading) based ResourceLoader instance (find these on the ResourceLoader companion object). Typically, Directory is used during development and the Classpath strategy is used to serve assets in production from an UberJar. This is usually based on a \"devmode\" flag when constructing your app\". Note that you should avoid setting the Classpath value to the root because otherwise it will serve anything from your classpath (including Java class files!)!: routes ( \"/static\" bind static ( Classpath ( \"/org/http4k/some/package/name\" )), \"/hotreload\" bind static ( Directory ( \"path/to/static/dir/goes/here\" )) ) Single Page Apps These can be easily activated as below, and default to serving from /public package: routes ( \"/api\" bind { Response ( OK ). body ( \"some api content\" ) }, singlePageApp () ) Typesafe Websockets. Websockets have been modeled using the same methodology as standard HTTP endpoints - ie. with both simplicity and testability as a first class concern, as well as benefiting from Lens-based typesafety. Websocket communication consists of 3 main concepts: WsHandler - represented as a typealias: WsHandler = (Request) -> WsConsumer? . This is responsible for matching an HTTP request to a websocket. WsConsumer - represented as a typealias: WsConsumer = (WebSocket) -> Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket. WsMessage - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the http4k HTTP message model, WsMessages are immutable data classes. The routing aspect of Websockets is done using a very similar API to the standard HTTP routing for HTTP messages and dynamic parts of the upgrade request are available when constructing a websocket instance: data class Wrapper ( val value : String ) val body = WsMessage . string (). map ( :: Wrapper , Wrapper :: value ). toLens () val nameLens = Path . of ( \"name\" ) val ws : WsHandler = websockets ( \"/hello\" bind websockets ( \"/{name}\" bind { ws : WebSocket -> val name = nameLens ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) ws . onMessage { val received = body ( it ) ws . send ( body ( received )) } ws . onClose { println ( \"closed\" ) } } ) ) A WsHandler can be combined with an HttpHandler into a PolyHandler and then mounted into a supported backend server using asServer() : val app = PolyHandler ( routes ( \"/\" bind { r : Request -> Response ( OK ) } ), websockets ( \"/ws\" bind { ws : WebSocket -> ws . send ( WsMessage ( \"hello!\" )) } ) ) app . asServer ( Jetty ( 9000 )). start () Alternatively, the WsHandler can be also converted to a synchronous WsClient - this allows testing to be done completely offline, which allows for super-fast tests: val client = app . testWsClient ( Request ( Method . GET , \"ws://localhost:9000/hello/bob\" )) !! client . send ( WsMessage ( \"1\" )) client . close ( Status ( 200 , \"bob\" )) client . received . take ( 2 ). forEach ( :: println ) Request and Response toString() The HttpMessages used by http4k toString in the HTTP wire format, which it simple to capture and replay HTTP message streams later in a similar way to tools like Mountebank . CURL format Creates curl command for a given request - this is useful to include in audit logs so exact requests can be replayed if required: val curl = Request ( POST , \"http://httpbin.org/post\" ). body ( listOf ( \"foo\" to \"bar\" ). toBody ()). toCurl () // curl -X POST --data \"foo=bar\" \"http://httpbin.org/post\"","title":"Core"},{"location":"guide/modules/core/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/core/#about","text":"Apart from Kotlin StdLib, the core module has ZERO dependencies and provides the following: Immutable versions of the HTTP spec objects (Request, Response, Cookies etc). HTTP handler and filter abstractions which models services as simple, composable functions. Simple routing implementation, plus HttpHandlerServlet to enable plugging into any Servlet engine. Lens mechanism for typesafe destructuring and construction of HTTP messages. Typesafe Request Context operations using Lenses. Abstractions for Servers, Clients, JSON Message formats, Templating, Websockets etc. SunHttp Ultra-fast single-LOC development server-backend Static file-serving capability with Caching and Hot-Reload APIs to record and replay HTTP traffic to disk or memory","title":"About"},{"location":"guide/modules/core/#httphandlers","text":"In http4k , an HTTP service is just a typealias of a simple function: typealias HttpHandler = ( Request ) -> Response First described in this Twitter paper \"Your Server as a Function\" , this abstraction allows us lots of flexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an HttpHandler , neither do we need to launch a real HTTP container to exercise it: val handler = { request : Request -> Response ( OK ). body ( \"Hello, ${request.query(\" name \")}!\" ) } val get = Request ( Method . GET , \"/\" ). query ( \"name\" , \"John Doe\" ) val response = handler ( get ) println ( response . status ) println ( response . bodyString ()) To mount the HttpHandler in a container, the can simply be converted to a Servlet by calling handler.asServlet()","title":"HttpHandlers"},{"location":"guide/modules/core/#filters","text":"Filters add extra processing to either the Request or Response. In http4k , they are modelled as: interface Filter : ( HttpHandler ) -> HttpHandler Filters are designed to simply compose together (using then() ) , creating reusable stacks of behaviour which can then be applied to any HttpHandler . For example, to add Basic Auth and latency reporting to a service: val handler = { _ : Request -> Response ( OK ) } val myFilter = Filter { next : HttpHandler -> { request : Request -> val start = System . currentTimeMillis () val response = next ( request ) val latency = System . currentTimeMillis () - start println ( \"I took $latency ms\" ) response } } val latencyAndBasicAuth : HttpHandler = ServerFilters . BasicAuth ( \"my realm\" , \"user\" , \"password\" ). then ( myFilter ) val app : HttpHandler = latencyAndBasicAuth . then ( handler ) The http4k-core module comes with a set of handy Filters for application to both Server and Client HttpHandlers , covering common things like: Request tracing headers (x-b3-traceid etc) Basic Auth Cache Control CORS Cookie handling Debugging request and responses Check out the org.http4k.filter package for the exact list.","title":"Filters"},{"location":"guide/modules/core/#routers-nestable-path-based-routing","text":"Create a Router using routes() to bind a static or dynamic path to either an HttpHandler, or to another sub-Router. These Routers can be nested infinitely deep and http4k will search for a matching route using a depth-first search algorithm, before falling back finally to a 404: routes ( \"/hello\" bind routes ( \"/{name:.*}\" bind GET to { request : Request -> Response ( OK ). body ( \"Hello, ${request.path(\" name \")}!\" ) } ), \"/fail\" bind POST to { request : Request -> Response ( INTERNAL_SERVER_ERROR ) } ). asServer ( Jetty ( 8000 )). start () Note that the http4k-contract module contains a more typesafe implementation of routing functionality, with runtime-generated live documentation in OpenApi/Swagger format.","title":"Routers - Nestable, path-based Routing"},{"location":"guide/modules/core/#typesafe-parameter-destructuringconstruction-of-http-messages-with-lenses","text":"Getting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. For this purpose, we can use a Lens . A Lens is a bi-directional entity which can be used to either get or set a particular value from/onto an HTTP message. http4k provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional). To utilise a lens, first you have to declare it with the form <Location>.<configuration and mapping operations>.<terminator> . There is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location: Location Starting type Applicable to Multiplicity Requirement terminator Examples Query String Request Singular or multiple Optional or Required Query.optional(\"name\") Query.required(\"name\") Query.int().required(\"name\") Query.localDate().multi.required(\"name\") Query.map(::CustomType, { it.value }).required(\"name\") Header String Request or Response Singular or multiple Optional or Required Header.optional(\"name\") Header.required(\"name\") Header.int().required(\"name\") Header.localDate().multi.required(\"name\") Header.map(::CustomType, { it.value }).required(\"name\") Path String Request Singular Required Path.of(\"name\") Path.int().of(\"name\") Path.map(::CustomType, { it.value }).of(\"name\") FormField String WebForm Singular or multiple Optional or Required FormField.optional(\"name\") FormField.required(\"name\") FormField.int().required(\"name\") FormField.localDate().multi.required(\"name\") FormField.map(::CustomType, { it.value }).required(\"name\") Body ByteBuffer Request or Response Singular Required Body.string(ContentType.TEXT_PLAIN).toLens() Body.json().toLens() Body.webForm(Validator.Strict, FormField.required(\"name\")).toLens() Once the lens is declared, you can use it on a target object to either get or set the value: Retrieving a value: use <lens>.extract(<target>) , or the more concise invoke form: <lens>(<target>) Setting a value: use <lens>.inject(<value>, <target>) , or the more concise invoke form: <lens>(<value>, <target>)","title":"Typesafe parameter destructuring/construction of HTTP messages with Lenses"},{"location":"guide/modules/core/#code","text":"package guide . modules . core import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.core.with import org.http4k.filter.ServerFilters import org.http4k.lens.Header import org.http4k.lens.Path import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.lens.localDate import org.http4k.lens.nonEmptyString import org.http4k.lens.string import org.http4k.routing.RoutingHttpHandler import org.http4k.routing.bind import org.http4k.routing.routes import java.time.LocalDate val pathLocalDate = Path . localDate () . of ( \"date\" ) val requiredQuery = Query . required ( \"myQueryName\" ) val nonEmptyQuery = Query . nonEmptyString () . required ( \"myNonEmptyQuery\" ) val optionalHeader = Header . int () . optional ( \"Content-Length\" ) val responseBody = Body . string ( ContentType . TEXT_PLAIN ) . toLens () // Most of the useful common JDK types are covered . However , if we want to use our own types , we can just use `map()` data class CustomType ( val value : String ) val requiredCustomQuery = Query . map (:: CustomType , { it . value }) . required ( \"myCustomType\" ) // To use the Lens , simply `invoke() or extract()` it using an HTTP message to extract the value , or alternatively `invoke() or inject()` it with the value if we are modifying ( via copy ) the message : val handler : RoutingHttpHandler = routes ( \"/hello/{date:.*}\" bind GET to { request : Request -> val pathDate : LocalDate = pathLocalDate ( request ) // SAME AS : // val pathDate : LocalDate = pathLocalDate . extract ( request ) val customType : CustomType = requiredCustomQuery ( request ) val anIntHeader : Int ? = optionalHeader ( request ) val baseResponse = Response ( OK ) val responseWithHeader = optionalHeader ( anIntHeader , baseResponse ) // SAME AS : // val responseWithHeader = optionalHeader . inject ( anIntHeader , baseResponse ) responseBody ( \"you sent $pathDate and $customType\" , responseWithHeader ) } ) // With the addition of the `CatchLensFailure` filter , no other validation is required when using Lenses , as http4k will handle invalid requests by returning a BAD_REQUEST ( 400 ) response . val app = ServerFilters . CatchLensFailure . then ( handler )( Request ( GET , \"/hello/2000-01-01?myCustomType=someValue\" )) // More conveniently for construction of HTTP messages , multiple lenses can be used at once to modify a message , which is useful for properly building both requests and responses in a typesafe way without resorting to string values ( especially in URLs which should never be constructed using String concatenation ): val modifiedRequest : Request = Request ( GET , \"http://google.com/{pathLocalDate}\" ) . with ( pathLocalDate of LocalDate . now (), requiredQuery of \"myAmazingString\" , optionalHeader of 123 )","title":"Code "},{"location":"guide/modules/core/#serving-static-assets","text":"For serving static assets, just bind a path to a Static block as below, using either a Classpath or Directory (Hot reloading) based ResourceLoader instance (find these on the ResourceLoader companion object). Typically, Directory is used during development and the Classpath strategy is used to serve assets in production from an UberJar. This is usually based on a \"devmode\" flag when constructing your app\". Note that you should avoid setting the Classpath value to the root because otherwise it will serve anything from your classpath (including Java class files!)!: routes ( \"/static\" bind static ( Classpath ( \"/org/http4k/some/package/name\" )), \"/hotreload\" bind static ( Directory ( \"path/to/static/dir/goes/here\" )) )","title":"Serving static assets"},{"location":"guide/modules/core/#single-page-apps","text":"These can be easily activated as below, and default to serving from /public package: routes ( \"/api\" bind { Response ( OK ). body ( \"some api content\" ) }, singlePageApp () )","title":"Single Page Apps"},{"location":"guide/modules/core/#typesafe-websockets","text":"Websockets have been modeled using the same methodology as standard HTTP endpoints - ie. with both simplicity and testability as a first class concern, as well as benefiting from Lens-based typesafety. Websocket communication consists of 3 main concepts: WsHandler - represented as a typealias: WsHandler = (Request) -> WsConsumer? . This is responsible for matching an HTTP request to a websocket. WsConsumer - represented as a typealias: WsConsumer = (WebSocket) -> Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket. WsMessage - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the http4k HTTP message model, WsMessages are immutable data classes. The routing aspect of Websockets is done using a very similar API to the standard HTTP routing for HTTP messages and dynamic parts of the upgrade request are available when constructing a websocket instance: data class Wrapper ( val value : String ) val body = WsMessage . string (). map ( :: Wrapper , Wrapper :: value ). toLens () val nameLens = Path . of ( \"name\" ) val ws : WsHandler = websockets ( \"/hello\" bind websockets ( \"/{name}\" bind { ws : WebSocket -> val name = nameLens ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) ws . onMessage { val received = body ( it ) ws . send ( body ( received )) } ws . onClose { println ( \"closed\" ) } } ) ) A WsHandler can be combined with an HttpHandler into a PolyHandler and then mounted into a supported backend server using asServer() : val app = PolyHandler ( routes ( \"/\" bind { r : Request -> Response ( OK ) } ), websockets ( \"/ws\" bind { ws : WebSocket -> ws . send ( WsMessage ( \"hello!\" )) } ) ) app . asServer ( Jetty ( 9000 )). start () Alternatively, the WsHandler can be also converted to a synchronous WsClient - this allows testing to be done completely offline, which allows for super-fast tests: val client = app . testWsClient ( Request ( Method . GET , \"ws://localhost:9000/hello/bob\" )) !! client . send ( WsMessage ( \"1\" )) client . close ( Status ( 200 , \"bob\" )) client . received . take ( 2 ). forEach ( :: println )","title":"Typesafe Websockets."},{"location":"guide/modules/core/#request-and-response-tostring","text":"The HttpMessages used by http4k toString in the HTTP wire format, which it simple to capture and replay HTTP message streams later in a similar way to tools like Mountebank .","title":"Request and Response toString()"},{"location":"guide/modules/core/#curl-format","text":"Creates curl command for a given request - this is useful to include in audit logs so exact requests can be replayed if required: val curl = Request ( POST , \"http://httpbin.org/post\" ). body ( listOf ( \"foo\" to \"bar\" ). toBody ()). toCurl () // curl -X POST --data \"foo=bar\" \"http://httpbin.org/post\"","title":"CURL format"},{"location":"guide/modules/hamkrest/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-testing-hamkrest\", version: \"3.247.0\" About A set of Hamkrest matchers for use when testing http4k apps. Code package guide . modules . hamkrest import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasHeader import org.http4k.hamkrest.hasQuery import org.http4k.hamkrest.hasStatus import org.http4k.lens.string fun main () { val request = Request ( POST , \"/?a=b\" ) . body ( \"http4k is cool\" ) . header ( \"my header\" , \"a value\" ) // status assertThat ( Response ( OK ), hasStatus ( OK )) // query assertThat ( request , hasQuery ( \"a\" , \"b\" )) // header assertThat ( request , hasHeader ( \"my header\" , \"a value\" )) // body assertThat ( request , hasBody ( equalTo ( \"http4k is cool\" ))) assertThat ( request , hasBody ( \"http4k is cool\" )) assertThat ( request , hasBody ( Body . string ( ContentType . TEXT_HTML ) . toLens (), equalTo ( \"http4k is cool\" ))) // composite assertThat ( request , hasBody ( equalTo ( \"http4k is cool\" )) . and ( hasQuery ( \"a\" , \"b\" ))) }","title":"Hamkrest"},{"location":"guide/modules/hamkrest/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-testing-hamkrest\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/hamkrest/#about","text":"A set of Hamkrest matchers for use when testing http4k apps.","title":"About"},{"location":"guide/modules/hamkrest/#code","text":"package guide . modules . hamkrest import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.core.Body import org.http4k.core.ContentType import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasHeader import org.http4k.hamkrest.hasQuery import org.http4k.hamkrest.hasStatus import org.http4k.lens.string fun main () { val request = Request ( POST , \"/?a=b\" ) . body ( \"http4k is cool\" ) . header ( \"my header\" , \"a value\" ) // status assertThat ( Response ( OK ), hasStatus ( OK )) // query assertThat ( request , hasQuery ( \"a\" , \"b\" )) // header assertThat ( request , hasHeader ( \"my header\" , \"a value\" )) // body assertThat ( request , hasBody ( equalTo ( \"http4k is cool\" ))) assertThat ( request , hasBody ( \"http4k is cool\" )) assertThat ( request , hasBody ( Body . string ( ContentType . TEXT_HTML ) . toLens (), equalTo ( \"http4k is cool\" ))) // composite assertThat ( request , hasBody ( equalTo ( \"http4k is cool\" )) . and ( hasQuery ( \"a\" , \"b\" ))) }","title":"Code "},{"location":"guide/modules/json/","text":"Installation (Gradle) Argo: compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"3.247.0\" Gson: compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"3.247.0\" Jackson: compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.247.0\" Moshi: compile group: \"org.http4k\", name: \"http4k-format-moshi\", version: \"3.247.0\" KotlinX Serialization: compile group: \"org.http4k\", name: \"http4k-format-kotlinx-serialization\", version: \"3.247.0\" About These modules add the ability to use JSON as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of standard methods and extension methods for converting common types into native JSON/XML objects, including custom Lens methods for each library so that JSON node objects can be written and read directly from HTTP messages: Code package guide . modules . json import com.fasterxml.jackson.databind.JsonNode import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.format.Jackson import org.http4k.format.Jackson.asJsonArray import org.http4k.format.Jackson.asJsonObject import org.http4k.format.Jackson.asJsonValue import org.http4k.format.Jackson.asPrettyJsonString import org.http4k.format.Jackson.json import org.http4k.format.Xml.xml import org.w3c.dom.Node val json = Jackson // Extension method API : val objectUsingExtensionFunctions : JsonNode = listOf ( \"thisIsAString\" to \"stringValue\" . asJsonValue (), \"thisIsANumber\" to 12345. asJsonValue (), \"thisIsAList\" to listOf ( true . asJsonValue ()) . asJsonArray () ) . asJsonObject () val jsonString : String = objectUsingExtensionFunctions . asPrettyJsonString () // Direct JSON library API : val objectUsingDirectApi : JsonNode = json . obj ( \"thisIsAString\" to json . string ( \"stringValue\" ), \"thisIsANumber\" to json . number ( 12345 ), \"thisIsAList\" to json . array ( listOf ( json . boolean ( true ))) ) // DSL JSON library API : val objectUsingDslApi : JsonNode = json { obj ( \"thisIsAString\" to string ( \"stringValue\" ), \"thisIsANumber\" to number ( 12345 ), \"thisIsAList\" to array ( listOf ( boolean ( true ))) ) } val response = Response ( OK ) . with ( Body . json () . toLens () of json . array ( listOf ( objectUsingDirectApi , objectUsingExtensionFunctions , objectUsingDslApi )) ) val xmlLens = Body . xml () . toLens () val xmlNode : Node = xmlLens ( Request ( GET , \"\" ) . body ( \"<xml/>\" )) Auto-marshalling capabilities Some of the message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection. We can use this facility in http4k to automatically marshall objects to/from HTTP message bodies using Lenses : Code package guide . modules . json import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.format.Jackson.auto data class Email ( val value : String ) data class Message ( val subject : String , val from : Email , val to : Email ) fun main () { // We can use the auto method here from either Jackson , Gson or the Xml message format objects . // Note that the auto () method needs to be manually imported as IntelliJ won 't pick it up automatically. val messageLens = Body . auto < Message > () . toLens () val myMessage = Message ( \"hello\" , Email ( \"bob@git.com\" ), Email ( \"sue@git.com\" )) // to inject the body into the message - this also works with Response val requestWithEmail = messageLens ( myMessage , Request ( GET , \"/\" )) println ( requestWithEmail ) // Produces : // GET / HTTP / 1.1 // content - type : application / json // // { \"subject\" : \"hello\" , \"from\" :{ \"value\" : \"bob@git.com\" }, \"to\" :{ \"value\" : \"sue@git.com\" }} // to extract the body from the message - this also works with Response val extractedMessage = messageLens ( requestWithEmail ) println ( extractedMessage ) println ( extractedMessage == myMessage ) // Produces : // Message ( subject = hello , from = Email ( value = bob @git.com ), to = Email ( value = sue @git.com )) // true } There is a utility to generate Kotlin data class code for JSON documents here . These data classes are compatible with using the Body.auto<T>() functionality. FAQ (aka gotchas) regarding Auto-marshalling capabilities Q. Where is the Body.auto method defined? A. Body.auto is an extension method which is declared on the parent singleton object for each of the message libraries that supports auto-marshalling - eg. Jackson , Gson , Moshi and Xml . All of these objects are declared in the same package, so you need to add an import similar to: import org.http4k.format.Jackson.auto Q. Using Jackson, the Data class auto-marshalling is not working correctly when my JSON fields start with capital letters A. Because of the way in which the Jackson library works, uppercase field names are NOT supported. Either switch out to use http4k-format-gson (which has the same API), or annotate your Data class with @JsonNaming(PropertyNamingStrategy.UpperCamelCaseStrategy.class) or the fields with @JsonAlias or to get it work correctly. Q. Using Jackson, Boolean properties with names starting with \"is\" do not marshall properly A. This is due to the way in which the Jackson ObjectMapper is configured. Annotation of the fields in question should help, or using ObjectMapper.disable(MapperFeature.AUTO_DETECT_IS_GETTERS) Q. Using Gson, the data class auto-marshalling does not fail when a null is populated in a Kotlin non-nullable field A. This happens because http4k uses straight GSON demarshalling, of JVM objects with no-Kotlin library in the mix. The nullability generally gets checked at compile-type and the lack of a Kotlin sanity check library exposes this flaw. No current fix - apart from to use the Jackson demarshalling instead! Q. Declared with Body.auto<List<XXX>>().toLens() , my auto-marshalled List doesn't extract properly! A. This occurs in Moshi when serialising bare lists to/from JSON and is to do with the underlying library being lazy in deserialising objects (using LinkedHashTreeMap) ()). Use Body.auto<Array<MyIntWrapper>>().toLens() instead. Yes, it's annoying but we haven't found a way to turn if off. This can be demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list. As shown, a workaround to this is to use Body.auto<Array<MyIntWrapper>>().toLens() instead, and then compare using Arrays.equal() package guide . modules . json import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.format.Moshi.auto data class MyIntWrapper ( val value : Int ) fun main () { val aListLens = Body . auto < List < MyIntWrapper >> () . toLens () val req = Request ( GET , \"/\" ) . body ( \"\"\" [ {\"value\":1}, {\"value\":2} ] \"\"\" ) val extractedList = aListLens ( req ) val nativeList = listOf ( MyIntWrapper ( 1 ), MyIntWrapper ( 2 )) println ( nativeList ) println ( extractedList ) println ( extractedList == nativeList ) // solution : val anArrayLens = Body . auto < Array < MyIntWrapper >> () . toLens () println ( anArrayLens ( req ) . contentEquals ( arrayOf ( MyIntWrapper ( 1 ), MyIntWrapper ( 2 )))) // produces : // [ MyIntWrapper ( value = 1 ), MyIntWrapper ( value = 2 )] // [{ value = 1 }, { value = 2 }] // false // true }","title":"JSON handling"},{"location":"guide/modules/json/#installation-gradle","text":"Argo: compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"3.247.0\" Gson: compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"3.247.0\" Jackson: compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.247.0\" Moshi: compile group: \"org.http4k\", name: \"http4k-format-moshi\", version: \"3.247.0\" KotlinX Serialization: compile group: \"org.http4k\", name: \"http4k-format-kotlinx-serialization\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/json/#about","text":"These modules add the ability to use JSON as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of standard methods and extension methods for converting common types into native JSON/XML objects, including custom Lens methods for each library so that JSON node objects can be written and read directly from HTTP messages:","title":"About"},{"location":"guide/modules/json/#code","text":"package guide . modules . json import com.fasterxml.jackson.databind.JsonNode import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.format.Jackson import org.http4k.format.Jackson.asJsonArray import org.http4k.format.Jackson.asJsonObject import org.http4k.format.Jackson.asJsonValue import org.http4k.format.Jackson.asPrettyJsonString import org.http4k.format.Jackson.json import org.http4k.format.Xml.xml import org.w3c.dom.Node val json = Jackson // Extension method API : val objectUsingExtensionFunctions : JsonNode = listOf ( \"thisIsAString\" to \"stringValue\" . asJsonValue (), \"thisIsANumber\" to 12345. asJsonValue (), \"thisIsAList\" to listOf ( true . asJsonValue ()) . asJsonArray () ) . asJsonObject () val jsonString : String = objectUsingExtensionFunctions . asPrettyJsonString () // Direct JSON library API : val objectUsingDirectApi : JsonNode = json . obj ( \"thisIsAString\" to json . string ( \"stringValue\" ), \"thisIsANumber\" to json . number ( 12345 ), \"thisIsAList\" to json . array ( listOf ( json . boolean ( true ))) ) // DSL JSON library API : val objectUsingDslApi : JsonNode = json { obj ( \"thisIsAString\" to string ( \"stringValue\" ), \"thisIsANumber\" to number ( 12345 ), \"thisIsAList\" to array ( listOf ( boolean ( true ))) ) } val response = Response ( OK ) . with ( Body . json () . toLens () of json . array ( listOf ( objectUsingDirectApi , objectUsingExtensionFunctions , objectUsingDslApi )) ) val xmlLens = Body . xml () . toLens () val xmlNode : Node = xmlLens ( Request ( GET , \"\" ) . body ( \"<xml/>\" ))","title":"Code "},{"location":"guide/modules/json/#auto-marshalling-capabilities","text":"Some of the message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection. We can use this facility in http4k to automatically marshall objects to/from HTTP message bodies using Lenses :","title":"Auto-marshalling capabilities"},{"location":"guide/modules/json/#code_1","text":"package guide . modules . json import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.format.Jackson.auto data class Email ( val value : String ) data class Message ( val subject : String , val from : Email , val to : Email ) fun main () { // We can use the auto method here from either Jackson , Gson or the Xml message format objects . // Note that the auto () method needs to be manually imported as IntelliJ won 't pick it up automatically. val messageLens = Body . auto < Message > () . toLens () val myMessage = Message ( \"hello\" , Email ( \"bob@git.com\" ), Email ( \"sue@git.com\" )) // to inject the body into the message - this also works with Response val requestWithEmail = messageLens ( myMessage , Request ( GET , \"/\" )) println ( requestWithEmail ) // Produces : // GET / HTTP / 1.1 // content - type : application / json // // { \"subject\" : \"hello\" , \"from\" :{ \"value\" : \"bob@git.com\" }, \"to\" :{ \"value\" : \"sue@git.com\" }} // to extract the body from the message - this also works with Response val extractedMessage = messageLens ( requestWithEmail ) println ( extractedMessage ) println ( extractedMessage == myMessage ) // Produces : // Message ( subject = hello , from = Email ( value = bob @git.com ), to = Email ( value = sue @git.com )) // true } There is a utility to generate Kotlin data class code for JSON documents here . These data classes are compatible with using the Body.auto<T>() functionality.","title":"Code "},{"location":"guide/modules/json/#faq-aka-gotchas-regarding-auto-marshalling-capabilities","text":"Q. Where is the Body.auto method defined? A. Body.auto is an extension method which is declared on the parent singleton object for each of the message libraries that supports auto-marshalling - eg. Jackson , Gson , Moshi and Xml . All of these objects are declared in the same package, so you need to add an import similar to: import org.http4k.format.Jackson.auto Q. Using Jackson, the Data class auto-marshalling is not working correctly when my JSON fields start with capital letters A. Because of the way in which the Jackson library works, uppercase field names are NOT supported. Either switch out to use http4k-format-gson (which has the same API), or annotate your Data class with @JsonNaming(PropertyNamingStrategy.UpperCamelCaseStrategy.class) or the fields with @JsonAlias or to get it work correctly. Q. Using Jackson, Boolean properties with names starting with \"is\" do not marshall properly A. This is due to the way in which the Jackson ObjectMapper is configured. Annotation of the fields in question should help, or using ObjectMapper.disable(MapperFeature.AUTO_DETECT_IS_GETTERS) Q. Using Gson, the data class auto-marshalling does not fail when a null is populated in a Kotlin non-nullable field A. This happens because http4k uses straight GSON demarshalling, of JVM objects with no-Kotlin library in the mix. The nullability generally gets checked at compile-type and the lack of a Kotlin sanity check library exposes this flaw. No current fix - apart from to use the Jackson demarshalling instead! Q. Declared with Body.auto<List<XXX>>().toLens() , my auto-marshalled List doesn't extract properly! A. This occurs in Moshi when serialising bare lists to/from JSON and is to do with the underlying library being lazy in deserialising objects (using LinkedHashTreeMap) ()). Use Body.auto<Array<MyIntWrapper>>().toLens() instead. Yes, it's annoying but we haven't found a way to turn if off. This can be demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list. As shown, a workaround to this is to use Body.auto<Array<MyIntWrapper>>().toLens() instead, and then compare using Arrays.equal() package guide . modules . json import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.format.Moshi.auto data class MyIntWrapper ( val value : Int ) fun main () { val aListLens = Body . auto < List < MyIntWrapper >> () . toLens () val req = Request ( GET , \"/\" ) . body ( \"\"\" [ {\"value\":1}, {\"value\":2} ] \"\"\" ) val extractedList = aListLens ( req ) val nativeList = listOf ( MyIntWrapper ( 1 ), MyIntWrapper ( 2 )) println ( nativeList ) println ( extractedList ) println ( extractedList == nativeList ) // solution : val anArrayLens = Body . auto < Array < MyIntWrapper >> () . toLens () println ( anArrayLens ( req ) . contentEquals ( arrayOf ( MyIntWrapper ( 1 ), MyIntWrapper ( 2 )))) // produces : // [ MyIntWrapper ( value = 1 ), MyIntWrapper ( value = 2 )] // [{ value = 1 }, { value = 2 }] // false // true }","title":"FAQ (aka gotchas) regarding Auto-marshalling capabilities"},{"location":"guide/modules/jsonrpc/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-jsonrpc\", version: \"3.247.0\" About Support for JSON-RPC handlers, with support for both manual and automatic marshalling modes. Each service method \"name\" is bound to a particular endpoint function and then the entire API is exposed as a standard http4k HttpHandler , so it can be composed with other HttpHandlers and Filters. A specialised ErrorHandler can also be assigned to the RPC contract. Note that in order to activate JSON RPC, you need to import one of the supported JSON modules. Code package guide . modules . jsonrpc import org.http4k.core.HttpHandler import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.format.Jackson import org.http4k.format.Json import org.http4k.jsonrpc.ErrorHandler import org.http4k.jsonrpc.ErrorMessage import org.http4k.jsonrpc.JsonRpc import java.util.concurrent.atomic.AtomicInteger class Counter { private val value = AtomicInteger () fun increment ( amount : Increment ): Int = when { amount . value == 10 -> throw RuntimeException ( \"Boom!\" ) amount . value < 0 -> throw NegativeIncrementException () else -> value . addAndGet ( amount . value ) } fun currentValue (): Int = value . get () data class Increment ( val value : Int ) class NegativeIncrementException : RuntimeException ( \"negative increment not allowed\" ) } object CounterErrorHandler : ErrorHandler { override fun invoke ( error : Throwable ): ErrorMessage ? = when ( error ) { is Counter . NegativeIncrementException -> NegativeIncrementExceptionMessage () else -> null } private class NegativeIncrementExceptionMessage : ErrorMessage ( 1 , \"Increment by negative\" ) { override fun < NODE > data ( json : Json < NODE > ) = json . string ( \"cannot increment counter by negative\" ) } } fun main () { val counter = Counter () val rpcHandler : HttpHandler = JsonRpc . auto ( Jackson , CounterErrorHandler ) { method ( \"increment\" , handler ( counter :: increment )) method ( \"current\" , handler ( counter :: currentValue )) } fun runRequest ( s : String ) { println ( rpcHandler ( Request ( POST , \"/rpc\" ) . header ( \"Content-Type\" , \"application/json\" ) . body ( s ) ) ) } val increment = \"\"\" {\"jsonrpc\": \"2.0\", \"method\": \"increment\", \"params\": {\"value\": 3}, \"id\": 1} \"\"\" runRequest ( increment ) val incrementInvalid = \"\"\" {\"jsonrpc\": \"2.0\", \"method\": \"increment\", \"params\": {\"value\": -1}, \"id\": 2} \"\"\" runRequest ( incrementInvalid ) val current = \"\"\" {\"jsonrpc\": \"2.0\", \"method\": \"current\", \"id\": 3} \"\"\" runRequest ( current ) }","title":"JSON RPC"},{"location":"guide/modules/jsonrpc/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-jsonrpc\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/jsonrpc/#about","text":"Support for JSON-RPC handlers, with support for both manual and automatic marshalling modes. Each service method \"name\" is bound to a particular endpoint function and then the entire API is exposed as a standard http4k HttpHandler , so it can be composed with other HttpHandlers and Filters. A specialised ErrorHandler can also be assigned to the RPC contract. Note that in order to activate JSON RPC, you need to import one of the supported JSON modules.","title":"About"},{"location":"guide/modules/jsonrpc/#code","text":"package guide . modules . jsonrpc import org.http4k.core.HttpHandler import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.format.Jackson import org.http4k.format.Json import org.http4k.jsonrpc.ErrorHandler import org.http4k.jsonrpc.ErrorMessage import org.http4k.jsonrpc.JsonRpc import java.util.concurrent.atomic.AtomicInteger class Counter { private val value = AtomicInteger () fun increment ( amount : Increment ): Int = when { amount . value == 10 -> throw RuntimeException ( \"Boom!\" ) amount . value < 0 -> throw NegativeIncrementException () else -> value . addAndGet ( amount . value ) } fun currentValue (): Int = value . get () data class Increment ( val value : Int ) class NegativeIncrementException : RuntimeException ( \"negative increment not allowed\" ) } object CounterErrorHandler : ErrorHandler { override fun invoke ( error : Throwable ): ErrorMessage ? = when ( error ) { is Counter . NegativeIncrementException -> NegativeIncrementExceptionMessage () else -> null } private class NegativeIncrementExceptionMessage : ErrorMessage ( 1 , \"Increment by negative\" ) { override fun < NODE > data ( json : Json < NODE > ) = json . string ( \"cannot increment counter by negative\" ) } } fun main () { val counter = Counter () val rpcHandler : HttpHandler = JsonRpc . auto ( Jackson , CounterErrorHandler ) { method ( \"increment\" , handler ( counter :: increment )) method ( \"current\" , handler ( counter :: currentValue )) } fun runRequest ( s : String ) { println ( rpcHandler ( Request ( POST , \"/rpc\" ) . header ( \"Content-Type\" , \"application/json\" ) . body ( s ) ) ) } val increment = \"\"\" {\"jsonrpc\": \"2.0\", \"method\": \"increment\", \"params\": {\"value\": 3}, \"id\": 1} \"\"\" runRequest ( increment ) val incrementInvalid = \"\"\" {\"jsonrpc\": \"2.0\", \"method\": \"increment\", \"params\": {\"value\": -1}, \"id\": 2} \"\"\" runRequest ( incrementInvalid ) val current = \"\"\" {\"jsonrpc\": \"2.0\", \"method\": \"current\", \"id\": 3} \"\"\" runRequest ( current ) }","title":"Code "},{"location":"guide/modules/metrics/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-metrics-micrometer\", version: \"3.247.0\" About This module provides configurable Filters to provide metrics for http4k apps, plugging into the awesome Micrometer library. Micrometer Both Server and Client filters are available for recording request counts and latency, optionally overriding values for the metric names, descriptions and request identification. package guide . modules . metrics import io.micrometer.core.instrument.simple.SimpleMeterRegistry import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.MetricFilters import org.http4k.routing.bind import org.http4k.routing.routes fun main () { // this is a micrometer registry used mostly for testing - substitute the correct implementation . val registry = SimpleMeterRegistry () val server = routes ( \"/metrics\" bind GET to { Response ( OK ) }) // apply filters to a server ... val app = MetricFilters . Server . RequestCounter ( registry ) . then ( MetricFilters . Server . RequestTimer ( registry )) . then ( server ) // ... or to a client val client = MetricFilters . Client . RequestCounter ( registry ) . then ( MetricFilters . Client . RequestTimer ( registry )) . then ( ApacheClient ()) // make some calls ( 0. . 10 ) . forEach { app ( Request ( GET , \"/metrics\" )) client ( Request ( GET , \"https://http4k.org\" )) } // see some results registry . forEachMeter { println ( \"${it.id} ${it.measure().joinToString(\" , \")}\" ) } }","title":"Metrics"},{"location":"guide/modules/metrics/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-metrics-micrometer\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/metrics/#about","text":"This module provides configurable Filters to provide metrics for http4k apps, plugging into the awesome Micrometer library.","title":"About"},{"location":"guide/modules/metrics/#micrometer","text":"Both Server and Client filters are available for recording request counts and latency, optionally overriding values for the metric names, descriptions and request identification. package guide . modules . metrics import io.micrometer.core.instrument.simple.SimpleMeterRegistry import org.http4k.client.ApacheClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.MetricFilters import org.http4k.routing.bind import org.http4k.routing.routes fun main () { // this is a micrometer registry used mostly for testing - substitute the correct implementation . val registry = SimpleMeterRegistry () val server = routes ( \"/metrics\" bind GET to { Response ( OK ) }) // apply filters to a server ... val app = MetricFilters . Server . RequestCounter ( registry ) . then ( MetricFilters . Server . RequestTimer ( registry )) . then ( server ) // ... or to a client val client = MetricFilters . Client . RequestCounter ( registry ) . then ( MetricFilters . Client . RequestTimer ( registry )) . then ( ApacheClient ()) // make some calls ( 0. . 10 ) . forEach { app ( Request ( GET , \"/metrics\" )) client ( Request ( GET , \"https://http4k.org\" )) } // see some results registry . forEachMeter { println ( \"${it.id} ${it.measure().joinToString(\" , \")}\" ) } }","title":"Micrometer "},{"location":"guide/modules/multipart/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-multipart\", version: \"3.247.0\" About Multipart form support for fields and files, including a set of lens extensions for fields/files. See the cookbook for example use.","title":"Multipart forms"},{"location":"guide/modules/multipart/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-multipart\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/multipart/#about","text":"Multipart form support for fields and files, including a set of lens extensions for fields/files. See the cookbook for example use.","title":"About"},{"location":"guide/modules/oauth/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.247.0\" About Support for using integrating with external OAuth2 providers for authentication purposes and to provide access to external APIs of entities such as Auth0, Google etc. Specifically, http4k supports the popular OAuth2 Authorization Code Grant . This flow provides a callback mechanism that plays out like this: App developer (you!) creates an application on the OAuth provider and receives a Client Id and a Client Secret . You also provide a \"callback\" URL to the provider which will be used later. When accessing a protected resource, your app checks for an Access Token from the user (via cookie or similar) If the user has no token, the app redirects the user browser back to the OAuth provider site, along with the \"state\" of the user - containing a generated CrossSiteRequestForgeryToken (CSRF - which is also stored by the app) and the original URI the user was trying to access. The user logs in on the OAuth provider site, which generates a code that is returned as a query parameter in a redirect back to the registered callback URL in your app, along with the CSRF token. Your app checks the content of the CSRF token to determine that the redirect is genuine, then sends the received code back to the OAuth provider in exchange for a valid AccessToken . This completes the flow The AccessToken can then be used to access various services from the OAuth provider APIs. There is a single user-defined interface, OAuthPersistence , required to implement to enable this flow. This interface is required to provide the custom way in which your application will store and retrieve the CSRF and AccessToken for a request. A common way to do this is through Cookies, but the values should definitely be encrypted. http4k only provides an insecure version of this class that you can use for testing. In order to remain provider-agnostic, the AccessToken object also contains the entirety of the (typically JSON) token response from the provider, which may include other fields depending on the types of scope for which your application is authorised by the user. To enable OAuth integration, construct a configured instance of OAuthProvider . This provides 3 things: 1. A filter to protect application resources 1. A callback HttpHandler for the OAuth provider to redirect the authticated user to 1. A fully configured API client (which populated the Host on the URI) - this allows different implementations of the provider to be used across environments. Example provider Out of the box, http4k provides implementations for several OAuth providers. package guide . modules . oauth import org.http4k.client.ApacheClient import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ServerFilters import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.security.InsecureCookieBasedOAuthPersistence import org.http4k.security.OAuthProvider import org.http4k.security.google import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { // set these before running this example val googleClientId = System . getenv ( \"CLIENT_ID\" ) val googleClientSecret = System . getenv ( \"CLIENT_SECRET\" ) val port = 9000 // the callback uri which is configured in our OAuth provider val callbackUri = Uri . of ( \"http://localhost:$port/callback\" ) // this is a test implementation of the OAuthPersistence interface , which should be // implemented by application developers val oAuthPersistence = InsecureCookieBasedOAuthPersistence ( \"Google\" ) // pre - defined configuration exist for common OAuth providers val oauthProvider = OAuthProvider . google ( ApacheClient (), Credentials ( googleClientId , googleClientSecret ), callbackUri , oAuthPersistence ) // the 2 main points here are the callback handler and the authFilter , which protects the root resource val app : HttpHandler = routes ( callbackUri . path bind GET to oauthProvider . callback , \"/\" bind GET to oauthProvider . authFilter . then { Response ( OK ) . body ( \"hello!\" ) } ) ServerFilters . CatchAll () . then ( app ) . asServer ( SunHttp ( port )) . start () . block () } // browse to : http : // localhost : 9000 - you 'll be redirected to google for authentication See the cookbook for a custom implementation.","title":"OAuth"},{"location":"guide/modules/oauth/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/oauth/#about","text":"Support for using integrating with external OAuth2 providers for authentication purposes and to provide access to external APIs of entities such as Auth0, Google etc. Specifically, http4k supports the popular OAuth2 Authorization Code Grant . This flow provides a callback mechanism that plays out like this: App developer (you!) creates an application on the OAuth provider and receives a Client Id and a Client Secret . You also provide a \"callback\" URL to the provider which will be used later. When accessing a protected resource, your app checks for an Access Token from the user (via cookie or similar) If the user has no token, the app redirects the user browser back to the OAuth provider site, along with the \"state\" of the user - containing a generated CrossSiteRequestForgeryToken (CSRF - which is also stored by the app) and the original URI the user was trying to access. The user logs in on the OAuth provider site, which generates a code that is returned as a query parameter in a redirect back to the registered callback URL in your app, along with the CSRF token. Your app checks the content of the CSRF token to determine that the redirect is genuine, then sends the received code back to the OAuth provider in exchange for a valid AccessToken . This completes the flow The AccessToken can then be used to access various services from the OAuth provider APIs. There is a single user-defined interface, OAuthPersistence , required to implement to enable this flow. This interface is required to provide the custom way in which your application will store and retrieve the CSRF and AccessToken for a request. A common way to do this is through Cookies, but the values should definitely be encrypted. http4k only provides an insecure version of this class that you can use for testing. In order to remain provider-agnostic, the AccessToken object also contains the entirety of the (typically JSON) token response from the provider, which may include other fields depending on the types of scope for which your application is authorised by the user. To enable OAuth integration, construct a configured instance of OAuthProvider . This provides 3 things: 1. A filter to protect application resources 1. A callback HttpHandler for the OAuth provider to redirect the authticated user to 1. A fully configured API client (which populated the Host on the URI) - this allows different implementations of the provider to be used across environments.","title":"About"},{"location":"guide/modules/oauth/#example-provider","text":"Out of the box, http4k provides implementations for several OAuth providers. package guide . modules . oauth import org.http4k.client.ApacheClient import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ServerFilters import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.security.InsecureCookieBasedOAuthPersistence import org.http4k.security.OAuthProvider import org.http4k.security.google import org.http4k.server.SunHttp import org.http4k.server.asServer fun main () { // set these before running this example val googleClientId = System . getenv ( \"CLIENT_ID\" ) val googleClientSecret = System . getenv ( \"CLIENT_SECRET\" ) val port = 9000 // the callback uri which is configured in our OAuth provider val callbackUri = Uri . of ( \"http://localhost:$port/callback\" ) // this is a test implementation of the OAuthPersistence interface , which should be // implemented by application developers val oAuthPersistence = InsecureCookieBasedOAuthPersistence ( \"Google\" ) // pre - defined configuration exist for common OAuth providers val oauthProvider = OAuthProvider . google ( ApacheClient (), Credentials ( googleClientId , googleClientSecret ), callbackUri , oAuthPersistence ) // the 2 main points here are the callback handler and the authFilter , which protects the root resource val app : HttpHandler = routes ( callbackUri . path bind GET to oauthProvider . callback , \"/\" bind GET to oauthProvider . authFilter . then { Response ( OK ) . body ( \"hello!\" ) } ) ServerFilters . CatchAll () . then ( app ) . asServer ( SunHttp ( port )) . start () . block () } // browse to : http : // localhost : 9000 - you 'll be redirected to google for authentication See the cookbook for a custom implementation.","title":"Example provider "},{"location":"guide/modules/resilience/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-resilience4j\", version: \"3.247.0\" About This module provides configurable Filters to provide CircuitBreaking, RateLimiting, Retrying and Bulkheading, by integrating with the awesome Resilience4J library. Circuit Breaking A Circuit Filter detects failures and then Opens for a set period to allow the underlying system to recover. package guide . modules . resilience import io.github.resilience4j.circuitbreaker.CircuitBreaker import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.SlidingWindowType.COUNT_BASED import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.INTERNAL_SERVER_ERROR import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResilienceFilters import java.time.Duration import java.util.ArrayDeque // Circuit state transition : CLOSED ( ok ) -> OPEN ( dead ) -> HALF_OPEN ( test ) -> CLOSED ( ok ) fun main () { // these example responses are queued up to trigger the circuit state changes val responses = ArrayDeque < Response > () responses . add ( Response ( INTERNAL_SERVER_ERROR )) responses . add ( Response ( OK )) responses . add ( Response ( OK )) // configure the circuit breaker filter here val circuitBreaker = CircuitBreaker . of ( \"circuit\" , CircuitBreakerConfig . custom () . slidingWindow ( 2 , 2 , COUNT_BASED ) . permittedNumberOfCallsInHalfOpenState ( 2 ) . waitDurationInOpenState ( Duration . ofSeconds ( 1 )) . build () ) val circuited = ResilienceFilters . CircuitBreak ( circuitBreaker , isError = { r : Response -> ! r . status . successful } // this defaults to >= 500 ) . then { responses . removeFirst () } println ( \"Result: \" + circuited ( Request ( GET , \"/\" )) . status + \" Circuit is: \" + circuitBreaker . state ) println ( \"Result: \" + circuited ( Request ( GET , \"/\" )) . status + \" Circuit is: \" + circuitBreaker . state ) Thread . sleep ( 1100 ) // wait for reset println ( \"Result: \" + circuited ( Request ( GET , \"/\" )) . status + \" Circuit is: \" + circuitBreaker . state ) println ( \"Result: \" + circuited ( Request ( GET , \"/\" )) . status + \" Circuit is: \" + circuitBreaker . state ) } Rate Limiting A RateLimit Filter monitors the number of requests over a set window. package guide . modules . resilience import io.github.resilience4j.ratelimiter.RateLimiter import io.github.resilience4j.ratelimiter.RateLimiterConfig import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResilienceFilters import java.time.Duration fun main () { // configure the rate limiter filter here val config = RateLimiterConfig . custom () . limitRefreshPeriod ( Duration . ofSeconds ( 1 )) . limitForPeriod ( 1 ) . timeoutDuration ( Duration . ofMillis ( 10 )) . build () // set up the responses to sleep for a bit val rateLimits = ResilienceFilters . RateLimit ( RateLimiter . of ( \"ratelimiter\" , config )) . then { Response ( OK ) } println ( rateLimits ( Request ( GET , \"/\" )) . status ) println ( rateLimits ( Request ( GET , \"/\" )) . status ) } Retrying A Retrying Filter retries requests if a failure is generated. package guide . modules . resilience import io.github.resilience4j.retry.Retry import io.github.resilience4j.retry.RetryConfig import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.INTERNAL_SERVER_ERROR import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResilienceFilters import java.util.ArrayDeque fun main () { // configure the retry filter here , with max attempts and backoff val retry = Retry . of ( \"retrying\" , RetryConfig . custom < RetryConfig > () . maxAttempts ( 3 ) . intervalFunction { attempt : Int -> ( attempt * 2 ) . toLong () } . build ()) // queued up responses val responses = ArrayDeque < Response > () responses . add ( Response ( INTERNAL_SERVER_ERROR )) responses . add ( Response ( OK )) val retrying = ResilienceFilters . RetryFailures ( retry , isError = { r : Response -> ! r . status . successful } ) . then { val response = responses . removeFirst () println ( \"trying request, will return \" + response . status ) response } println ( retrying ( Request ( GET , \"/\" ))) } Bulkheading A Bulkhead Filter limits the amount of parallel calls that can be executed. package guide . modules . resilience import io.github.resilience4j.bulkhead.Bulkhead import io.github.resilience4j.bulkhead.BulkheadConfig import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResilienceFilters import java.time.Duration import kotlin.concurrent.thread fun main () { // configure the Bulkhead filter here val config = BulkheadConfig . custom () . maxConcurrentCalls ( 5 ) . maxWaitDuration ( Duration . ofMillis ( 1000 )) . build () val bulkheading = ResilienceFilters . Bulkheading ( Bulkhead . of ( \"bulkhead\" , config )) . then { Thread . sleep ( 100 ) Response ( OK ) } // throw a bunch of requests at the filter - only 5 should pass ( 1. . 10 ) . forEach { thread { println ( bulkheading ( Request ( GET , \"/\" )) . status ) } } }","title":"Resilience"},{"location":"guide/modules/resilience/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-resilience4j\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/resilience/#about","text":"This module provides configurable Filters to provide CircuitBreaking, RateLimiting, Retrying and Bulkheading, by integrating with the awesome Resilience4J library.","title":"About"},{"location":"guide/modules/resilience/#circuit-breaking","text":"A Circuit Filter detects failures and then Opens for a set period to allow the underlying system to recover. package guide . modules . resilience import io.github.resilience4j.circuitbreaker.CircuitBreaker import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig.SlidingWindowType.COUNT_BASED import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.INTERNAL_SERVER_ERROR import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResilienceFilters import java.time.Duration import java.util.ArrayDeque // Circuit state transition : CLOSED ( ok ) -> OPEN ( dead ) -> HALF_OPEN ( test ) -> CLOSED ( ok ) fun main () { // these example responses are queued up to trigger the circuit state changes val responses = ArrayDeque < Response > () responses . add ( Response ( INTERNAL_SERVER_ERROR )) responses . add ( Response ( OK )) responses . add ( Response ( OK )) // configure the circuit breaker filter here val circuitBreaker = CircuitBreaker . of ( \"circuit\" , CircuitBreakerConfig . custom () . slidingWindow ( 2 , 2 , COUNT_BASED ) . permittedNumberOfCallsInHalfOpenState ( 2 ) . waitDurationInOpenState ( Duration . ofSeconds ( 1 )) . build () ) val circuited = ResilienceFilters . CircuitBreak ( circuitBreaker , isError = { r : Response -> ! r . status . successful } // this defaults to >= 500 ) . then { responses . removeFirst () } println ( \"Result: \" + circuited ( Request ( GET , \"/\" )) . status + \" Circuit is: \" + circuitBreaker . state ) println ( \"Result: \" + circuited ( Request ( GET , \"/\" )) . status + \" Circuit is: \" + circuitBreaker . state ) Thread . sleep ( 1100 ) // wait for reset println ( \"Result: \" + circuited ( Request ( GET , \"/\" )) . status + \" Circuit is: \" + circuitBreaker . state ) println ( \"Result: \" + circuited ( Request ( GET , \"/\" )) . status + \" Circuit is: \" + circuitBreaker . state ) }","title":"Circuit Breaking "},{"location":"guide/modules/resilience/#rate-limiting","text":"A RateLimit Filter monitors the number of requests over a set window. package guide . modules . resilience import io.github.resilience4j.ratelimiter.RateLimiter import io.github.resilience4j.ratelimiter.RateLimiterConfig import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResilienceFilters import java.time.Duration fun main () { // configure the rate limiter filter here val config = RateLimiterConfig . custom () . limitRefreshPeriod ( Duration . ofSeconds ( 1 )) . limitForPeriod ( 1 ) . timeoutDuration ( Duration . ofMillis ( 10 )) . build () // set up the responses to sleep for a bit val rateLimits = ResilienceFilters . RateLimit ( RateLimiter . of ( \"ratelimiter\" , config )) . then { Response ( OK ) } println ( rateLimits ( Request ( GET , \"/\" )) . status ) println ( rateLimits ( Request ( GET , \"/\" )) . status ) }","title":"Rate Limiting "},{"location":"guide/modules/resilience/#retrying","text":"A Retrying Filter retries requests if a failure is generated. package guide . modules . resilience import io.github.resilience4j.retry.Retry import io.github.resilience4j.retry.RetryConfig import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.INTERNAL_SERVER_ERROR import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResilienceFilters import java.util.ArrayDeque fun main () { // configure the retry filter here , with max attempts and backoff val retry = Retry . of ( \"retrying\" , RetryConfig . custom < RetryConfig > () . maxAttempts ( 3 ) . intervalFunction { attempt : Int -> ( attempt * 2 ) . toLong () } . build ()) // queued up responses val responses = ArrayDeque < Response > () responses . add ( Response ( INTERNAL_SERVER_ERROR )) responses . add ( Response ( OK )) val retrying = ResilienceFilters . RetryFailures ( retry , isError = { r : Response -> ! r . status . successful } ) . then { val response = responses . removeFirst () println ( \"trying request, will return \" + response . status ) response } println ( retrying ( Request ( GET , \"/\" ))) }","title":"Retrying "},{"location":"guide/modules/resilience/#bulkheading","text":"A Bulkhead Filter limits the amount of parallel calls that can be executed. package guide . modules . resilience import io.github.resilience4j.bulkhead.Bulkhead import io.github.resilience4j.bulkhead.BulkheadConfig import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ResilienceFilters import java.time.Duration import kotlin.concurrent.thread fun main () { // configure the Bulkhead filter here val config = BulkheadConfig . custom () . maxConcurrentCalls ( 5 ) . maxWaitDuration ( Duration . ofMillis ( 1000 )) . build () val bulkheading = ResilienceFilters . Bulkheading ( Bulkhead . of ( \"bulkhead\" , config )) . then { Thread . sleep ( 100 ) Response ( OK ) } // throw a bunch of requests at the filter - only 5 should pass ( 1. . 10 ) . forEach { thread { println ( bulkheading ( Request ( GET , \"/\" )) . status ) } } }","title":"Bulkheading "},{"location":"guide/modules/serverless/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-serverless-lambda\", version: \"3.247.0\" About These modules provide integration with Serverless deployment environments, such as AWS Lambda. AWS Lambda integration Since http4k is server independent, it turns out to be fairly trivial to deploy full applications to AWS Lambda , and then call them by setting up the API Gateway to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. This has the added bonus that you can test your applications in a local environment and then simply deploy them to AWS Lambda via S3 upload. In order to achieve this, only a single interface AppLoader needs to be implemented. This is far from a complete guide, but configuring AWS Lambda and the API Gateway involves several stages: Users, Roles and Policies for the API Gateway and Lambda. API Gateway to proxy all requests to your Lambda. Building your http4k application into a standard UberJar. Optionally using Proguard to minify the JAR. Package up the (minified) JAR into a standard Zip distribution. Create and configure the Lambda function, and at the same time: Upload the standard Zip file to S3. Set the function execution to call the main http4k entry point: org.http4k.serverless.lambda.LambdaFunction::handle Set an environment variable for the Lambda HTTP4K_BOOTSTRAP_CLASS to the class of your AppLoader class. We hope to soon provide some tools to automate at least some of the above process, or at least document it somewhat. However, AWS is a complicated beast and many people have a preferred way to set it up: CloudFormation templates, Serverless framework, Terraform, etc. In the meantime, here is an example of how the AppLoader is created and a sneak peak at launching the app locally: Code package guide . modules . serverless import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent import org.http4k.client.ApacheClient import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.SunHttp import org.http4k.server.asServer import org.http4k.serverless.AppLoader import org.http4k.serverless.BootstrapAppLoader import org.http4k.serverless.lambda.LambdaFunction // This AppLoader is responsible for building our HttpHandler which is supplied to AWS // It is the only actual piece of code that needs to be written . object TweetEchoLambda : AppLoader { override fun invoke ( env : Map < String , String > ): HttpHandler = { Response ( OK ) . body ( it . bodyString () . take ( 20 )) } } fun main () { // Launching your Lambda Function locally - by simply providing the operating ENVIRONMENT map as would // be configured on AWS . fun runLambdaLocally () { val app : HttpHandler = TweetEchoLambda ( mapOf ()) val localLambda = app . asServer ( SunHttp ( 8000 )) . start () println ( ApacheClient ()( Request ( GET , \"http://localhost:8000/\" ) . body ( \"hello hello hello, i suppose this isn't 140 characters anymore..\" ))) localLambda . stop () } // the following code is purely here for demonstration purposes , to explain exactly what is happening at AWS . fun runLambdaAsAwsWould () { val lambda = LambdaFunction ( mapOf ( BootstrapAppLoader . HTTP4K_BOOTSTRAP_CLASS to TweetEchoLambda :: class . java . name )) val response = lambda . handle ( APIGatewayProxyRequestEvent () . apply { path = \"/\" body = \"hello hello hello, i suppose this isn't 140 characters anymore..\" httpMethod = \"GET\" headers = mapOf () queryStringParameters = mapOf () }) println ( response . statusCode ) println ( response . headers ) println ( response . body ) } runLambdaLocally () runLambdaAsAwsWould () }","title":"Serverless backend"},{"location":"guide/modules/serverless/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-serverless-lambda\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/serverless/#about","text":"These modules provide integration with Serverless deployment environments, such as AWS Lambda.","title":"About"},{"location":"guide/modules/serverless/#aws-lambda-integration","text":"Since http4k is server independent, it turns out to be fairly trivial to deploy full applications to AWS Lambda , and then call them by setting up the API Gateway to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. This has the added bonus that you can test your applications in a local environment and then simply deploy them to AWS Lambda via S3 upload. In order to achieve this, only a single interface AppLoader needs to be implemented. This is far from a complete guide, but configuring AWS Lambda and the API Gateway involves several stages: Users, Roles and Policies for the API Gateway and Lambda. API Gateway to proxy all requests to your Lambda. Building your http4k application into a standard UberJar. Optionally using Proguard to minify the JAR. Package up the (minified) JAR into a standard Zip distribution. Create and configure the Lambda function, and at the same time: Upload the standard Zip file to S3. Set the function execution to call the main http4k entry point: org.http4k.serverless.lambda.LambdaFunction::handle Set an environment variable for the Lambda HTTP4K_BOOTSTRAP_CLASS to the class of your AppLoader class. We hope to soon provide some tools to automate at least some of the above process, or at least document it somewhat. However, AWS is a complicated beast and many people have a preferred way to set it up: CloudFormation templates, Serverless framework, Terraform, etc. In the meantime, here is an example of how the AppLoader is created and a sneak peak at launching the app locally:","title":"AWS Lambda integration"},{"location":"guide/modules/serverless/#code","text":"package guide . modules . serverless import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent import org.http4k.client.ApacheClient import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.SunHttp import org.http4k.server.asServer import org.http4k.serverless.AppLoader import org.http4k.serverless.BootstrapAppLoader import org.http4k.serverless.lambda.LambdaFunction // This AppLoader is responsible for building our HttpHandler which is supplied to AWS // It is the only actual piece of code that needs to be written . object TweetEchoLambda : AppLoader { override fun invoke ( env : Map < String , String > ): HttpHandler = { Response ( OK ) . body ( it . bodyString () . take ( 20 )) } } fun main () { // Launching your Lambda Function locally - by simply providing the operating ENVIRONMENT map as would // be configured on AWS . fun runLambdaLocally () { val app : HttpHandler = TweetEchoLambda ( mapOf ()) val localLambda = app . asServer ( SunHttp ( 8000 )) . start () println ( ApacheClient ()( Request ( GET , \"http://localhost:8000/\" ) . body ( \"hello hello hello, i suppose this isn't 140 characters anymore..\" ))) localLambda . stop () } // the following code is purely here for demonstration purposes , to explain exactly what is happening at AWS . fun runLambdaAsAwsWould () { val lambda = LambdaFunction ( mapOf ( BootstrapAppLoader . HTTP4K_BOOTSTRAP_CLASS to TweetEchoLambda :: class . java . name )) val response = lambda . handle ( APIGatewayProxyRequestEvent () . apply { path = \"/\" body = \"hello hello hello, i suppose this isn't 140 characters anymore..\" httpMethod = \"GET\" headers = mapOf () queryStringParameters = mapOf () }) println ( response . statusCode ) println ( response . headers ) println ( response . body ) } runLambdaLocally () runLambdaAsAwsWould () }","title":"Code "},{"location":"guide/modules/servers/","text":"Installation (Gradle) Apache: compile group: \"org.http4k\", name: \"http4k-server-apache\", version: \"3.247.0\" Jetty: compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.247.0\" Ktor CIO: compile group: \"org.http4k\", name: \"http4k-server-ktorcio\", version: \"3.247.0\" Ktor Netty: compile group: \"org.http4k\", name: \"http4k-server-ktornetty\", version: \"3.247.0\" Netty: compile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"3.247.0\" Undertow: compile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"3.247.0\" SunHttp (for development only): compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\" About Server-backend modules provide a consistent API to mount HttpHandlers into the specified container in 1 LOC, by simply passing it to the relevant ServerConfig implementation (in this case Jetty ): Code package guide . modules . servers import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { { request : Request -> Response ( OK ) . body ( \"Hello World\" ) } . asServer ( Jetty ( 8000 )) . start () } Customisation Each of the server backends implement an interface ServerConfig , which is written with sensible defaults for the server in questions, but is also designed to be used as a starting point for tweaking to API user needs. To customize, simply use the relevant ServerConfig class as a starting point and reimplement as required.","title":"Server backend"},{"location":"guide/modules/servers/#installation-gradle","text":"Apache: compile group: \"org.http4k\", name: \"http4k-server-apache\", version: \"3.247.0\" Jetty: compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.247.0\" Ktor CIO: compile group: \"org.http4k\", name: \"http4k-server-ktorcio\", version: \"3.247.0\" Ktor Netty: compile group: \"org.http4k\", name: \"http4k-server-ktornetty\", version: \"3.247.0\" Netty: compile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"3.247.0\" Undertow: compile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"3.247.0\" SunHttp (for development only): compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/servers/#about","text":"Server-backend modules provide a consistent API to mount HttpHandlers into the specified container in 1 LOC, by simply passing it to the relevant ServerConfig implementation (in this case Jetty ):","title":"About"},{"location":"guide/modules/servers/#code","text":"package guide . modules . servers import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { { request : Request -> Response ( OK ) . body ( \"Hello World\" ) } . asServer ( Jetty ( 8000 )) . start () }","title":"Code "},{"location":"guide/modules/servers/#customisation","text":"Each of the server backends implement an interface ServerConfig , which is written with sensible defaults for the server in questions, but is also designed to be used as a starting point for tweaking to API user needs. To customize, simply use the relevant ServerConfig class as a starting point and reimplement as required.","title":"Customisation"},{"location":"guide/modules/servicevirtualisation/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-testing-servirtium\", version: \"3.247.0\" About Service Virtualisation testing technology provides a way of declaring contracts which can record HTTP conversations to a custom Markdown format and then replaying them later offline. http4k provides a fully featured implementation of the Servirtium solution to implement this concept. The basic idea is that you define an abstract contract Class/Interface which describes the expected behaviour for a system using a Client class (aka the Client-Under-Test ). This contract is then implemented twice: In a Recording contract - using a MiTM proxy which sits between the Client-Under-Test and the real service. This proxy records the HTTP traffic to a custom Markdown format which can be stored in a VCS, and can be configured to remove the dynamic sections of the traffic such as Date headers etc. In a Replaying contract - using an MiTM server which matches incoming traffic and replays a recorded conversation for the matched requests in order from the Markdown file. The result of these 2 implementations is that we can exercise the Client-Under-Test code against different versions of the contract without performing any actual remote calls to prove compatibility. This is important because there may be complicated orchestration required for testing against a real system, or the end service may be unavailable or flaky. http4k provides a few different pieces of support for [Serviritum]: [JUnit5] extensions which provide the record/replay behaviour, providing a way to record and replay contracts without the use of a real server. This is only compatible when the Client-Under-Test utilises a http4k Client, since it leverages the Server-as-a-Function paradigm. MiTM proxy servers for record/replay behaviour, by inserting themselves as a proxy in the HTTP call chain and intercepting the HTTP traffic. This is compatible with HTTP clients using any JVM technology, not just http4k services - so can be used as a general JVM-based solution for implementing Servirtium -style tests. A Storage Provider abstraction for storing and loading recorded contracts from various locations including disk and directly from GitHub . Examples of use Climate API Demo: github.com/http4k/servirtium-demo-kotlin-climate-tck . The climate API tested uses a simple programatic wrapper for World Bank's climate-data service. It can respond to requests with XML or JSON payloads, and the http4k-testing-servirtium module can record and payback either. This is a standard showcase for Servirtium. Kotlin Examples: Playback of a Servirtium recording: kotlin/DiskPlaybackClimateApiTests.kt Making a Servirtium recording: kotlin/DiskRecordingClimateApiTest.kt In the same package, see also a direct example for contrast, and one that can playback from recordings themselves on a website rather than from local disk. Java Examples: Playback of a Servirtium recording: java/DiskReplayClimateApiTests.java Making a Servirtium recording: java/DiskRecordingClimateApiTests.java In the same package, see also a direct example for contrast, and one that can playback from recordings themselves on a website rather than from local disk.","title":"Service Virtualisaion"},{"location":"guide/modules/servicevirtualisation/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-testing-servirtium\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/servicevirtualisation/#about","text":"Service Virtualisation testing technology provides a way of declaring contracts which can record HTTP conversations to a custom Markdown format and then replaying them later offline. http4k provides a fully featured implementation of the Servirtium solution to implement this concept. The basic idea is that you define an abstract contract Class/Interface which describes the expected behaviour for a system using a Client class (aka the Client-Under-Test ). This contract is then implemented twice: In a Recording contract - using a MiTM proxy which sits between the Client-Under-Test and the real service. This proxy records the HTTP traffic to a custom Markdown format which can be stored in a VCS, and can be configured to remove the dynamic sections of the traffic such as Date headers etc. In a Replaying contract - using an MiTM server which matches incoming traffic and replays a recorded conversation for the matched requests in order from the Markdown file. The result of these 2 implementations is that we can exercise the Client-Under-Test code against different versions of the contract without performing any actual remote calls to prove compatibility. This is important because there may be complicated orchestration required for testing against a real system, or the end service may be unavailable or flaky. http4k provides a few different pieces of support for [Serviritum]: [JUnit5] extensions which provide the record/replay behaviour, providing a way to record and replay contracts without the use of a real server. This is only compatible when the Client-Under-Test utilises a http4k Client, since it leverages the Server-as-a-Function paradigm. MiTM proxy servers for record/replay behaviour, by inserting themselves as a proxy in the HTTP call chain and intercepting the HTTP traffic. This is compatible with HTTP clients using any JVM technology, not just http4k services - so can be used as a general JVM-based solution for implementing Servirtium -style tests. A Storage Provider abstraction for storing and loading recorded contracts from various locations including disk and directly from GitHub .","title":"About"},{"location":"guide/modules/servicevirtualisation/#examples-of-use","text":"Climate API Demo: github.com/http4k/servirtium-demo-kotlin-climate-tck . The climate API tested uses a simple programatic wrapper for World Bank's climate-data service. It can respond to requests with XML or JSON payloads, and the http4k-testing-servirtium module can record and payback either. This is a standard showcase for Servirtium.","title":"Examples of use"},{"location":"guide/modules/servicevirtualisation/#kotlin-examples","text":"Playback of a Servirtium recording: kotlin/DiskPlaybackClimateApiTests.kt Making a Servirtium recording: kotlin/DiskRecordingClimateApiTest.kt In the same package, see also a direct example for contrast, and one that can playback from recordings themselves on a website rather than from local disk.","title":"Kotlin Examples:"},{"location":"guide/modules/servicevirtualisation/#java-examples","text":"Playback of a Servirtium recording: java/DiskReplayClimateApiTests.java Making a Servirtium recording: java/DiskRecordingClimateApiTests.java In the same package, see also a direct example for contrast, and one that can playback from recordings themselves on a website rather than from local disk.","title":"Java Examples:"},{"location":"guide/modules/templating/","text":"Installation (Gradle) Dust: compile group: \"org.http4k\", name: \"http4k-template-dust\", version: \"3.247.0\" Freemarker: compile group: \"org.http4k\", name: \"http4k-template-freemarker\", version: \"3.247.0\" Handlebars: compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"3.247.0\" Jade4j: compile group: \"org.http4k\", name: \"http4k-template-jade4j\", version: \"3.247.0\" Pebble: compile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"3.247.0\" Thymeleaf: compile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"3.247.0\" About The http4k templating API provides a standard mechanism for rendering using common templating libraries. Simply implement the ViewModel interface on a model class and pass it to the renderer to get a string. All of the implementations support view rendering using the following strategies: Cached on the classpath Cached from the filesystem Hot-Reloading from the filesystem The examples below are for Handlebars, but the others have the same APIs: Code package guide . modules . templating import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_HTML import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.template.HandlebarsTemplates import org.http4k.template.ViewModel import org.http4k.template.viewModel import java.io.File data class Person ( val name : String , val age : Int ) : ViewModel fun main () { // first , create a Renderer - this can be a Caching instance or a HotReload for development val renderer = HandlebarsTemplates () . HotReload ( \"src/test/resources\" ) // first example uses a renderer to create a string val app : HttpHandler = { val viewModel = Person ( \"Bob\" , 45 ) val renderedView = renderer ( viewModel ) Response ( OK ) . body ( renderedView ) } println ( app ( Request ( GET , \"/someUrl\" ))) // the lens example uses the Body . viewModel to also set the content type , and avoid using Strings val viewLens = Body . viewModel ( renderer , TEXT_HTML ) . toLens () val appUsingLens : HttpHandler = { Response ( OK ) . with ( viewLens of Person ( \"Bob\" , 45 )) } println ( appUsingLens ( Request ( GET , \"/someUrl\" ))) // overwrite the content - this will prove the hot reload works ! File ( \"src/test/resources/guide/modules/templating/Person.hbs\" ) . writer () . use { it . write ( \"{{name}} is not {{age}} years old\" ) } println ( appUsingLens ( Request ( GET , \"/someUrl\" ))) }","title":"Templating"},{"location":"guide/modules/templating/#installation-gradle","text":"Dust: compile group: \"org.http4k\", name: \"http4k-template-dust\", version: \"3.247.0\" Freemarker: compile group: \"org.http4k\", name: \"http4k-template-freemarker\", version: \"3.247.0\" Handlebars: compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"3.247.0\" Jade4j: compile group: \"org.http4k\", name: \"http4k-template-jade4j\", version: \"3.247.0\" Pebble: compile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"3.247.0\" Thymeleaf: compile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/templating/#about","text":"The http4k templating API provides a standard mechanism for rendering using common templating libraries. Simply implement the ViewModel interface on a model class and pass it to the renderer to get a string. All of the implementations support view rendering using the following strategies: Cached on the classpath Cached from the filesystem Hot-Reloading from the filesystem The examples below are for Handlebars, but the others have the same APIs:","title":"About"},{"location":"guide/modules/templating/#code","text":"package guide . modules . templating import org.http4k.core.Body import org.http4k.core.ContentType.Companion.TEXT_HTML import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.template.HandlebarsTemplates import org.http4k.template.ViewModel import org.http4k.template.viewModel import java.io.File data class Person ( val name : String , val age : Int ) : ViewModel fun main () { // first , create a Renderer - this can be a Caching instance or a HotReload for development val renderer = HandlebarsTemplates () . HotReload ( \"src/test/resources\" ) // first example uses a renderer to create a string val app : HttpHandler = { val viewModel = Person ( \"Bob\" , 45 ) val renderedView = renderer ( viewModel ) Response ( OK ) . body ( renderedView ) } println ( app ( Request ( GET , \"/someUrl\" ))) // the lens example uses the Body . viewModel to also set the content type , and avoid using Strings val viewLens = Body . viewModel ( renderer , TEXT_HTML ) . toLens () val appUsingLens : HttpHandler = { Response ( OK ) . with ( viewLens of Person ( \"Bob\" , 45 )) } println ( appUsingLens ( Request ( GET , \"/someUrl\" ))) // overwrite the content - this will prove the hot reload works ! File ( \"src/test/resources/guide/modules/templating/Person.hbs\" ) . writer () . use { it . write ( \"{{name}} is not {{age}} years old\" ) } println ( appUsingLens ( Request ( GET , \"/someUrl\" ))) }","title":"Code  "},{"location":"guide/modules/webdriver/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-testing-webdriver\", version: \"3.247.0\" About A basic Selenium WebDriver API implementation for http4k HttpHandlers, which runs completely out of container (no network) for ultra fast tests. Feature Supported Notes Navigation yes simple back/forward/refresh history CSS selectors yes Link navigation yes Form field entry and submission yes Cookie storage yes manual expiry management JavaScript no Alerts no Screenshots no Frames no Multiple windows no Use the API like any other WebDriver implementation, by simply passing your app HttpHandler to construct it: Code package guide . modules . webdriver import org.http4k.core.Method.GET import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.webdriver.Http4kWebDriver import org.openqa.selenium.By fun main () { val app = routes ( \"/hello\" bind GET to { Response ( OK ) . body ( \"<html><title>hello</title></html>\" ) } ) val driver = Http4kWebDriver ( app ) driver . navigate () . to ( \"http://localhost:10000/hello\" ) println ( driver . title ) println ( driver . findElement ( By . tagName ( \"title\" ))) // prints : // // hello // JSoupWebElement ( element =< title > hello </ title > ) }","title":"WebDriver"},{"location":"guide/modules/webdriver/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-testing-webdriver\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/webdriver/#about","text":"A basic Selenium WebDriver API implementation for http4k HttpHandlers, which runs completely out of container (no network) for ultra fast tests. Feature Supported Notes Navigation yes simple back/forward/refresh history CSS selectors yes Link navigation yes Form field entry and submission yes Cookie storage yes manual expiry management JavaScript no Alerts no Screenshots no Frames no Multiple windows no Use the API like any other WebDriver implementation, by simply passing your app HttpHandler to construct it:","title":"About"},{"location":"guide/modules/webdriver/#code","text":"package guide . modules . webdriver import org.http4k.core.Method.GET import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.webdriver.Http4kWebDriver import org.openqa.selenium.By fun main () { val app = routes ( \"/hello\" bind GET to { Response ( OK ) . body ( \"<html><title>hello</title></html>\" ) } ) val driver = Http4kWebDriver ( app ) driver . navigate () . to ( \"http://localhost:10000/hello\" ) println ( driver . title ) println ( driver . findElement ( By . tagName ( \"title\" ))) // prints : // // hello // JSoupWebElement ( element =< title > hello </ title > ) }","title":"Code "},{"location":"guide/modules/xml/","text":"Installation (Gradle) compile group: \"org.http4k\", name: \"http4k-format-xml\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-jackson-xml\", version: \"3.247.0\" About These modules provide auto-marshalling functionality to convert XML into arbitrary data classes. The 2 differ slightly in their behaviour, due to the underlying libraries used for implementation. We recommend using http4k-format-jackson-xml as it has more predictable and consistent behaviour. JacksonXml Provides bi-directional conversion Does NOT expose an XML DOM node model Generally requires Jackson field annotations to manipulate output format Provides extension point to map custom types using BiDiMapping registration (so supports all Java and Http4k primitives such as Uri ) JacksonXML Code Provides extraction conversion only Exposes an XML DOM node model as a first-class citizen - so can read directly from a string into a DOM model Does not generate a wrapper element to represent the parent node Has trouble with repeating child-elements, depending on zero, one or many elements in the XML. This is due to the underlying library implementation Only handles objects with primitive JDK types package guide . modules . xml import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.with import org.http4k.format.JacksonXml.auto data class JacksonWrapper ( val message : JacksonMsg ? ) data class JacksonMsg ( val subject : String ? , val from : String ? , val to : String ? , val content : String ? ) fun main () { // We can use the auto method here from the JacksonXML message format object. Note that the // auto () method is an extension function which needs to be manually imported ( IntelliJ won 't pick it up automatically). val messageLens = Body . auto < JacksonWrapper > () . toLens () // extract the body from the message - this also works with Response val wrapper = JacksonWrapper ( JacksonMsg ( \"subject\" , \"from\" , \"to\" , \"content\" )) val message = \"\"\"<jacksonWrapper><message subject=\"hi\"><from>david@http4k.org</from><to>ivan@http4k.org</to>hello world</message></jacksonWrapper>\"\"\" println ( messageLens ( Request ( GET , \"/\" ) . body ( message ))) // inject a converted object - as - XML - string into a request println ( Request ( GET , \"\" ) . with ( messageLens . of ( wrapper )) . bodyString ()) } Xml As above, we recommend using http4k-format-jackson-xml as it has more predictable and consistent behaviour. XML Code package guide . modules . xml import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.format.Xml.auto data class XmlWrapper ( val mesApacheClientStreamingContractessage : MessageXml ? ) data class MessageXml ( val subject : String ? , val from : String ? , val to : String ? , val content : String ? ) fun main () { // We can use the auto method here from the Xml message format object. Note that the // auto () method is an extension function which needs to be manually imported ( IntelliJ won 't pick it up automatically). // Also , this lense is ONLY one way - to extract values from a message val messageLens = Body . auto < XmlWrapper > () . toLens () // extract the body from the message - this also works with Response val message = \"\"\"<message subject=\"hi\"><from>david@http4k.org</from><to>ivan@http4k.org</to>hello world</message>\"\"\" val requestWithEmail = Request ( GET , \"/\" ) . body ( message ) println ( messageLens ( requestWithEmail )) }","title":"XML handling"},{"location":"guide/modules/xml/#installation-gradle","text":"compile group: \"org.http4k\", name: \"http4k-format-xml\", version: \"3.247.0\" compile group: \"org.http4k\", name: \"http4k-format-jackson-xml\", version: \"3.247.0\"","title":"Installation (Gradle)"},{"location":"guide/modules/xml/#about","text":"These modules provide auto-marshalling functionality to convert XML into arbitrary data classes. The 2 differ slightly in their behaviour, due to the underlying libraries used for implementation. We recommend using http4k-format-jackson-xml as it has more predictable and consistent behaviour.","title":"About"},{"location":"guide/modules/xml/#jacksonxml","text":"Provides bi-directional conversion Does NOT expose an XML DOM node model Generally requires Jackson field annotations to manipulate output format Provides extension point to map custom types using BiDiMapping registration (so supports all Java and Http4k primitives such as Uri )","title":"JacksonXml"},{"location":"guide/modules/xml/#jacksonxml-code","text":"Provides extraction conversion only Exposes an XML DOM node model as a first-class citizen - so can read directly from a string into a DOM model Does not generate a wrapper element to represent the parent node Has trouble with repeating child-elements, depending on zero, one or many elements in the XML. This is due to the underlying library implementation Only handles objects with primitive JDK types package guide . modules . xml import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.with import org.http4k.format.JacksonXml.auto data class JacksonWrapper ( val message : JacksonMsg ? ) data class JacksonMsg ( val subject : String ? , val from : String ? , val to : String ? , val content : String ? ) fun main () { // We can use the auto method here from the JacksonXML message format object. Note that the // auto () method is an extension function which needs to be manually imported ( IntelliJ won 't pick it up automatically). val messageLens = Body . auto < JacksonWrapper > () . toLens () // extract the body from the message - this also works with Response val wrapper = JacksonWrapper ( JacksonMsg ( \"subject\" , \"from\" , \"to\" , \"content\" )) val message = \"\"\"<jacksonWrapper><message subject=\"hi\"><from>david@http4k.org</from><to>ivan@http4k.org</to>hello world</message></jacksonWrapper>\"\"\" println ( messageLens ( Request ( GET , \"/\" ) . body ( message ))) // inject a converted object - as - XML - string into a request println ( Request ( GET , \"\" ) . with ( messageLens . of ( wrapper )) . bodyString ()) }","title":"JacksonXML Code "},{"location":"guide/modules/xml/#xml","text":"As above, we recommend using http4k-format-jackson-xml as it has more predictable and consistent behaviour.","title":"Xml"},{"location":"guide/modules/xml/#xml-code","text":"package guide . modules . xml import org.http4k.core.Body import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.format.Xml.auto data class XmlWrapper ( val mesApacheClientStreamingContractessage : MessageXml ? ) data class MessageXml ( val subject : String ? , val from : String ? , val to : String ? , val content : String ? ) fun main () { // We can use the auto method here from the Xml message format object. Note that the // auto () method is an extension function which needs to be manually imported ( IntelliJ won 't pick it up automatically). // Also , this lense is ONLY one way - to extract values from a message val messageLens = Body . auto < XmlWrapper > () . toLens () // extract the body from the message - this also works with Response val message = \"\"\"<message subject=\"hi\"><from>david@http4k.org</from><to>ivan@http4k.org</to>hello world</message>\"\"\" val requestWithEmail = Request ( GET , \"/\" ) . body ( message ) println ( messageLens ( requestWithEmail )) }","title":"XML Code "},{"location":"guide/testing/","text":"The creators of http4k takes testing very seriously - so seriously that there really isn't that much to say here! The API has been designed to make it as simple as possible to test both individual endpoints and entire applications in a consistent fashion, which is aided by remembering that: The input and output Request/Response objects are immutable. HttpHandlers are just functions. An entire http4k application is just an HttpHandler . Because of the above, there really isn't much required in the way of \"testing infrastructure\" - no magic containers or test fixtures that you might find in other frameworks. Testing is just matter of calling the correct function! Additionally, because the server and client HttpHandler interfaces are symmetrical - moving between in and out of container contexts (or indeed even to another HTTP framework entirely) is just a matter of switching out the HttpHandler implementation from the constructed app (out of container) to an HTTP client (in-container). That said, possibly the most useful thing is to demonstrate the process that we have developed to test micro-services. A simple example of the development process can be found here . Testing modules We have developed the following modules to help with testing: http4k-testing-hamkrest : a set of composable Hamkrest matchers for matching http4k message objects against. http4k-testing-webdriver : an ultra-lightweight Selenium WebDriver implementation which can be used to test-drive http4k apps (ie. HttpHandlers). http4k-testing-approval : JUnit 5 extensions for Approval testing of http4k Request and Response messages. http4k-testing-chaos : API for declaring and injecting failure modes into http4k applications, allowing modelling and hence answering of \"what if\" style questions to help understand how code fares under failure conditions such as latency and dying processes. Example code for testing Testing HttpHandlers with static paths package guide . testing import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.Test val EchoBody : HttpHandler = { r -> Response ( OK ) . body ( r . bodyString ()) } class StaticPathTest { @Test fun `echoes body from request` () { Request ( GET , \"/anything\" ) . body ( \"my data is large\" ) val response : Response = EchoBody ( Request ( GET , \"/anything\" ) . body ( \"my data is large\" )) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"my data is large\" ))) } } Testing HttpHandlers with dynamic paths package guide . testing import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.http4k.routing.RoutingHttpHandler import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.junit.jupiter.api.Test val EchoPath = \"/echo/{message}\" bind GET to { r -> Response ( OK ) . body ( r . path ( \"message\" ) ? : \"nothing!\" ) } class DynamicPathTest { @Test fun `echoes body from path` () { val route : RoutingHttpHandler = routes ( EchoPath ) val response : Response = route ( Request ( GET , \"/echo/my+great+message\" )) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"my great message\" ))) } } Testing Filters package guide . testing import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.hamkrest.hasHeader import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.Test val AddLatency = Filter { next -> { next ( it ) . header ( \"x-extra-header\" , \"some value\" ) } } class FilterTest { @Test fun `adds a special header` () { val handler : HttpHandler = AddLatency . then { Response ( OK ) } val response : Response = handler ( Request ( GET , \"/echo/my+great+message\" )) assertThat ( response , hasStatus ( OK ) . and ( hasHeader ( \"x-extra-header\" , \"some value\" ))) } } Testing Websockets with offline and online clients package guide . testing import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.WebsocketClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Uri import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.testing.testWsClient import org.http4k.websocket.Websocket import org.http4k.websocket.WsClient import org.http4k.websocket.WsHandler import org.http4k.websocket.WsMessage import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test val namePath = Path . of ( \"name\" ) // here is our websocket app - it uses dynamic path binding and lenses val testApp : WsHandler = websockets ( \"/{name}\" bind { ws : Websocket -> val name = namePath ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) } ) // this is the abstract contract that defines the behaviour to be tested abstract class WebsocketContract { // subclasses only have to supply a blocking WsClient abstract fun client (): WsClient @Test fun `echoes back connected name` () { assertThat ( client () . received () . take ( 1 ) . toList (), equalTo ( listOf ( WsMessage ( \"hello bob\" )))) } } // a unit test version of the contract - it connects to the websocket in memory with no network class WebsocketUnitTest : WebsocketContract () { override fun client () = cookbook . websockets . testApp . testWsClient ( Request ( GET , \"/bob\" )) !! } // a integration test version of the contract - it starts a server and connects to the websocket over the network class WebsocketServerTest : WebsocketContract () { override fun client () = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/bob\" )) private val server = cookbook . websockets . testApp . asServer ( Jetty ( 8000 )) @BeforeEach fun before () { server . start () } @AfterEach fun after () { server . stop () } }","title":"Application Testing"},{"location":"guide/testing/#testing-modules","text":"We have developed the following modules to help with testing: http4k-testing-hamkrest : a set of composable Hamkrest matchers for matching http4k message objects against. http4k-testing-webdriver : an ultra-lightweight Selenium WebDriver implementation which can be used to test-drive http4k apps (ie. HttpHandlers). http4k-testing-approval : JUnit 5 extensions for Approval testing of http4k Request and Response messages. http4k-testing-chaos : API for declaring and injecting failure modes into http4k applications, allowing modelling and hence answering of \"what if\" style questions to help understand how code fares under failure conditions such as latency and dying processes.","title":"Testing modules"},{"location":"guide/testing/#example-code-for-testing","text":"","title":"Example code for testing"},{"location":"guide/testing/#testing-httphandlers-with-static-paths","text":"package guide . testing import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.Test val EchoBody : HttpHandler = { r -> Response ( OK ) . body ( r . bodyString ()) } class StaticPathTest { @Test fun `echoes body from request` () { Request ( GET , \"/anything\" ) . body ( \"my data is large\" ) val response : Response = EchoBody ( Request ( GET , \"/anything\" ) . body ( \"my data is large\" )) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"my data is large\" ))) } }","title":"Testing HttpHandlers with static paths "},{"location":"guide/testing/#testing-httphandlers-with-dynamic-paths","text":"package guide . testing import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.http4k.routing.RoutingHttpHandler import org.http4k.routing.bind import org.http4k.routing.path import org.http4k.routing.routes import org.junit.jupiter.api.Test val EchoPath = \"/echo/{message}\" bind GET to { r -> Response ( OK ) . body ( r . path ( \"message\" ) ? : \"nothing!\" ) } class DynamicPathTest { @Test fun `echoes body from path` () { val route : RoutingHttpHandler = routes ( EchoPath ) val response : Response = route ( Request ( GET , \"/echo/my+great+message\" )) assertThat ( response , hasStatus ( OK ) . and ( hasBody ( \"my great message\" ))) } }","title":"Testing HttpHandlers with dynamic paths "},{"location":"guide/testing/#testing-filters","text":"package guide . testing import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.hamkrest.hasHeader import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.Test val AddLatency = Filter { next -> { next ( it ) . header ( \"x-extra-header\" , \"some value\" ) } } class FilterTest { @Test fun `adds a special header` () { val handler : HttpHandler = AddLatency . then { Response ( OK ) } val response : Response = handler ( Request ( GET , \"/echo/my+great+message\" )) assertThat ( response , hasStatus ( OK ) . and ( hasHeader ( \"x-extra-header\" , \"some value\" ))) } }","title":"Testing Filters "},{"location":"guide/testing/#testing-websockets-with-offline-and-online-clients","text":"package guide . testing import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.WebsocketClient import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Uri import org.http4k.lens.Path import org.http4k.routing.bind import org.http4k.routing.websockets import org.http4k.server.Jetty import org.http4k.server.asServer import org.http4k.testing.testWsClient import org.http4k.websocket.Websocket import org.http4k.websocket.WsClient import org.http4k.websocket.WsHandler import org.http4k.websocket.WsMessage import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test val namePath = Path . of ( \"name\" ) // here is our websocket app - it uses dynamic path binding and lenses val testApp : WsHandler = websockets ( \"/{name}\" bind { ws : Websocket -> val name = namePath ( ws . upgradeRequest ) ws . send ( WsMessage ( \"hello $name\" )) } ) // this is the abstract contract that defines the behaviour to be tested abstract class WebsocketContract { // subclasses only have to supply a blocking WsClient abstract fun client (): WsClient @Test fun `echoes back connected name` () { assertThat ( client () . received () . take ( 1 ) . toList (), equalTo ( listOf ( WsMessage ( \"hello bob\" )))) } } // a unit test version of the contract - it connects to the websocket in memory with no network class WebsocketUnitTest : WebsocketContract () { override fun client () = cookbook . websockets . testApp . testWsClient ( Request ( GET , \"/bob\" )) !! } // a integration test version of the contract - it starts a server and connects to the websocket over the network class WebsocketServerTest : WebsocketContract () { override fun client () = WebsocketClient . blocking ( Uri . of ( \"ws://localhost:8000/bob\" )) private val server = cookbook . websockets . testApp . asServer ( Jetty ( 8000 )) @BeforeEach fun before () { server . start () } @AfterEach fun after () { server . stop () } }","title":"Testing Websockets with offline and online clients "},{"location":"in_action/","text":"Rationale & design KotlinConf presentations: Server as a Function. In Kotlin. _ _ ____ Slides Video See http4k in action in these example projects and repos: Each project is tagged with the http4k features it demonstrates: \"Hello World\" CD pipeline TDD'd example application Templates Testing JSON / Lenses CD pipeline Approval Testing OpenApi Static resources Dropbox clone in 70 lines of Kotlin Templates Testing Http Client Multipart AWS CD pipeline Serverless GraalVM Simple websocket driven chat-server in 30 lines of Kotlin Testing Websockets CD Pipeline Static resources Stage-by-stage example of London-style TDD development process Testing Todo backend (standard routing) Testing JSON / Lenses CD pipeline Todo backend (contract routing) Testing JSON / Lenses OpenApi CD pipeline Real World example (Medium clone) Testing Contracts","title":"In action"},{"location":"in_action/#rationale-design","text":"","title":"Rationale &amp; design"},{"location":"in_action/#kotlinconf-presentations-server-as-a-function-in-kotlin-______","text":"Slides Video","title":"KotlinConf presentations: Server as a Function. In Kotlin. ______"},{"location":"in_action/#see-http4k-in-action-in-these-example-projects-and-repos","text":"Each project is tagged with the http4k features it demonstrates:","title":"See http4k in action in these example projects and repos:"},{"location":"in_action/#hello-world","text":"CD pipeline","title":"\"Hello World\""},{"location":"in_action/#tddd-example-application","text":"Templates Testing JSON / Lenses CD pipeline Approval Testing OpenApi Static resources","title":"TDD'd example application"},{"location":"in_action/#dropbox-clone-in-70-lines-of-kotlin","text":"Templates Testing Http Client Multipart AWS CD pipeline Serverless GraalVM","title":"Dropbox clone in 70 lines of Kotlin"},{"location":"in_action/#simple-websocket-driven-chat-server-in-30-lines-of-kotlin","text":"Testing Websockets CD Pipeline Static resources","title":"Simple websocket driven chat-server in 30 lines of Kotlin"},{"location":"in_action/#stage-by-stage-example-of-london-style-tdd-development-process","text":"Testing","title":"Stage-by-stage example of London-style TDD development process"},{"location":"in_action/#todo-backend-standard-routing","text":"Testing JSON / Lenses CD pipeline","title":"Todo backend (standard routing)"},{"location":"in_action/#todo-backend-contract-routing","text":"Testing JSON / Lenses OpenApi CD pipeline","title":"Todo backend (contract routing)"},{"location":"in_action/#real-world-example-medium-clone","text":"Testing Contracts","title":"Real World example (Medium clone)"},{"location":"installation/","text":"All http4k libraries are available on Maven Central and JCenter and are released under a single version. For the core module, add the following to your Gradle file: compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.247.0\"","title":"Installation"},{"location":"performance/","text":"The http4k server-backend modules provide a very thin adapter layer over the raw APIs of the underlying servers, so generally performs at a very low overhead compared to the raw server. Tech Empower Benchmarks We have entered http4k into the prominent Tech Empower Framework Benchmarks project, which assesses frameworks over a series of realistic tests. For this benchmark, no customisation or performance tuning of the underlying servers was done - the default application HttpHandler was used which is then plugged into each custom backend, as below: fun main () { Http4kBenchmarkServer . start ( Undertow ( 9000 )) } Command-line JVM options, however, were tuned for the test to take advantage of various JVM features. The full implementation of the benchmark can be found here . Results - Round 17 Overall, http4k did very well in this round of benchmarking, especially considering that the ethos of the library is one of excellent Developer experience over and above high-end performance (which tends to result in less friendly APIs). The big surprise was the high performance of the Apache server backend, which consistently outranked Undertow (which is the the most fully featured of all the supported backends and our default option). The SunHttp backend, which we entered for a baseline comparison, unfortunately didn't produce any results in this round. DB query + HTML rendering: results : Top rank: 6/73 - Apache backend Database driver used is PostgreSql backed by a Hikari pool. Handlebars templating engine is used for rendering. Multiple DB queries: results : Top rank: 3/66 - Jetty backend Database driver used is PostgreSql backed by a Hikari pool. Single DB query: results : Top rank: 8/68 - Apache backend Database driver used is PostgreSql backed by a Hikari pool. Random DB updates: results : Top rank: 14/59 - Jetty backend Database driver used is PostgreSql backed by a Hikari pool. JSON Serialization: results : Top rank: 20/69 - Apache backend The standard Jackson module is used for JSON creation and marshalling. Plaintext pipelining: results : Top rank: 23/66 - Apache backend Recommendations Benchmark your own app's performance trying different engines if performance is critical. The Tech Empower benchmarks attempt to simulate simple real-world scenarios, but they can behave drastically different than your app. One other consideration is test time; some engines start up much faster than others.","title":"Performance"},{"location":"performance/#tech-empower-benchmarks","text":"We have entered http4k into the prominent Tech Empower Framework Benchmarks project, which assesses frameworks over a series of realistic tests. For this benchmark, no customisation or performance tuning of the underlying servers was done - the default application HttpHandler was used which is then plugged into each custom backend, as below: fun main () { Http4kBenchmarkServer . start ( Undertow ( 9000 )) } Command-line JVM options, however, were tuned for the test to take advantage of various JVM features. The full implementation of the benchmark can be found here .","title":"Tech Empower Benchmarks"},{"location":"performance/#results-round-17","text":"Overall, http4k did very well in this round of benchmarking, especially considering that the ethos of the library is one of excellent Developer experience over and above high-end performance (which tends to result in less friendly APIs). The big surprise was the high performance of the Apache server backend, which consistently outranked Undertow (which is the the most fully featured of all the supported backends and our default option). The SunHttp backend, which we entered for a baseline comparison, unfortunately didn't produce any results in this round.","title":"Results - Round 17"},{"location":"performance/#db-query-html-rendering-results","text":"Top rank: 6/73 - Apache backend Database driver used is PostgreSql backed by a Hikari pool. Handlebars templating engine is used for rendering.","title":"DB query + HTML rendering: results:"},{"location":"performance/#multiple-db-queries-results","text":"Top rank: 3/66 - Jetty backend Database driver used is PostgreSql backed by a Hikari pool.","title":"Multiple DB queries: results:"},{"location":"performance/#single-db-query-results","text":"Top rank: 8/68 - Apache backend Database driver used is PostgreSql backed by a Hikari pool.","title":"Single DB query: results:"},{"location":"performance/#random-db-updates-results","text":"Top rank: 14/59 - Jetty backend Database driver used is PostgreSql backed by a Hikari pool.","title":"Random DB updates: results:"},{"location":"performance/#json-serialization-results","text":"Top rank: 20/69 - Apache backend The standard Jackson module is used for JSON creation and marshalling.","title":"JSON Serialization: results:"},{"location":"performance/#plaintext-pipelining-results","text":"Top rank: 23/66 - Apache backend","title":"Plaintext pipelining: results:"},{"location":"performance/#recommendations","text":"Benchmark your own app's performance trying different engines if performance is critical. The Tech Empower benchmarks attempt to simulate simple real-world scenarios, but they can behave drastically different than your app. One other consideration is test time; some engines start up much faster than others.","title":"Recommendations"},{"location":"quickstart/","text":"Quickstart This simple example demonstates how to serve and consume HTTP services using http4k . To install, add these dependencies to your Gradle file: dependencies { compile group: \"org.http4k\" , name: \"http4k-core\" , version: \"3.247.0\" compile group: \"org.http4k\" , name: \"http4k-server-jetty\" , version: \"3.247.0\" compile group: \"org.http4k\" , name: \"http4k-client-apache\" , version: \"3.247.0\" } The following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it. package quickstart import org.http4k.client.ApacheClient import org.http4k.core.Method import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { val app = { request : Request -> Response ( OK ) . body ( \"Hello, ${request.query(\" name \")}!\" ) } val jettyServer = app . asServer ( Jetty ( 9000 )) . start () val request = Request ( Method . GET , \"http://localhost:9000\" ) . query ( \"name\" , \"John Doe\" ) val client = ApacheClient () println ( client ( request )) jettyServer . stop () } Single-line CD Bootstrap Run the single command in the readme of this repo to create a HelloWorld http4k app with a full CD pipeline using Github -> TravisCI -> Heroku. Why should I use this library? Presentation about the development of http4k given at the Kotlin London meetup.","title":"Getting started"},{"location":"quickstart/#quickstart","text":"This simple example demonstates how to serve and consume HTTP services using http4k . To install, add these dependencies to your Gradle file: dependencies { compile group: \"org.http4k\" , name: \"http4k-core\" , version: \"3.247.0\" compile group: \"org.http4k\" , name: \"http4k-server-jetty\" , version: \"3.247.0\" compile group: \"org.http4k\" , name: \"http4k-client-apache\" , version: \"3.247.0\" } The following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it. package quickstart import org.http4k.client.ApacheClient import org.http4k.core.Method import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.Jetty import org.http4k.server.asServer fun main () { val app = { request : Request -> Response ( OK ) . body ( \"Hello, ${request.query(\" name \")}!\" ) } val jettyServer = app . asServer ( Jetty ( 9000 )) . start () val request = Request ( Method . GET , \"http://localhost:9000\" ) . query ( \"name\" , \"John Doe\" ) val client = ApacheClient () println ( client ( request )) jettyServer . stop () }","title":"Quickstart"},{"location":"quickstart/#single-line-cd-bootstrap","text":"Run the single command in the readme of this repo to create a HelloWorld http4k app with a full CD pipeline using Github -> TravisCI -> Heroku.","title":"Single-line CD Bootstrap"},{"location":"quickstart/#why-should-i-use-this-library","text":"Presentation about the development of http4k given at the Kotlin London meetup.","title":"Why should I use this library?"},{"location":"rationale/","text":"tldr; Presentation about the development of http4k given at the Kotlin London meetup. About http4k is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - the routing module is inspired by UtterlyIdle , the \"Server as a function\" and filter model is stolen from Finagle , and the contract module OpenApi/Swagger generator is ported from Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch. For our purposes, we needed something that: Starts/stops ultra quickly. Easily testable outside of an HTTP container, and testing should require little to no custom infrastructure. Provides typesafe HTTP message deconstruction/construction (in this case via Lenses). Automatically deals with contract breaches (missing/invalid params etc) to remove boilerplate. Absolutely no magic involved: No reflection. No annotations. Minimal dependencies (apart from the Kotlin StdLib, http4k-core has zero). Automatic generation of OpenApi/Swagger documentation (including JSON Schema models). Has a symmetric server/client API ( HttpHandler should just be Request -> Response ). Has immutable Request/Response objects. http4k ticks all of these boxes. It allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers using a single line of code. The symmetric HTTP API also allows Filter chains (often called \"Middleware\" or \"Interceptors\" in other frameworks) to be constructed into reusable units/stacks for both server and client sides (eg. logging/metrics/caching...) since they can be composed together for later use. As a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests). Scenarios such as \"what happens if this HTTP dependency continually takes > 5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary. Concepts All incoming and outgoing HTTP services are modelled as HttpHandler , which is modelled as (Request) -> Response : val handler : HttpHandler = { request : Request -> Response ( OK ) } Pre/post processing is done using a Filter , which is modelled as (HttpHandler) -> HttpHandler . Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating HttpHandler - to yield a decorated HttpHandler : val filter : Filter = Filter { next : HttpHandler -> { request : Request -> next ( request ). header ( \"my response header\" , \"value\" ) } } val decorated : HttpHandler = filter . then ( handler ) Binding an HttpHandler to a path and HTTP verb yields a RoutingHttpHandler , which is both an HttpHandler and a Router : val route : RoutingHttpHandler = \"/path\" bind GET to { Response ( OK ). body ( \"you GET bob\" ) } RoutingHttpHandler s can be grouped together: val app : RoutingHttpHandler = routes ( \"/bob\" bind GET to { Response ( OK ). body ( \"you GET bob\" ) }, \"/rita\" bind POST to { Response ( OK ). body ( \"you POST rita\" ) }, \"/sue\" bind DELETE to { Response ( OK ). body ( \"you DELETE sue\" ) } ) A Router is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next Router in the list. Routers can be combined together (under particular context roots) to form another RoutingHttpHandler : val bigApp : HttpHandler = routes ( \"/this\" bind app , \"/other\" bind app ) HttpHandlers can be bound to a container (to create an Http4kServer ) with 1 LOC. The decouples the server implementation from the business logic: val jettyServer = app . asServer ( Jetty ( 9000 )). start () An Http client is also a HttpHandler : val client : HttpHandler = ApacheClient () Because the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other: val app1 : HttpHandler = MyApp1 () val app2 : HttpHandler = MyApp2 ( app1 )","title":"Rationale & Concepts"},{"location":"rationale/#tldr","text":"Presentation about the development of http4k given at the Kotlin London meetup.","title":"tldr;"},{"location":"rationale/#about","text":"http4k is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - the routing module is inspired by UtterlyIdle , the \"Server as a function\" and filter model is stolen from Finagle , and the contract module OpenApi/Swagger generator is ported from Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch. For our purposes, we needed something that: Starts/stops ultra quickly. Easily testable outside of an HTTP container, and testing should require little to no custom infrastructure. Provides typesafe HTTP message deconstruction/construction (in this case via Lenses). Automatically deals with contract breaches (missing/invalid params etc) to remove boilerplate. Absolutely no magic involved: No reflection. No annotations. Minimal dependencies (apart from the Kotlin StdLib, http4k-core has zero). Automatic generation of OpenApi/Swagger documentation (including JSON Schema models). Has a symmetric server/client API ( HttpHandler should just be Request -> Response ). Has immutable Request/Response objects. http4k ticks all of these boxes. It allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers using a single line of code. The symmetric HTTP API also allows Filter chains (often called \"Middleware\" or \"Interceptors\" in other frameworks) to be constructed into reusable units/stacks for both server and client sides (eg. logging/metrics/caching...) since they can be composed together for later use. As a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests). Scenarios such as \"what happens if this HTTP dependency continually takes > 5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary.","title":"About"},{"location":"rationale/#concepts","text":"All incoming and outgoing HTTP services are modelled as HttpHandler , which is modelled as (Request) -> Response : val handler : HttpHandler = { request : Request -> Response ( OK ) } Pre/post processing is done using a Filter , which is modelled as (HttpHandler) -> HttpHandler . Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating HttpHandler - to yield a decorated HttpHandler : val filter : Filter = Filter { next : HttpHandler -> { request : Request -> next ( request ). header ( \"my response header\" , \"value\" ) } } val decorated : HttpHandler = filter . then ( handler ) Binding an HttpHandler to a path and HTTP verb yields a RoutingHttpHandler , which is both an HttpHandler and a Router : val route : RoutingHttpHandler = \"/path\" bind GET to { Response ( OK ). body ( \"you GET bob\" ) } RoutingHttpHandler s can be grouped together: val app : RoutingHttpHandler = routes ( \"/bob\" bind GET to { Response ( OK ). body ( \"you GET bob\" ) }, \"/rita\" bind POST to { Response ( OK ). body ( \"you POST rita\" ) }, \"/sue\" bind DELETE to { Response ( OK ). body ( \"you DELETE sue\" ) } ) A Router is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next Router in the list. Routers can be combined together (under particular context roots) to form another RoutingHttpHandler : val bigApp : HttpHandler = routes ( \"/this\" bind app , \"/other\" bind app ) HttpHandlers can be bound to a container (to create an Http4kServer ) with 1 LOC. The decouples the server implementation from the business logic: val jettyServer = app . asServer ( Jetty ( 9000 )). start () An Http client is also a HttpHandler : val client : HttpHandler = ApacheClient () Because the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other: val app1 : HttpHandler = MyApp1 () val app2 : HttpHandler = MyApp2 ( app1 )","title":"Concepts"},{"location":"support/","text":"Commercial Support We recognise that although organisations use happily Open Source Software such as http4k , they may gain additional peace of mind from having direct access to expert advice. For this purpose, the project creators offer a range of professional services to support library users in making the most of the powerful feature set which http4k provides, including: System architecture and design review Testing strategy and implementation review Project-level Developer and Team mentoring On-site http4k talks and training Troubleshooting integration issues and debugging Kotlin language Developer training Advice on extending or creating custom builds of http4k Please get in touch at: support@http4k.org General Help In the first instance, try and see if there is a relevant example in the cookbook or FAQ - more and more are being added all the time! For issues, please describe giving as much detail as you can - including version and steps to recreate. Slack room: #http4k @ slack.kotlinlang.org <-- PREFERRED Gitter channel: http4k/http4k @ gitter.im Twitter: @http4k Note: As a general rule, you'll get a quicker response from the Slack channel. Logo Usage The http4k logo design and branding are copyright 2019 to the owners of http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant branding guidelines .","title":"Getting Support"},{"location":"support/#commercial-support","text":"We recognise that although organisations use happily Open Source Software such as http4k , they may gain additional peace of mind from having direct access to expert advice. For this purpose, the project creators offer a range of professional services to support library users in making the most of the powerful feature set which http4k provides, including: System architecture and design review Testing strategy and implementation review Project-level Developer and Team mentoring On-site http4k talks and training Troubleshooting integration issues and debugging Kotlin language Developer training Advice on extending or creating custom builds of http4k Please get in touch at: support@http4k.org","title":"Commercial Support"},{"location":"support/#general-help","text":"In the first instance, try and see if there is a relevant example in the cookbook or FAQ - more and more are being added all the time! For issues, please describe giving as much detail as you can - including version and steps to recreate. Slack room: #http4k @ slack.kotlinlang.org <-- PREFERRED Gitter channel: http4k/http4k @ gitter.im Twitter: @http4k Note: As a general rule, you'll get a quicker response from the Slack channel.","title":"General Help"},{"location":"support/#logo-usage","text":"The http4k logo design and branding are copyright 2019 to the owners of http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant branding guidelines .","title":"Logo Usage"},{"location":"tutorials/add_a_little_chaos_to_your_life/","text":"Add a little chaos to your life Intro plan http4k testing iv: add a little chaos to your life chaos testing with the chaos engine chaos theory the chaos engine adding a a little chaos to your life the chaos proxy","title":"Tutorial: Add a little chaos to your life"},{"location":"tutorials/add_a_little_chaos_to_your_life/#add-a-little-chaos-to-your-life","text":"","title":"Add a little chaos to your life"},{"location":"tutorials/add_a_little_chaos_to_your_life/#intro","text":"","title":"Intro"},{"location":"tutorials/add_a_little_chaos_to_your_life/#plan","text":"http4k testing iv: add a little chaos to your life chaos testing with the chaos engine chaos theory the chaos engine adding a a little chaos to your life the chaos proxy","title":"plan"},{"location":"tutorials/documenting_apis_with_openapi/","text":"Tutorial: Documenting http4k APIs with OpenApi3 This post describes http4k support for fully describing and securing HTTP endpoints using version 3 of the OpenApi specification, providing typesafe JSON-schema documentation for messages and automatically validating incoming HTTP traffic. About OpenApi In microservice environments, some of the biggest challenges exist around the communications between processes that simply aren't present when you're doing monolith-based development. This manifests in many different operational ways such as monitoring, discovery and fault tolerance, but one of the key aspects is communicating the the HTTP contract provided by a particular service. There have been various efforts to standardise these aspects, and one of the most popular is OpenApi , which grew out of the original Swagger project. There are 3 key advantages to OpenApi: It provides a standardised way of documenting APIs, including routes, parameter optionality and format, security models and JSON Schema breakdown of JSON messages. It has standardised support from cloud providers such as Google Cloud Endpoints and AWS API Gateway . The OpenApi UI allows a very simple and developer-focused way of exploring and interacting with HTTP services from a browser environment. It is cross-platform and has good tooling support. Using OpenApi Generators , a specification document can be used to generate HTTP server stubs and working HTTP clients in a variety of languages, thus reducing integration efforts. Typesafe HTTP contracts with http4k-contract http4k has supported generating version 2 of OpenApi docs since all the way back in 2017 (v1.16) via it's http4k-contract module, and after a couple of releases ironing out the niggles (and some amazing help from the community), the team is now happy to announce OpenApi3 support with the release of http4k version 3.179.0. In line with the overall ethos of the project , http4k OpenApi support is done entirely through code and in a typesafe and refactorable way. This is somewhat of a departure from how most other libraries have implemented OpenApi (where often annotations and other compile-time magic are used) and means that in http4k the spec defined in code is the same one that is used to generate the API documentation and the same one used to validate incoming HTTP messages, meaning that it can never go stale. This focus on runtime code also allows for dynamic behaviours which would be very difficult to replicate at compile-time. Out of the box, http4k-contract the module now provides the following features when configured for OpenApi3: Automatic generation of route documentation in OpenApi v3 format, including the JSON Schema models for example incoming and outgoing messages (which arguably provide at least 50% of the value of using OpenApi). Complete auto-validation of the defined HTTP contract through the typesafe http4k Lens mechanism - violations are automatically detected and a BAD_REQUEST returned to the caller. This means that zero custom validation code is required to clutter up your routing layer and you can concentrate on working with meaningful domain types instead of primitives. Support/implementation of all defined OpenApi security models at both a global and per-route scope - BearerToken, ApiKey, OAuth and BasicAuth, although you can of course define and use custom implementations. Simple API for defining custom OpenApi extensions to extend the outputted specification document, for example using http4k in with AWS API Gateway or Google Cloud Endpoints So, how does we do all this using the http4k API? Let's find out with a worked example. 1. Your first endpoint After importing the http4k-core and http4k-contract dependencies into your project, we can write a new endpoint aka ContractRoute . The first thing to note is that we will be using a slightly different routing DSL the standard http4k one, one which provides a richer way to document endpoints - but don't worry - at it's core it utilises the same simple http4k building blocks of HttpHandler and Filter , as well as leveraging the http4k Lens API to automatically extract and convert incoming parameters into richer domain types. As ever, routes can (and should) be written and testing independently, which aids code decomposition and reuse. In this simple example, we're going to use a path with two dynamic parameters; name - a String, and the Integer age - which will be extracted and \"mapped\" into the constructor of a simple validated domain wrapper type. If the basic format of the path or the values for these path parameters cannot be extracted correctly, the endpoint fails to match and is skipped - this allows for several different variations of the same URI path signature to co-exist. Once the values have been extracted, they are passed as arguments to a function which will return a pre-configured HttpHandler for that call: package tutorials . documenting_apis_with_openapi import org.http4k.contract.ContractRoute import org.http4k.contract.div import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.lens.Path import org.http4k.lens.int data class Age ( val value : Int ) { init { require ( value >= 0 ) } } fun basicHandler ( name : String , age : Age ): HttpHandler = { req : Request -> val beverage = if ( age . value >= 18 ) \"beer\" else \"lemonade\" Response ( OK ) . body ( \"Hello $name, would you like some $beverage?\" ) } val basicRoute : ContractRoute = \"/greet\" / Path . of ( \"name\" ) / Path . int () . map (:: Age ) . of ( \"age\" ) bindContract GET to :: basicHandler And here's a unit test for that endpoint - the good news is that it's no more complex than a standard http4k unit test because ContractRoute is also an HttpHandler so can just be invoked as a function. Here, we're also leveraging the http4k-testing-hamkrest module to supply Hamkrest Matchers for validating the response message: package tutorials . documenting_apis_with_openapi import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.hamkrest.hasBody import org.junit.jupiter.api.Test class BasicGreetingRouteTest { @Test fun `greets an adult` () { assertThat ( basicRoute ( Request ( GET , \"/greet/Bob/21\" )), hasBody ( \"Hello Bob, would you like some beer?\" )) } } 2. Defining an HTTP contract Now that we've got our endpoint, we want to be able to actually serve it with the OpenApi documentation. For contract-based routing, we use the contract {} routing DSL which allows us to specify a richer set of details about the API definition, but exposes exactly the same API semantics as the standard routes() block - it is also an HttpHandler and can therefore be composed together to form standard route-matching trees. For rendering the API documentation, we configure an OpenApi object, supplying a standard http4k JSON adapter instance - the recommended one to use is Jackson from the http4k-format-jackson module, so we'll need to import that module into our project as well. Whilst all of the settings used in this DSL above are optional (and default to sensible values if not overridden), here we are updating the URL where the OpenApi spec is served and supplying an instance of Security that we will use to protect our routes (more about that later). package tutorials . documenting_apis_with_openapi import org.http4k.contract.contract import org.http4k.contract.openapi.ApiInfo import org.http4k.contract.openapi.v3.OpenApi3 import org.http4k.contract.security.BasicAuthSecurity import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.format.Jackson import org.http4k.server.Undertow import org.http4k.server.asServer fun main () { val http : HttpHandler = contract { renderer = OpenApi3 ( ApiInfo ( \"my secure api\" , \"v1.0\" , \"API description\" ), Jackson ) descriptionPath = \"/api/swagger.json\" security = BasicAuthSecurity ( \"realm\" , Credentials ( \"user\" , \"password\" )) routes += basicRoute } http . asServer ( Undertow ( 9000 )) . start () } Now we've got a complete contract, we can simply start the server and browse to http://localhost:9000/api/swagger.json to see the basic API spec in the OpenApi UI (or see the online version here ) to see how the endpoint contract looks and how the process of supplying credentials is done through the UI by clicking Authorize . This covers the very basics of generating API docs, but there is still a lot more http4k can do for us... 3. Auto-validating incoming HTTP messages For a better standard of API docs, we should add more details to the endpoint definition. The OpenAPI spec allows us to add this detail, but this normally comes with a maintenance cost - especially when the documentation is static or disparate from the location of the actual code serving requests, and we want to minimise the risk of stale documentation. In http4k, the extended contract metadata is kept close to the endpoint code and mostly type-checked by the compiler, so this threat is minimised as far as practical. Metadata for endpoints can be supplied via inserting a meta {} DSL block, which contains a mixture of 2 main types of property: Informational properties - such as summary , description and tags simply improve the experience of the user of the UI. Contractual properties define parameters using the http4k Lens API (in the same way as we used for the path) for the Query , Header or Body parts of the request. Once added to the contract, these items will also be auto-validated for form and presence before the contract HttpHandler is invoked, thus eliminating the need for any custom validation code to be written. We can then use the same lenses to confidently extract those values inside our HttpHandler code. Let's demonstrate by writing a slightly different version of the same endpoint, but move age to be a required query parameter, and also add the option to override the drink we offer: package tutorials . documenting_apis_with_openapi import org.http4k.contract.ContractRoute import org.http4k.contract.Tag import org.http4k.contract.div import org.http4k.contract.meta import org.http4k.core.ContentType.Companion.TEXT_PLAIN import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.lens.Path import org.http4k.lens.Query import org.http4k.lens.int data class Drink ( val name : String ) { init { require ( name . isNotEmpty ()) } } fun Greetings (): ContractRoute { val age = Query . int () . map (:: Age ) . required ( \"age\" , \"Your age\" ) val favouriteDrink = Query . map (:: Drink ) . optional ( \"drink\" , \"Your favourite beverage\" ) fun handler ( name : String ): HttpHandler = { req : Request -> val drinkToOffer : Drink ? = favouriteDrink ( req ) val beverage : String = drinkToOffer ? . name ? : if ( age ( req ) . value >= 18 ) \"beer\" else \"lemonade\" Response ( OK ) . body ( \"Hello $name, would you like some $beverage?\" ) } return \"/greet\" / Path . of ( \"name\" , \"Your name\" ) meta { summary = \"Send greetings\" description = \"Greets the stupid human by offering them a beverage suitable for their age\" tags += Tag ( \"query\" ) queries += favouriteDrink queries += age produces += TEXT_PLAIN returning ( OK to \"A successful offer of a drink to the lowly meatbag.\" ) } bindContract GET to :: handler } If we then add the Greetings endpoint to the contract and make a call omitting age ... http://localhost:9000/greet/Bob?drink=cola ... the contract validation will fail and a HTTP Bad Request (400) returned to the client with a JSON body describing the error: HTTP / 1 . 1 400 Bad Request content-type : application / json ; charset = utf-8 { \"message\": \"Missing/invalid parameters\", \"params\": [ { \"name\" : \"age\" , \"type\" : \"query\" , \"datatype\" : \"integer\" , \"required\" : true , \"reason\" : \"Missing\" } ] } We can see the updated OpenApi UI here . Note that because request parameters are validated before sending, we cannot replicate the above invalid request in the UI. 4. Modelling HTTP body messages The most exciting part http4k supporting OpenApi3 is the ability to represent HTTP messages in JSON Schema form in the documentation. This facility is what unlocks the true cross-language support and takes the usefulness of the OpenApi UI to another level, for both exploratory and support functions. Request and response messages can both be specified in the meta {} block using overloads of the receiving() and returning() functions. By using these functions, we can supply an example object to the DSL - this is what drives the generation of the JSON Schema and, more importantly, ensures that the documentation cannot go stale as it is driven by code. Lets add another route to the mix which returns a JSON body object modelled with a Kotlin Data class and once again using the http4k Lens API . Here, the lens not only provides the validating (de)serialisation mechanism, but also activates the Content-Type header injection and parsing behaviour - this will ensure that all incoming and outgoing messages have the correct headers. For JSON bodies, the lens is created with Body.auto<>().toLens() ( auto() is an extension function imported from Jackson ) which provides the typed injection and extraction functions. Notice here that for injection we are using the more fluent API with() and of() extension functions, as opposed to the standard lens injection function (X, HttpMessage) -> HttpMessage : package tutorials . documenting_apis_with_openapi import org.http4k.contract.ContractRoute import org.http4k.contract.Tag import org.http4k.contract.div import org.http4k.contract.meta import org.http4k.core.Body import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Response import org.http4k.core.Status.Companion.NOT_FOUND import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.format.Jackson.auto import org.http4k.lens.Path data class Person ( val name : String , val age : Age , val children : List < Person > = emptyList ()) fun Family (): ContractRoute { val familyData = Person ( \"Bob\" , Age ( 85 ), listOf ( Person ( \"Anita\" , Age ( 55 )), Person ( \"Donald\" , Age ( 52 ), listOf ( Person ( \"Don Jr\" , Age ( 21 )))) )) val responseLens = Body . auto < Person > ( \"The matched family tree\" ) . toLens () fun handler ( queryName : String ): HttpHandler = { fun Person . search (): Person ? = when ( name ) { queryName -> this else -> children . firstOrNull { it . search () != null } } familyData . search () ? . let { Response ( OK ) . with ( responseLens of it ) } ? : Response ( NOT_FOUND ) } return \"/search\" / Path . of ( \"name\" , \"The name to search for in the tree\" ) meta { summary = \"Search family tree\" description = \"Given a name, returns a sub family tree starting with that person\" tags += Tag ( \"query\" ) returning ( OK , responseLens to Person ( \"Donald\" , Age ( 52 ), listOf ( Person ( \"Don Jr\" , Age ( 21 )))), \"Cut down family tree\" ) returning ( NOT_FOUND to \"That person does not exist the family\" ) } bindContract GET to :: handler } Taking a final look at the OpenApi UI here shows that not just has the UI been updated with the new route, but that example entries for the expected response are now displayed, as well as JSON Schema entries for the Person and Age classes in the Schemas section at the bottom. Wrapping up... Once we have the final specification document available, users of our API can use the various OpenApi Generators to generate HTTP clients in various languages for interacting with it, or to generate fake services that provide our API in their own environments (and thus enabling more simple end-to-end testing). The \"Fake HTTP services\" technique also enables the creation of Consumer-Driven-Contract style tests, and opens up possibilities for all kinds of interesting Chaos/failure-mode testing (you can even use the http4k-testing-chaos module to help with this \ud83d\ude09). The full source for this tutorial can be found here , or for a sense of how this all looks in when mixed into a complete http4k project, check out the http4k-by-example repo, which contains an entire TDD'd project showcasing a multitude of http4k features and testing styles.","title":"Documenting http4k apps with OpenApi3"},{"location":"tutorials/documenting_apis_with_openapi/#tutorial-documenting-http4k-apis-with-openapi3","text":"This post describes http4k support for fully describing and securing HTTP endpoints using version 3 of the OpenApi specification, providing typesafe JSON-schema documentation for messages and automatically validating incoming HTTP traffic.","title":"Tutorial: Documenting http4k APIs with OpenApi3"},{"location":"tutorials/documenting_apis_with_openapi/#about-openapi","text":"In microservice environments, some of the biggest challenges exist around the communications between processes that simply aren't present when you're doing monolith-based development. This manifests in many different operational ways such as monitoring, discovery and fault tolerance, but one of the key aspects is communicating the the HTTP contract provided by a particular service. There have been various efforts to standardise these aspects, and one of the most popular is OpenApi , which grew out of the original Swagger project. There are 3 key advantages to OpenApi: It provides a standardised way of documenting APIs, including routes, parameter optionality and format, security models and JSON Schema breakdown of JSON messages. It has standardised support from cloud providers such as Google Cloud Endpoints and AWS API Gateway . The OpenApi UI allows a very simple and developer-focused way of exploring and interacting with HTTP services from a browser environment. It is cross-platform and has good tooling support. Using OpenApi Generators , a specification document can be used to generate HTTP server stubs and working HTTP clients in a variety of languages, thus reducing integration efforts.","title":"About OpenApi"},{"location":"tutorials/documenting_apis_with_openapi/#typesafe-http-contracts-with-http4k-contract","text":"http4k has supported generating version 2 of OpenApi docs since all the way back in 2017 (v1.16) via it's http4k-contract module, and after a couple of releases ironing out the niggles (and some amazing help from the community), the team is now happy to announce OpenApi3 support with the release of http4k version 3.179.0. In line with the overall ethos of the project , http4k OpenApi support is done entirely through code and in a typesafe and refactorable way. This is somewhat of a departure from how most other libraries have implemented OpenApi (where often annotations and other compile-time magic are used) and means that in http4k the spec defined in code is the same one that is used to generate the API documentation and the same one used to validate incoming HTTP messages, meaning that it can never go stale. This focus on runtime code also allows for dynamic behaviours which would be very difficult to replicate at compile-time. Out of the box, http4k-contract the module now provides the following features when configured for OpenApi3: Automatic generation of route documentation in OpenApi v3 format, including the JSON Schema models for example incoming and outgoing messages (which arguably provide at least 50% of the value of using OpenApi). Complete auto-validation of the defined HTTP contract through the typesafe http4k Lens mechanism - violations are automatically detected and a BAD_REQUEST returned to the caller. This means that zero custom validation code is required to clutter up your routing layer and you can concentrate on working with meaningful domain types instead of primitives. Support/implementation of all defined OpenApi security models at both a global and per-route scope - BearerToken, ApiKey, OAuth and BasicAuth, although you can of course define and use custom implementations. Simple API for defining custom OpenApi extensions to extend the outputted specification document, for example using http4k in with AWS API Gateway or Google Cloud Endpoints So, how does we do all this using the http4k API? Let's find out with a worked example.","title":"Typesafe HTTP contracts with http4k-contract"},{"location":"tutorials/documenting_apis_with_openapi/#1-your-first-endpoint","text":"After importing the http4k-core and http4k-contract dependencies into your project, we can write a new endpoint aka ContractRoute . The first thing to note is that we will be using a slightly different routing DSL the standard http4k one, one which provides a richer way to document endpoints - but don't worry - at it's core it utilises the same simple http4k building blocks of HttpHandler and Filter , as well as leveraging the http4k Lens API to automatically extract and convert incoming parameters into richer domain types. As ever, routes can (and should) be written and testing independently, which aids code decomposition and reuse. In this simple example, we're going to use a path with two dynamic parameters; name - a String, and the Integer age - which will be extracted and \"mapped\" into the constructor of a simple validated domain wrapper type. If the basic format of the path or the values for these path parameters cannot be extracted correctly, the endpoint fails to match and is skipped - this allows for several different variations of the same URI path signature to co-exist. Once the values have been extracted, they are passed as arguments to a function which will return a pre-configured HttpHandler for that call: package tutorials . documenting_apis_with_openapi import org.http4k.contract.ContractRoute import org.http4k.contract.div import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.lens.Path import org.http4k.lens.int data class Age ( val value : Int ) { init { require ( value >= 0 ) } } fun basicHandler ( name : String , age : Age ): HttpHandler = { req : Request -> val beverage = if ( age . value >= 18 ) \"beer\" else \"lemonade\" Response ( OK ) . body ( \"Hello $name, would you like some $beverage?\" ) } val basicRoute : ContractRoute = \"/greet\" / Path . of ( \"name\" ) / Path . int () . map (:: Age ) . of ( \"age\" ) bindContract GET to :: basicHandler And here's a unit test for that endpoint - the good news is that it's no more complex than a standard http4k unit test because ContractRoute is also an HttpHandler so can just be invoked as a function. Here, we're also leveraging the http4k-testing-hamkrest module to supply Hamkrest Matchers for validating the response message: package tutorials . documenting_apis_with_openapi import com.natpryce.hamkrest.assertion.assertThat import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.hamkrest.hasBody import org.junit.jupiter.api.Test class BasicGreetingRouteTest { @Test fun `greets an adult` () { assertThat ( basicRoute ( Request ( GET , \"/greet/Bob/21\" )), hasBody ( \"Hello Bob, would you like some beer?\" )) } }","title":"1. Your first endpoint"},{"location":"tutorials/documenting_apis_with_openapi/#2-defining-an-http-contract","text":"Now that we've got our endpoint, we want to be able to actually serve it with the OpenApi documentation. For contract-based routing, we use the contract {} routing DSL which allows us to specify a richer set of details about the API definition, but exposes exactly the same API semantics as the standard routes() block - it is also an HttpHandler and can therefore be composed together to form standard route-matching trees. For rendering the API documentation, we configure an OpenApi object, supplying a standard http4k JSON adapter instance - the recommended one to use is Jackson from the http4k-format-jackson module, so we'll need to import that module into our project as well. Whilst all of the settings used in this DSL above are optional (and default to sensible values if not overridden), here we are updating the URL where the OpenApi spec is served and supplying an instance of Security that we will use to protect our routes (more about that later). package tutorials . documenting_apis_with_openapi import org.http4k.contract.contract import org.http4k.contract.openapi.ApiInfo import org.http4k.contract.openapi.v3.OpenApi3 import org.http4k.contract.security.BasicAuthSecurity import org.http4k.core.Credentials import org.http4k.core.HttpHandler import org.http4k.format.Jackson import org.http4k.server.Undertow import org.http4k.server.asServer fun main () { val http : HttpHandler = contract { renderer = OpenApi3 ( ApiInfo ( \"my secure api\" , \"v1.0\" , \"API description\" ), Jackson ) descriptionPath = \"/api/swagger.json\" security = BasicAuthSecurity ( \"realm\" , Credentials ( \"user\" , \"password\" )) routes += basicRoute } http . asServer ( Undertow ( 9000 )) . start () } Now we've got a complete contract, we can simply start the server and browse to http://localhost:9000/api/swagger.json to see the basic API spec in the OpenApi UI (or see the online version here ) to see how the endpoint contract looks and how the process of supplying credentials is done through the UI by clicking Authorize . This covers the very basics of generating API docs, but there is still a lot more http4k can do for us...","title":"2. Defining an HTTP contract"},{"location":"tutorials/documenting_apis_with_openapi/#3-auto-validating-incoming-http-messages","text":"For a better standard of API docs, we should add more details to the endpoint definition. The OpenAPI spec allows us to add this detail, but this normally comes with a maintenance cost - especially when the documentation is static or disparate from the location of the actual code serving requests, and we want to minimise the risk of stale documentation. In http4k, the extended contract metadata is kept close to the endpoint code and mostly type-checked by the compiler, so this threat is minimised as far as practical. Metadata for endpoints can be supplied via inserting a meta {} DSL block, which contains a mixture of 2 main types of property: Informational properties - such as summary , description and tags simply improve the experience of the user of the UI. Contractual properties define parameters using the http4k Lens API (in the same way as we used for the path) for the Query , Header or Body parts of the request. Once added to the contract, these items will also be auto-validated for form and presence before the contract HttpHandler is invoked, thus eliminating the need for any custom validation code to be written. We can then use the same lenses to confidently extract those values inside our HttpHandler code. Let's demonstrate by writing a slightly different version of the same endpoint, but move age to be a required query parameter, and also add the option to override the drink we offer: package tutorials . documenting_apis_with_openapi import org.http4k.contract.ContractRoute import org.http4k.contract.Tag import org.http4k.contract.div import org.http4k.contract.meta import org.http4k.core.ContentType.Companion.TEXT_PLAIN import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.lens.Path import org.http4k.lens.Query import org.http4k.lens.int data class Drink ( val name : String ) { init { require ( name . isNotEmpty ()) } } fun Greetings (): ContractRoute { val age = Query . int () . map (:: Age ) . required ( \"age\" , \"Your age\" ) val favouriteDrink = Query . map (:: Drink ) . optional ( \"drink\" , \"Your favourite beverage\" ) fun handler ( name : String ): HttpHandler = { req : Request -> val drinkToOffer : Drink ? = favouriteDrink ( req ) val beverage : String = drinkToOffer ? . name ? : if ( age ( req ) . value >= 18 ) \"beer\" else \"lemonade\" Response ( OK ) . body ( \"Hello $name, would you like some $beverage?\" ) } return \"/greet\" / Path . of ( \"name\" , \"Your name\" ) meta { summary = \"Send greetings\" description = \"Greets the stupid human by offering them a beverage suitable for their age\" tags += Tag ( \"query\" ) queries += favouriteDrink queries += age produces += TEXT_PLAIN returning ( OK to \"A successful offer of a drink to the lowly meatbag.\" ) } bindContract GET to :: handler } If we then add the Greetings endpoint to the contract and make a call omitting age ... http://localhost:9000/greet/Bob?drink=cola ... the contract validation will fail and a HTTP Bad Request (400) returned to the client with a JSON body describing the error: HTTP / 1 . 1 400 Bad Request content-type : application / json ; charset = utf-8 { \"message\": \"Missing/invalid parameters\", \"params\": [ { \"name\" : \"age\" , \"type\" : \"query\" , \"datatype\" : \"integer\" , \"required\" : true , \"reason\" : \"Missing\" } ] } We can see the updated OpenApi UI here . Note that because request parameters are validated before sending, we cannot replicate the above invalid request in the UI.","title":"3. Auto-validating incoming HTTP messages"},{"location":"tutorials/documenting_apis_with_openapi/#4-modelling-http-body-messages","text":"The most exciting part http4k supporting OpenApi3 is the ability to represent HTTP messages in JSON Schema form in the documentation. This facility is what unlocks the true cross-language support and takes the usefulness of the OpenApi UI to another level, for both exploratory and support functions. Request and response messages can both be specified in the meta {} block using overloads of the receiving() and returning() functions. By using these functions, we can supply an example object to the DSL - this is what drives the generation of the JSON Schema and, more importantly, ensures that the documentation cannot go stale as it is driven by code. Lets add another route to the mix which returns a JSON body object modelled with a Kotlin Data class and once again using the http4k Lens API . Here, the lens not only provides the validating (de)serialisation mechanism, but also activates the Content-Type header injection and parsing behaviour - this will ensure that all incoming and outgoing messages have the correct headers. For JSON bodies, the lens is created with Body.auto<>().toLens() ( auto() is an extension function imported from Jackson ) which provides the typed injection and extraction functions. Notice here that for injection we are using the more fluent API with() and of() extension functions, as opposed to the standard lens injection function (X, HttpMessage) -> HttpMessage : package tutorials . documenting_apis_with_openapi import org.http4k.contract.ContractRoute import org.http4k.contract.Tag import org.http4k.contract.div import org.http4k.contract.meta import org.http4k.core.Body import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Response import org.http4k.core.Status.Companion.NOT_FOUND import org.http4k.core.Status.Companion.OK import org.http4k.core.with import org.http4k.format.Jackson.auto import org.http4k.lens.Path data class Person ( val name : String , val age : Age , val children : List < Person > = emptyList ()) fun Family (): ContractRoute { val familyData = Person ( \"Bob\" , Age ( 85 ), listOf ( Person ( \"Anita\" , Age ( 55 )), Person ( \"Donald\" , Age ( 52 ), listOf ( Person ( \"Don Jr\" , Age ( 21 )))) )) val responseLens = Body . auto < Person > ( \"The matched family tree\" ) . toLens () fun handler ( queryName : String ): HttpHandler = { fun Person . search (): Person ? = when ( name ) { queryName -> this else -> children . firstOrNull { it . search () != null } } familyData . search () ? . let { Response ( OK ) . with ( responseLens of it ) } ? : Response ( NOT_FOUND ) } return \"/search\" / Path . of ( \"name\" , \"The name to search for in the tree\" ) meta { summary = \"Search family tree\" description = \"Given a name, returns a sub family tree starting with that person\" tags += Tag ( \"query\" ) returning ( OK , responseLens to Person ( \"Donald\" , Age ( 52 ), listOf ( Person ( \"Don Jr\" , Age ( 21 )))), \"Cut down family tree\" ) returning ( NOT_FOUND to \"That person does not exist the family\" ) } bindContract GET to :: handler } Taking a final look at the OpenApi UI here shows that not just has the UI been updated with the new route, but that example entries for the expected response are now displayed, as well as JSON Schema entries for the Person and Age classes in the Schemas section at the bottom.","title":"4. Modelling HTTP body messages"},{"location":"tutorials/documenting_apis_with_openapi/#wrapping-up","text":"Once we have the final specification document available, users of our API can use the various OpenApi Generators to generate HTTP clients in various languages for interacting with it, or to generate fake services that provide our API in their own environments (and thus enabling more simple end-to-end testing). The \"Fake HTTP services\" technique also enables the creation of Consumer-Driven-Contract style tests, and opens up possibilities for all kinds of interesting Chaos/failure-mode testing (you can even use the http4k-testing-chaos module to help with this \ud83d\ude09). The full source for this tutorial can be found here , or for a sense of how this all looks in when mixed into a complete http4k project, check out the http4k-by-example repo, which contains an entire TDD'd project showcasing a multitude of http4k features and testing styles.","title":"Wrapping up..."},{"location":"tutorials/tdding_http4k/","text":"TDDing http4k Application Design What follows is a guide to how we build http4k applications test first to provide excellent test coverage driven by decoupled tests. For this example, we will use an example of a Maths app with the following requirements: The app must add 2 numbers together via an HTTP call The app must multiply 2 numbers together via an HTTP call Answers generated by the service will be logged (via HTTP POST) to another server - the Recorder. Apps can generally be split into 3 tiers: Endpoint: HttpHandlers are constructed individually, by providing a builder function which takes the business-level dependencies. Application: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier. Server: Builder function which takes the configuration for environmental concerns such as ports and downstream urls. The tutorial is split into 4 sections: Part 1: Building a walking skeleton Part 2: Adding an endpoint Part 3: Adding another endpoint Part 4: Adding an external dependency","title":"TDDing http4k"},{"location":"tutorials/tdding_http4k/#tdding-http4k","text":"","title":"TDDing http4k"},{"location":"tutorials/tdding_http4k/#application-design","text":"What follows is a guide to how we build http4k applications test first to provide excellent test coverage driven by decoupled tests. For this example, we will use an example of a Maths app with the following requirements: The app must add 2 numbers together via an HTTP call The app must multiply 2 numbers together via an HTTP call Answers generated by the service will be logged (via HTTP POST) to another server - the Recorder. Apps can generally be split into 3 tiers: Endpoint: HttpHandlers are constructed individually, by providing a builder function which takes the business-level dependencies. Application: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier. Server: Builder function which takes the configuration for environmental concerns such as ports and downstream urls. The tutorial is split into 4 sections: Part 1: Building a walking skeleton Part 2: Adding an endpoint Part 3: Adding another endpoint Part 4: Adding an external dependency","title":"Application Design"},{"location":"tutorials/tdding_http4k/_1/","text":"Until we have an application that can be deployed, we cannot create any business value. The Walking Skeleton model dictates that putting the most trivial endpoint into a production environment will prove our deployment pipeline is sound, and helps to set the direction for the testing strategy that we will use going forward. We start with in ICT (In-Container-Test), which have the job of testing server-level concerns such as monitoring, documentation, and checking in a high-level way that the business endpoints are wired correctly. Requirements: The service can be pinged over HTTP to prove that is still alive. Tests: package tutorials . tdding_http4k . _1 import com.natpryce.hamkrest.assertion.assertThat import org.http4k.client.OkHttp import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test class EndToEndTest { private val client = OkHttp () private val server = MyMathServer ( 0 ) @BeforeEach fun setup () { server . start () } @AfterEach fun teardown () { server . stop () } @Test fun `responds to ping` () { assertThat ( client ( Request ( GET , \"http://localhost:${server.port()}/ping\" )), hasStatus ( OK )) } } Production: package tutorials . tdding_http4k . _1 import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer fun MyMathServer ( port : Int ): Http4kServer = { _ : Request -> Response ( OK ) } . asServer ( Jetty ( port ))","title":"TDDing http4k Part 1: Building a walking skeleton"},{"location":"tutorials/tdding_http4k/_1/#requirements","text":"The service can be pinged over HTTP to prove that is still alive.","title":"Requirements:"},{"location":"tutorials/tdding_http4k/_1/#tests","text":"package tutorials . tdding_http4k . _1 import com.natpryce.hamkrest.assertion.assertThat import org.http4k.client.OkHttp import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test class EndToEndTest { private val client = OkHttp () private val server = MyMathServer ( 0 ) @BeforeEach fun setup () { server . start () } @AfterEach fun teardown () { server . stop () } @Test fun `responds to ping` () { assertThat ( client ( Request ( GET , \"http://localhost:${server.port()}/ping\" )), hasStatus ( OK )) } }","title":"Tests:"},{"location":"tutorials/tdding_http4k/_1/#production","text":"package tutorials . tdding_http4k . _1 import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer fun MyMathServer ( port : Int ): Http4kServer = { _ : Request -> Response ( OK ) } . asServer ( Jetty ( port ))","title":"Production:"},{"location":"tutorials/tdding_http4k/_2/","text":"Starting with another EndToEnd test, we can then drill-down into the functional behaviour of the system by introducing OCT (Out of Container) tests and converting the e2e test to just test endpoint wiring (so far). The common assertions have also been converted to reusable extension methods on Response. Requirements: Implement an \"add\" service, which will sum a number of integer values. Tests: package tutorials . tdding_http4k . _2 import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.client.OkHttp import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.BAD_REQUEST import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test import tutorials.tdding_http4k._2.Matchers.answerShouldBe object Matchers { fun Response . answerShouldBe ( expected : Int ) { assertThat ( this , hasStatus ( OK ) . and ( hasBody ( expected . toString ()))) } } class EndToEndTest { private val client = OkHttp () private val server = MyMathServer ( 0 ) @BeforeEach fun setup () { server . start () } @AfterEach fun teardown () { server . stop () } @Test fun `all endpoints are mounted correctly` () { assertThat ( client ( Request ( GET , \"http://localhost:${server.port()}/ping\" )), hasStatus ( OK )) client ( Request ( GET , \"http://localhost:${server.port()}/add?value=1&value=2\" )) . answerShouldBe ( 3 ) } } class AddFunctionalTest { private val client = MyMathsApp () @Test fun `adds values together` () { client ( Request ( GET , \"/add?value=1&value=2\" )) . answerShouldBe ( 3 ) } @Test fun `answer is zero when no values` () { client ( Request ( GET , \"/add\" )) . answerShouldBe ( 0 ) } @Test fun `bad request when some values are not numbers` () { assertThat ( client ( Request ( GET , \"/add?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) } } Production: package tutorials . tdding_http4k . _2 import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ServerFilters.CatchLensFailure import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer fun MyMathServer ( port : Int ): Http4kServer = MyMathsApp () . asServer ( Jetty ( port )) fun MyMathsApp (): HttpHandler = CatchLensFailure . then ( routes ( \"/ping\" bind GET to { _ : Request -> Response ( OK ) }, \"/add\" bind GET to { request : Request -> val valuesToAdd = Query . int () . multi . defaulted ( \"value\" , listOf ())( request ) Response ( OK ) . body ( valuesToAdd . sum () . toString ()) } ) )","title":"TDDing http4k Part 2: Adding an endpoint"},{"location":"tutorials/tdding_http4k/_2/#requirements","text":"Implement an \"add\" service, which will sum a number of integer values.","title":"Requirements:"},{"location":"tutorials/tdding_http4k/_2/#tests","text":"package tutorials . tdding_http4k . _2 import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.client.OkHttp import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.BAD_REQUEST import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test import tutorials.tdding_http4k._2.Matchers.answerShouldBe object Matchers { fun Response . answerShouldBe ( expected : Int ) { assertThat ( this , hasStatus ( OK ) . and ( hasBody ( expected . toString ()))) } } class EndToEndTest { private val client = OkHttp () private val server = MyMathServer ( 0 ) @BeforeEach fun setup () { server . start () } @AfterEach fun teardown () { server . stop () } @Test fun `all endpoints are mounted correctly` () { assertThat ( client ( Request ( GET , \"http://localhost:${server.port()}/ping\" )), hasStatus ( OK )) client ( Request ( GET , \"http://localhost:${server.port()}/add?value=1&value=2\" )) . answerShouldBe ( 3 ) } } class AddFunctionalTest { private val client = MyMathsApp () @Test fun `adds values together` () { client ( Request ( GET , \"/add?value=1&value=2\" )) . answerShouldBe ( 3 ) } @Test fun `answer is zero when no values` () { client ( Request ( GET , \"/add\" )) . answerShouldBe ( 0 ) } @Test fun `bad request when some values are not numbers` () { assertThat ( client ( Request ( GET , \"/add?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) } }","title":"Tests:"},{"location":"tutorials/tdding_http4k/_2/#production","text":"package tutorials . tdding_http4k . _2 import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ServerFilters.CatchLensFailure import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer fun MyMathServer ( port : Int ): Http4kServer = MyMathsApp () . asServer ( Jetty ( port )) fun MyMathsApp (): HttpHandler = CatchLensFailure . then ( routes ( \"/ping\" bind GET to { _ : Request -> Response ( OK ) }, \"/add\" bind GET to { request : Request -> val valuesToAdd = Query . int () . multi . defaulted ( \"value\" , listOf ())( request ) Response ( OK ) . body ( valuesToAdd . sum () . toString ()) } ) )","title":"Production:"},{"location":"tutorials/tdding_http4k/_3/","text":"Requirements: Implement a \"multiply\" service, which will find the product of a number of integer values. Tests: package tutorials . tdding_http4k . _3 import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.client.OkHttp import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.BAD_REQUEST import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test import tutorials.tdding_http4k._3.Matchers.answerShouldBe object Matchers { fun Response . answerShouldBe ( expected : Int ) { assertThat ( this , hasStatus ( OK ) . and ( hasBody ( expected . toString ()))) } } class EndToEndTest { private val client = OkHttp () private val server = MyMathServer ( 0 ) @BeforeEach fun setup () { server . start () } @AfterEach fun teardown () { server . stop () } @Test fun `all endpoints are mounted correctly` () { assertThat ( client ( Request ( GET , \"http://localhost:${server.port()}/ping\" )), hasStatus ( OK )) client ( Request ( GET , \"http://localhost:${server.port()}/add?value=1&value=2\" )) . answerShouldBe ( 3 ) client ( Request ( GET , \"http://localhost:${server.port()}/multiply?value=2&value=4\" )) . answerShouldBe ( 8 ) } } class AddFunctionalTest { private val client = MyMathsApp () @Test fun `adds values together` () { client ( Request ( GET , \"/add?value=1&value=2\" )) . answerShouldBe ( 3 ) } @Test fun `answer is zero when no values` () { client ( Request ( GET , \"/add\" )) . answerShouldBe ( 0 ) } @Test fun `bad request when some values are not numbers` () { assertThat ( client ( Request ( GET , \"/add?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) } } class MultiplyFunctionalTest { private val client = MyMathsApp () @Test fun `products values together` () { client ( Request ( GET , \"/multiply?value=2&value=4\" )) . answerShouldBe ( 8 ) } @Test fun `answer is zero when no values` () { client ( Request ( GET , \"/multiply\" )) . answerShouldBe ( 0 ) } @Test fun `bad request when some values are not numbers` () { assertThat ( client ( Request ( GET , \"/multiply?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) } } Production: package tutorials . tdding_http4k . _3 import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ServerFilters.CatchLensFailure import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer fun MyMathServer ( port : Int ): Http4kServer = MyMathsApp () . asServer ( Jetty ( port )) fun MyMathsApp (): HttpHandler = CatchLensFailure . then ( routes ( \"/ping\" bind GET to { _ : Request -> Response ( OK ) }, \"/add\" bind GET to calculate { it . sum () }, \"/multiply\" bind GET to calculate { it . fold ( 1 ) { memo , next -> memo * next } } ) ) private fun calculate ( fn : ( List < Int > ) -> Int ): ( Request ) -> Response { val values = Query . int () . multi . defaulted ( \"value\" , listOf ()) return { request : Request -> val valuesToCalc = values ( request ) val answer = if ( valuesToCalc . isEmpty ()) 0 else fn ( valuesToCalc ) Response ( OK ) . body ( answer . toString ()) } }","title":"TDDing http4k Part 3: Adding another endpoint"},{"location":"tutorials/tdding_http4k/_3/#requirements","text":"Implement a \"multiply\" service, which will find the product of a number of integer values.","title":"Requirements:"},{"location":"tutorials/tdding_http4k/_3/#tests","text":"package tutorials . tdding_http4k . _3 import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import org.http4k.client.OkHttp import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.BAD_REQUEST import org.http4k.core.Status.Companion.OK import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Test import tutorials.tdding_http4k._3.Matchers.answerShouldBe object Matchers { fun Response . answerShouldBe ( expected : Int ) { assertThat ( this , hasStatus ( OK ) . and ( hasBody ( expected . toString ()))) } } class EndToEndTest { private val client = OkHttp () private val server = MyMathServer ( 0 ) @BeforeEach fun setup () { server . start () } @AfterEach fun teardown () { server . stop () } @Test fun `all endpoints are mounted correctly` () { assertThat ( client ( Request ( GET , \"http://localhost:${server.port()}/ping\" )), hasStatus ( OK )) client ( Request ( GET , \"http://localhost:${server.port()}/add?value=1&value=2\" )) . answerShouldBe ( 3 ) client ( Request ( GET , \"http://localhost:${server.port()}/multiply?value=2&value=4\" )) . answerShouldBe ( 8 ) } } class AddFunctionalTest { private val client = MyMathsApp () @Test fun `adds values together` () { client ( Request ( GET , \"/add?value=1&value=2\" )) . answerShouldBe ( 3 ) } @Test fun `answer is zero when no values` () { client ( Request ( GET , \"/add\" )) . answerShouldBe ( 0 ) } @Test fun `bad request when some values are not numbers` () { assertThat ( client ( Request ( GET , \"/add?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) } } class MultiplyFunctionalTest { private val client = MyMathsApp () @Test fun `products values together` () { client ( Request ( GET , \"/multiply?value=2&value=4\" )) . answerShouldBe ( 8 ) } @Test fun `answer is zero when no values` () { client ( Request ( GET , \"/multiply\" )) . answerShouldBe ( 0 ) } @Test fun `bad request when some values are not numbers` () { assertThat ( client ( Request ( GET , \"/multiply?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) } }","title":"Tests:"},{"location":"tutorials/tdding_http4k/_3/#production","text":"package tutorials . tdding_http4k . _3 import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.OK import org.http4k.core.then import org.http4k.filter.ServerFilters.CatchLensFailure import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer fun MyMathServer ( port : Int ): Http4kServer = MyMathsApp () . asServer ( Jetty ( port )) fun MyMathsApp (): HttpHandler = CatchLensFailure . then ( routes ( \"/ping\" bind GET to { _ : Request -> Response ( OK ) }, \"/add\" bind GET to calculate { it . sum () }, \"/multiply\" bind GET to calculate { it . fold ( 1 ) { memo , next -> memo * next } } ) ) private fun calculate ( fn : ( List < Int > ) -> Int ): ( Request ) -> Response { val values = Query . int () . multi . defaulted ( \"value\" , listOf ()) return { request : Request -> val valuesToCalc = values ( request ) val answer = if ( valuesToCalc . isEmpty ()) 0 else fn ( valuesToCalc ) Response ( OK ) . body ( answer . toString ()) } }","title":"Production:"},{"location":"tutorials/tdding_http4k/_4/","text":"At this point, the separation of the layers starts to become clear: - The server layer is responsible for taking external configuration and instantiating the app layer. - The application layer API is only in terms of HTTP transports - it constructs business level abstractions which are passed down into to the individual endpoints The process here is to create fake versions of the dependency which can be tested against through the business interface. This requires another style of testing, CDCs (Consumer Driven Contracts), to be created. These contract tests ensure that our interactions with the external service are valid. Requirements: Results from calculations should be POSTed via HTTP to another \"answer recording\" service. Implementation Notes: The following process is followed to us to the final state, whilst always allowing us to keep the build green: Determine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer} Create RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder Create FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement Include the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything) Pass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler Factor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done Introduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment Alter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp In MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record() Tests: package tutorials . tdding_http4k . _4 import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.OkHttp import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.ACCEPTED import org.http4k.core.Status.Companion.BAD_REQUEST import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters.SetHostFrom import org.http4k.filter.ServerFilters.CatchLensFailure import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.http4k.lens.Path import org.http4k.lens.int import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Jetty import org.http4k.server.asServer import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Disabled import org.junit.jupiter.api.Test import tutorials.tdding_http4k._4.Matchers.answerShouldBe import java.util.Random object Matchers { fun Response . answerShouldBe ( expected : Int ) { assertThat ( this , hasStatus ( OK ) . and ( hasBody ( expected . toString ()))) } } abstract class RecorderCdc { abstract val client : HttpHandler @Test fun `records answer` () { Recorder ( client ) . record ( 123 ) checkAnswerRecorded () } open fun checkAnswerRecorded () {} } class FakeRecorderHttp : HttpHandler { val calls = mutableListOf < Int > () private val answer = Path . int () . of ( \"answer\" ) private val app = CatchLensFailure . then ( routes ( \"/{answer}\" bind POST to { request -> calls . add ( answer ( request )); Response ( ACCEPTED ) } ) ) override fun invoke ( request : Request ): Response = app ( request ) } class FakeRecorderTest : RecorderCdc () { override val client = FakeRecorderHttp () override fun checkAnswerRecorded () { assertThat ( client . calls , equalTo ( listOf ( 123 ))) } } @Disabled // this obviously doesn 't exist, so we ignore it here class RealRecorderTest : RecorderCdc () { override val client = SetHostFrom ( Uri . of ( \"http://realrecorder\" )) . then ( OkHttp ()) } class EndToEndTest { private val port = Random () . nextInt ( 1000 ) + 8000 private val recorderPort = port + 1 private val client = OkHttp () private val recorder = FakeRecorderHttp () private val server = MyMathServer ( 0 , Uri . of ( \"http://localhost:$recorderPort\" )) private val recorderServer = recorder . asServer ( Jetty ( recorderPort )) @BeforeEach fun setup () { recorderServer . start () server . start () } @AfterEach fun teardown () { server . stop () recorderServer . stop () } @Test fun `all endpoints are mounted correctly` () { assertThat ( client ( Request ( GET , \"http://localhost:${server.port()}/ping\" )), hasStatus ( OK )) client ( Request ( GET , \"http://localhost:${server.port()}/add?value=1&value=2\" )) . answerShouldBe ( 3 ) client ( Request ( GET , \"http://localhost:${server.port()}/multiply?value=2&value=4\" )) . answerShouldBe ( 8 ) } } class AppEnvironment { val recorder = FakeRecorderHttp () val client = MyMathsApp ( recorder ) } class AddFunctionalTest { private val env = AppEnvironment () @Test fun `adds values together` () { env . client ( Request ( GET , \"/add?value=1&value=2\" )) . answerShouldBe ( 3 ) assertThat ( env . recorder . calls , equalTo ( listOf ( 3 ))) } @Test fun `answer is zero when no values` () { env . client ( Request ( GET , \"/add\" )) . answerShouldBe ( 0 ) assertThat ( env . recorder . calls , equalTo ( listOf ( 0 ))) } @Test fun `bad request when some values are not numbers` () { assertThat ( env . client ( Request ( GET , \"/add?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) assertThat ( env . recorder . calls . isEmpty (), equalTo ( true )) } } class MultiplyFunctionalTest { private val env = AppEnvironment () @Test fun `products values together` () { env . client ( Request ( GET , \"/multiply?value=2&value=4\" )) . answerShouldBe ( 8 ) assertThat ( env . recorder . calls , equalTo ( listOf ( 8 ))) } @Test fun `answer is zero when no values` () { env . client ( Request ( GET , \"/multiply\" )) . answerShouldBe ( 0 ) assertThat ( env . recorder . calls , equalTo ( listOf ( 0 ))) } @Test fun `bad request when some values are not numbers` () { assertThat ( env . client ( Request ( GET , \"/multiply?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) assertThat ( env . recorder . calls . isEmpty (), equalTo ( true )) } } Production: package tutorials . tdding_http4k . _4 import org.http4k.client.OkHttp import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.ACCEPTED import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters.SetHostFrom import org.http4k.filter.ServerFilters.CatchLensFailure import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer class Recorder ( private val client : HttpHandler ) { fun record ( value : Int ) { val response = client ( Request ( POST , \"/$value\" )) if ( response . status != ACCEPTED ) throw RuntimeException ( \"recorder returned ${response.status}\" ) } } fun MyMathsApp ( recorderHttp : HttpHandler ): HttpHandler { val recorder = Recorder ( recorderHttp ) return CatchLensFailure . then ( routes ( \"/ping\" bind GET to { _ : Request -> Response ( OK ) }, \"/add\" bind GET to calculate ( recorder ) { it . sum () }, \"/multiply\" bind GET to calculate ( recorder ) { it . fold ( 1 ) { memo , next -> memo * next } } ) ) } private fun calculate ( recorder : Recorder , fn : ( List < Int > ) -> Int ): ( Request ) -> Response { val values = Query . int () . multi . defaulted ( \"value\" , listOf ()) return { request : Request -> val valuesToCalc = values ( request ) val answer = if ( valuesToCalc . isEmpty ()) 0 else fn ( valuesToCalc ) recorder . record ( answer ) Response ( OK ) . body ( answer . toString ()) } } fun MyMathServer ( port : Int , recorderBaseUri : Uri ): Http4kServer = MyMathsApp ( SetHostFrom ( recorderBaseUri ) . then ( OkHttp ())) . asServer ( Jetty ( port ))","title":"Part 4: Adding an external dependency"},{"location":"tutorials/tdding_http4k/_4/#requirements","text":"Results from calculations should be POSTed via HTTP to another \"answer recording\" service.","title":"Requirements:"},{"location":"tutorials/tdding_http4k/_4/#implementation-notes","text":"The following process is followed to us to the final state, whilst always allowing us to keep the build green: Determine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer} Create RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder Create FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement Include the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything) Pass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler Factor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done Introduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment Alter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp In MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record()","title":"Implementation Notes:"},{"location":"tutorials/tdding_http4k/_4/#tests","text":"package tutorials . tdding_http4k . _4 import com.natpryce.hamkrest.and import com.natpryce.hamkrest.assertion.assertThat import com.natpryce.hamkrest.equalTo import org.http4k.client.OkHttp import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.ACCEPTED import org.http4k.core.Status.Companion.BAD_REQUEST import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters.SetHostFrom import org.http4k.filter.ServerFilters.CatchLensFailure import org.http4k.hamkrest.hasBody import org.http4k.hamkrest.hasStatus import org.http4k.lens.Path import org.http4k.lens.int import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Jetty import org.http4k.server.asServer import org.junit.jupiter.api.AfterEach import org.junit.jupiter.api.BeforeEach import org.junit.jupiter.api.Disabled import org.junit.jupiter.api.Test import tutorials.tdding_http4k._4.Matchers.answerShouldBe import java.util.Random object Matchers { fun Response . answerShouldBe ( expected : Int ) { assertThat ( this , hasStatus ( OK ) . and ( hasBody ( expected . toString ()))) } } abstract class RecorderCdc { abstract val client : HttpHandler @Test fun `records answer` () { Recorder ( client ) . record ( 123 ) checkAnswerRecorded () } open fun checkAnswerRecorded () {} } class FakeRecorderHttp : HttpHandler { val calls = mutableListOf < Int > () private val answer = Path . int () . of ( \"answer\" ) private val app = CatchLensFailure . then ( routes ( \"/{answer}\" bind POST to { request -> calls . add ( answer ( request )); Response ( ACCEPTED ) } ) ) override fun invoke ( request : Request ): Response = app ( request ) } class FakeRecorderTest : RecorderCdc () { override val client = FakeRecorderHttp () override fun checkAnswerRecorded () { assertThat ( client . calls , equalTo ( listOf ( 123 ))) } } @Disabled // this obviously doesn 't exist, so we ignore it here class RealRecorderTest : RecorderCdc () { override val client = SetHostFrom ( Uri . of ( \"http://realrecorder\" )) . then ( OkHttp ()) } class EndToEndTest { private val port = Random () . nextInt ( 1000 ) + 8000 private val recorderPort = port + 1 private val client = OkHttp () private val recorder = FakeRecorderHttp () private val server = MyMathServer ( 0 , Uri . of ( \"http://localhost:$recorderPort\" )) private val recorderServer = recorder . asServer ( Jetty ( recorderPort )) @BeforeEach fun setup () { recorderServer . start () server . start () } @AfterEach fun teardown () { server . stop () recorderServer . stop () } @Test fun `all endpoints are mounted correctly` () { assertThat ( client ( Request ( GET , \"http://localhost:${server.port()}/ping\" )), hasStatus ( OK )) client ( Request ( GET , \"http://localhost:${server.port()}/add?value=1&value=2\" )) . answerShouldBe ( 3 ) client ( Request ( GET , \"http://localhost:${server.port()}/multiply?value=2&value=4\" )) . answerShouldBe ( 8 ) } } class AppEnvironment { val recorder = FakeRecorderHttp () val client = MyMathsApp ( recorder ) } class AddFunctionalTest { private val env = AppEnvironment () @Test fun `adds values together` () { env . client ( Request ( GET , \"/add?value=1&value=2\" )) . answerShouldBe ( 3 ) assertThat ( env . recorder . calls , equalTo ( listOf ( 3 ))) } @Test fun `answer is zero when no values` () { env . client ( Request ( GET , \"/add\" )) . answerShouldBe ( 0 ) assertThat ( env . recorder . calls , equalTo ( listOf ( 0 ))) } @Test fun `bad request when some values are not numbers` () { assertThat ( env . client ( Request ( GET , \"/add?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) assertThat ( env . recorder . calls . isEmpty (), equalTo ( true )) } } class MultiplyFunctionalTest { private val env = AppEnvironment () @Test fun `products values together` () { env . client ( Request ( GET , \"/multiply?value=2&value=4\" )) . answerShouldBe ( 8 ) assertThat ( env . recorder . calls , equalTo ( listOf ( 8 ))) } @Test fun `answer is zero when no values` () { env . client ( Request ( GET , \"/multiply\" )) . answerShouldBe ( 0 ) assertThat ( env . recorder . calls , equalTo ( listOf ( 0 ))) } @Test fun `bad request when some values are not numbers` () { assertThat ( env . client ( Request ( GET , \"/multiply?value=1&value=notANumber\" )), hasStatus ( BAD_REQUEST )) assertThat ( env . recorder . calls . isEmpty (), equalTo ( true )) } }","title":"Tests:"},{"location":"tutorials/tdding_http4k/_4/#production","text":"package tutorials . tdding_http4k . _4 import org.http4k.client.OkHttp import org.http4k.core.HttpHandler import org.http4k.core.Method.GET import org.http4k.core.Method.POST import org.http4k.core.Request import org.http4k.core.Response import org.http4k.core.Status.Companion.ACCEPTED import org.http4k.core.Status.Companion.OK import org.http4k.core.Uri import org.http4k.core.then import org.http4k.filter.ClientFilters.SetHostFrom import org.http4k.filter.ServerFilters.CatchLensFailure import org.http4k.lens.Query import org.http4k.lens.int import org.http4k.routing.bind import org.http4k.routing.routes import org.http4k.server.Http4kServer import org.http4k.server.Jetty import org.http4k.server.asServer class Recorder ( private val client : HttpHandler ) { fun record ( value : Int ) { val response = client ( Request ( POST , \"/$value\" )) if ( response . status != ACCEPTED ) throw RuntimeException ( \"recorder returned ${response.status}\" ) } } fun MyMathsApp ( recorderHttp : HttpHandler ): HttpHandler { val recorder = Recorder ( recorderHttp ) return CatchLensFailure . then ( routes ( \"/ping\" bind GET to { _ : Request -> Response ( OK ) }, \"/add\" bind GET to calculate ( recorder ) { it . sum () }, \"/multiply\" bind GET to calculate ( recorder ) { it . fold ( 1 ) { memo , next -> memo * next } } ) ) } private fun calculate ( recorder : Recorder , fn : ( List < Int > ) -> Int ): ( Request ) -> Response { val values = Query . int () . multi . defaulted ( \"value\" , listOf ()) return { request : Request -> val valuesToCalc = values ( request ) val answer = if ( valuesToCalc . isEmpty ()) 0 else fn ( valuesToCalc ) recorder . record ( answer ) Response ( OK ) . body ( answer . toString ()) } } fun MyMathServer ( port : Int , recorderBaseUri : Uri ): Http4kServer = MyMathsApp ( SetHostFrom ( recorderBaseUri ) . then ( OkHttp ())) . asServer ( Jetty ( port ))","title":"Production:"},{"location":"tutorials/typesafe_configuration/","text":"Add typesafe 12-factor configuration to http4k apps with Environments. Intro This post covers the various concerns around configuring HTTP apps, and introduces the http4k approach for addressing these when deploying applications into cloud-native environments, which leverages the Kotlin type system for maximum safely and code reuse. Concerns when configuring applications One of the tenets of operating applications according to the principles of 12factor , and especially in containerised cloud-native apps, is to inject all app configuration through the use of environmental variables. Additionally, when using more restrictive settings (such as utilising JVM security manager policies or through the use of container images which don't provide an OS baseline) it may not be possible to read files (such as YAML, JSON etc) from disk, which reinforces this approach. There are several particular relevant concerns that we need to address, but overall the effect that we are looking for is that any misconfiguration of the application will result in it failing to startup. For this reason we want to reify all values to check them as soon as possible in the application bootstrap phase. 1. Optionality Kotlin's type system guards us against missing values being injected - for instance the following code will throw a IllegalStateException due to a typo in the parameter name: package tutorials.typesafe_configuration.pre // export ANTIDISESTABLISHMENTARIANISM=opposition to the disestablishment of the Church of England val definition: String = System.getenv(\"ANTIDISESTABLISHMENTARIAMISM\") However not all configuration values will be required. We can define that there are 3 distinct modes of optionality available for each parameter: Required: These values must be injected for each environment, with no default value defined. Most configurations such as hostnames should always use this form to maximise operational safety. Optional: These values can be supplied, but there is no default value. This category fits well with dynamic properties which could be data-driven (ie. not known at compile-time). Defaulted: These values can be supplied, but a fallback value (or chain of other config values) will be used if they are not. Missing values should produce a reasonable error and stop the app from starting. 2. Type coercion Most applications will require a variety of configuration primitive types, which may or may not map to the Java/Kotlin standard types, including: strings such as service URLs, log levels, or AWS role names numeric values such as ports or retry counts booleans such as debug switch or feature flags duration values for timeouts, backoff times But handling these raw types alone is not enough to guarantee safety - it is best to marshall the values into a suitable operational/domain type that can validate the input and avoid confusion. Kotlin gives us a simple way to do this using require as a guard: package tutorials.typesafe_configuration.pre class Port(val value: Int) { init { require((1..65535).contains(value)) { \"Out of range Port: '$value'\" } } } // export PORT=8000 val port = Port(System.getenv(\"PORT\").toInt()) Additionally to the above, it is important to represent those values in a form that cannot be misinterpreted. A good example of this is the passing of temporal values as integers - timeouts defined this way could be easily be parsed into the wrong time unit (seconds instead of milliseconds). Using a higher level primitive such as Duration will help us here: package tutorials . typesafe_configuration . pre import java.time.Duration data class Timeout ( val value : Duration ) { init { require ( ! value . isNegative ) { \"Cannot have negative timeout\" } } } // export TIMEOUT = PT30S val timeout = Timeout ( Duration . parse ( System . getenv ( \"TIMEOUT\" ))) Obviously, the above is still not very safe - and what's more, a coercion could now fail with one of 3 different exceptions depending on if the value was missing ( IllegalStateException ), unparsable ( DateTimeParseException ) or invalid ( IllegalArgumentException ). The conversion code from String -> Duration must also be repeated (or extracted) for each value that we wish to parse. 3. Multiplicity Configuration parameters may have one or many values and need to be converted safely from the injected string representation (usually comma-separated) and into their internally represented types at application startup: package tutorials.typesafe_configuration.pre class Host(val value: String) // export HOSTNAMES=eu-west1.aws.com,eu-west2.aws.com,eu-west3.aws.com val hosts = System.getenv(\"HOSTNAMES\").split(\",\").map { Host(it.trim()) } Once again, the splitting code will need to be repeated for each config value, or extracted to a library function. 4. Security The configuration of a standard app will generally contain both sensitive and non-sensitive values. Sensitive such as application secrets, DB passwords or API keys should be handled in a way that avoid storing directly in memory in a readable format or long lived fashion, where they may be inadvertently inspected or outputted into a log file. Dangling code situations such as in the code below are common, and are asking for trouble... package tutorials . typesafe_configuration . pre import org.http4k.client.OkHttp import org.http4k.core.Method.GET import org.http4k.core.Request import java.nio.ByteBuffer val s3 = OkHttp () fun readFile ( secretKey : String , bucketKey : String ): ByteBuffer { return s3 ( Request ( GET , \"https://mybucket.s3.amazonaws.com/$bucketKey\" )) . body . payload } // export AWS_SECRET_KEY = someSuperSecretValueThatOpsReallyDoNotWantYouToKnow val file = readFile ( System . getenv ( \"AWS_SECRET_KEY\" ), \"myfile.txt\" ) 5. Configuration Context & Overriding We also want to avoid defining all values for all possible scenarios - for example in test cases, so the ability to overlay configuration sets on top of each other is useful. Although it is against the rules of 12-factor, it is sometimes convenient to source parameter values from a variety of contexts when running applications in non-cloud environments: System Environment variables Properties files JAR resources Local files Source code defined environmental configuration Implementing this kind of fallback logic manually, you'd end up with code like the below: package tutorials . typesafe_configuration . pre val name = System . getProperty ( \"USERNAME\" ) ? : System . getenv ( \"USERNAME\" ) ? : \"DEFAULT_USER\" The http4k approach... There are already many options for configurational libraries written in Kotlin, but http4k also provides an option in the http4k-cloudnative add-on module which leverages the power of the Lens system already built into the core library to provide a consistent experience to API users. In case you're new to Lenses, here's a recap... Lenses - a recap In http4k , Lenses are typically used to provide typesafe conversion of typed values into and out of HTTP messages, although this concept has been extended within the http4k ecosystem to support that of a form handling and request contexts. A Lens is an stateless object responsible for either the one-way (or Bidirectional) transformation of It defines type parameters representing input IN and output OUT types and implements one (for a Lens ) or both (for a BiDiLens ) of the following interfaces: LensExtractor - takes a value of type IN and extracts a value of type OUT LensInjector - takes a value of type IN and a value of type OUT and returns a modified value of type IN with the value injected into it. package tutorials . typesafe_configuration . post interface LensExtractor < in IN , out OUT > : ( IN ) -> OUT { override operator fun invoke ( target : IN ): OUT } interface LensInjector < in IN , in OUT > { operator fun < R : OUT > invoke ( value : IN , target : R ): R } interface Lens < IN , OUT > : LensExtractor < IN , OUT > interface BiDiLens < IN , OUT > : Lens < IN , OUT > , LensInjector < IN , OUT > The creation of a Lens consists of 4 main concerns: targeting determines where the Lens expects to extract and inject the values from/to, which can consist of both an overall target and a name within that target. multiplicity handling which defines how many of a particular value we are attempting to handle. the transformation chain of function composition which forms a specification for converting one type to another. This is done in code using the map() method defined on the Lens. the optionality of a Lens denotes the behaviour if/when a value cannot be found in the target. To define a Lens instance through the http4k Lens API, we take an initial target specification, decide it's multiplicity , provide any transformations with map() , and finally reify the specification into a Lens instance by deciding it's optionality. It sounds involved, but it is consistent and the fluent API has been designed to make it simpler. By way of an example, here we define a bi-directional Lens for custom type Page , extracted from a querystring value and defaulting to Page 1. package tutorials . typesafe_configuration . post import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.lens.BiDiLens import org.http4k.lens.Query import org.http4k.lens.int data class Page ( val value : Int ) { init { require ( value > 1 ) { \"Page number must be positive\" } } } val lens : BiDiLens < Request , Page > = Query . int () . map (:: Page , Page :: value ) . defaulted ( \"pageNumber\" , Page ( 1 )) val pageNumber : Page = lens ( Request ( GET , \"http://abc/search?pageNumber=55\" )) val updatedRequest : Request = lens ( pageNumber , Request ( GET , \"http://abc/search\" )) In http4k , Lenses are typically used to provide typesafe conversion of typed values into and out of HTTP messages, although this concept has been extended within the http4k ecosystem to support that of a form handling and request contexts. http4k Environments in http4k , an Environment object is a context which holds configuration values. It effectively behaves like a Map , in that it can be composed with other Environment objects to provide a consolidated view of all of it's component values. package tutorials . typesafe_configuration . post import org.http4k.cloudnative.env.Environment import java.io.File val systemEnv : Environment = Environment . ENV val jvmFlags : Environment = Environment . JVM_PROPERTIES val jar : Environment = Environment . fromResource ( \"jar.properties\" ) val filesystem : Environment = Environment . from ( File ( \"fs.properties\" )) val codeBased : Environment = Environment . from ( \"key1\" to \"value1\" , \"key2\" to \"value2\" ) val consolidated : Environment = jvmFlags overrides systemEnv overrides codeBased overrides filesystem overrides jar If you're using any of the other Kotlin-based configuration libraries, the above should look pretty familiar. The difference starts to become apparent when attempting to retrieve values from the Environment instance. This is done using EnviromentKey Lenses, which are an extension of the http4k Lens system that specifically targets Environment objects. package tutorials . typesafe_configuration . post import org.http4k.cloudnative.env.Environment import org.http4k.cloudnative.env.EnvironmentKey import org.http4k.lens.Lens import org.http4k.lens.duration import org.http4k.lens.int import java.time.Duration data class Timeout ( val value : Duration ) data class Port ( val value : Int ) data class Host ( val value : String ) // export TIMEOUT = PT30S // export PORT = 8080 // export HOSTNAMES = eu - west1 . aws . com , eu - west2 . aws . com , eu - west3 . aws . com val env = Environment . ENV val portLens : Lens < Environment , Port > = EnvironmentKey . int () . map (:: Port ) . defaulted ( \"PORT\" , Port ( 9000 )) val timeoutLens : Lens < Environment , Timeout ? > = EnvironmentKey . duration () . map (:: Timeout ) . optional ( \"TIMEOUT\" ) val hostsLens : Lens < Environment , List < Host >> = EnvironmentKey . map (:: Host ) . multi . required ( \"HOSTNAMES\" ) val timeout : Timeout ? = timeoutLens ( env ) val port : Port = portLens ( env ) val hosts : List < Host > = hostsLens ( env ) Handling failure When using the http4k Environment to define config, missing or values which cannot be deserialised all now cause a LensFailure to be thrown with a descriptive error message. As before, this results in the application failing to start, but as the exception if both consistent and explicit, diagnosing the problem becomes much simpler. Single-shot Secrets In order to avoid the accidental exposure of sensitive information such as passwords into the application runtime, a new type Secret has been introduced, which tries as much as possible to avoid exposing it's internal value as a readable String . The Secret class is designed to only have the string version of it's value read once, and only within a specific use() block, after which the underlying value is internally overwritten and further attempts to read it throw an IllegalStateException . The typical use-case for this block is to set-up a SQL Datasource or to create a Filter which adds authentication to all outbound requests, as in the example below: package tutorials . typesafe_configuration . post import org.http4k.client.OkHttp import org.http4k.cloudnative.env.Environment import org.http4k.cloudnative.env.EnvironmentKey import org.http4k.cloudnative.env.Secret import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.then import org.http4k.filter.ServerFilters import org.http4k.lens.Lens import org.http4k.lens.secret // export USER_PASSWORD = 12345 val accessToken : Lens < Environment , Secret > = EnvironmentKey . secret () . required ( \"USER_PASSWORD\" ) val secret : Secret = accessToken ( Environment . ENV ) val authFilter : Filter = secret . use { value : String -> ServerFilters . BearerAuth ( value ) } val authedHttp : HttpHandler = authFilter . then ( OkHttp ()) As with other supported primitives, Secret is available by default in all supported Lens Locations.","title":"http4k tutorials: Add typesafe 12-factor configuration to http4k apps with Environments."},{"location":"tutorials/typesafe_configuration/#add-typesafe-12-factor-configuration-to-http4k-apps-with-environments","text":"","title":"Add typesafe 12-factor configuration to http4k apps with Environments."},{"location":"tutorials/typesafe_configuration/#intro","text":"This post covers the various concerns around configuring HTTP apps, and introduces the http4k approach for addressing these when deploying applications into cloud-native environments, which leverages the Kotlin type system for maximum safely and code reuse.","title":"Intro"},{"location":"tutorials/typesafe_configuration/#concerns-when-configuring-applications","text":"One of the tenets of operating applications according to the principles of 12factor , and especially in containerised cloud-native apps, is to inject all app configuration through the use of environmental variables. Additionally, when using more restrictive settings (such as utilising JVM security manager policies or through the use of container images which don't provide an OS baseline) it may not be possible to read files (such as YAML, JSON etc) from disk, which reinforces this approach. There are several particular relevant concerns that we need to address, but overall the effect that we are looking for is that any misconfiguration of the application will result in it failing to startup. For this reason we want to reify all values to check them as soon as possible in the application bootstrap phase.","title":"Concerns when configuring applications"},{"location":"tutorials/typesafe_configuration/#1-optionality","text":"Kotlin's type system guards us against missing values being injected - for instance the following code will throw a IllegalStateException due to a typo in the parameter name: package tutorials.typesafe_configuration.pre // export ANTIDISESTABLISHMENTARIANISM=opposition to the disestablishment of the Church of England val definition: String = System.getenv(\"ANTIDISESTABLISHMENTARIAMISM\") However not all configuration values will be required. We can define that there are 3 distinct modes of optionality available for each parameter: Required: These values must be injected for each environment, with no default value defined. Most configurations such as hostnames should always use this form to maximise operational safety. Optional: These values can be supplied, but there is no default value. This category fits well with dynamic properties which could be data-driven (ie. not known at compile-time). Defaulted: These values can be supplied, but a fallback value (or chain of other config values) will be used if they are not. Missing values should produce a reasonable error and stop the app from starting.","title":"1. Optionality"},{"location":"tutorials/typesafe_configuration/#2-type-coercion","text":"Most applications will require a variety of configuration primitive types, which may or may not map to the Java/Kotlin standard types, including: strings such as service URLs, log levels, or AWS role names numeric values such as ports or retry counts booleans such as debug switch or feature flags duration values for timeouts, backoff times But handling these raw types alone is not enough to guarantee safety - it is best to marshall the values into a suitable operational/domain type that can validate the input and avoid confusion. Kotlin gives us a simple way to do this using require as a guard: package tutorials.typesafe_configuration.pre class Port(val value: Int) { init { require((1..65535).contains(value)) { \"Out of range Port: '$value'\" } } } // export PORT=8000 val port = Port(System.getenv(\"PORT\").toInt()) Additionally to the above, it is important to represent those values in a form that cannot be misinterpreted. A good example of this is the passing of temporal values as integers - timeouts defined this way could be easily be parsed into the wrong time unit (seconds instead of milliseconds). Using a higher level primitive such as Duration will help us here: package tutorials . typesafe_configuration . pre import java.time.Duration data class Timeout ( val value : Duration ) { init { require ( ! value . isNegative ) { \"Cannot have negative timeout\" } } } // export TIMEOUT = PT30S val timeout = Timeout ( Duration . parse ( System . getenv ( \"TIMEOUT\" ))) Obviously, the above is still not very safe - and what's more, a coercion could now fail with one of 3 different exceptions depending on if the value was missing ( IllegalStateException ), unparsable ( DateTimeParseException ) or invalid ( IllegalArgumentException ). The conversion code from String -> Duration must also be repeated (or extracted) for each value that we wish to parse.","title":"2. Type coercion"},{"location":"tutorials/typesafe_configuration/#3-multiplicity","text":"Configuration parameters may have one or many values and need to be converted safely from the injected string representation (usually comma-separated) and into their internally represented types at application startup: package tutorials.typesafe_configuration.pre class Host(val value: String) // export HOSTNAMES=eu-west1.aws.com,eu-west2.aws.com,eu-west3.aws.com val hosts = System.getenv(\"HOSTNAMES\").split(\",\").map { Host(it.trim()) } Once again, the splitting code will need to be repeated for each config value, or extracted to a library function.","title":"3. Multiplicity"},{"location":"tutorials/typesafe_configuration/#4-security","text":"The configuration of a standard app will generally contain both sensitive and non-sensitive values. Sensitive such as application secrets, DB passwords or API keys should be handled in a way that avoid storing directly in memory in a readable format or long lived fashion, where they may be inadvertently inspected or outputted into a log file. Dangling code situations such as in the code below are common, and are asking for trouble... package tutorials . typesafe_configuration . pre import org.http4k.client.OkHttp import org.http4k.core.Method.GET import org.http4k.core.Request import java.nio.ByteBuffer val s3 = OkHttp () fun readFile ( secretKey : String , bucketKey : String ): ByteBuffer { return s3 ( Request ( GET , \"https://mybucket.s3.amazonaws.com/$bucketKey\" )) . body . payload } // export AWS_SECRET_KEY = someSuperSecretValueThatOpsReallyDoNotWantYouToKnow val file = readFile ( System . getenv ( \"AWS_SECRET_KEY\" ), \"myfile.txt\" )","title":"4. Security"},{"location":"tutorials/typesafe_configuration/#5-configuration-context-overriding","text":"We also want to avoid defining all values for all possible scenarios - for example in test cases, so the ability to overlay configuration sets on top of each other is useful. Although it is against the rules of 12-factor, it is sometimes convenient to source parameter values from a variety of contexts when running applications in non-cloud environments: System Environment variables Properties files JAR resources Local files Source code defined environmental configuration Implementing this kind of fallback logic manually, you'd end up with code like the below: package tutorials . typesafe_configuration . pre val name = System . getProperty ( \"USERNAME\" ) ? : System . getenv ( \"USERNAME\" ) ? : \"DEFAULT_USER\"","title":"5. Configuration Context &amp; Overriding"},{"location":"tutorials/typesafe_configuration/#the-http4k-approach","text":"There are already many options for configurational libraries written in Kotlin, but http4k also provides an option in the http4k-cloudnative add-on module which leverages the power of the Lens system already built into the core library to provide a consistent experience to API users. In case you're new to Lenses, here's a recap...","title":"The http4k approach..."},{"location":"tutorials/typesafe_configuration/#lenses-a-recap","text":"In http4k , Lenses are typically used to provide typesafe conversion of typed values into and out of HTTP messages, although this concept has been extended within the http4k ecosystem to support that of a form handling and request contexts. A Lens is an stateless object responsible for either the one-way (or Bidirectional) transformation of It defines type parameters representing input IN and output OUT types and implements one (for a Lens ) or both (for a BiDiLens ) of the following interfaces: LensExtractor - takes a value of type IN and extracts a value of type OUT LensInjector - takes a value of type IN and a value of type OUT and returns a modified value of type IN with the value injected into it. package tutorials . typesafe_configuration . post interface LensExtractor < in IN , out OUT > : ( IN ) -> OUT { override operator fun invoke ( target : IN ): OUT } interface LensInjector < in IN , in OUT > { operator fun < R : OUT > invoke ( value : IN , target : R ): R } interface Lens < IN , OUT > : LensExtractor < IN , OUT > interface BiDiLens < IN , OUT > : Lens < IN , OUT > , LensInjector < IN , OUT > The creation of a Lens consists of 4 main concerns: targeting determines where the Lens expects to extract and inject the values from/to, which can consist of both an overall target and a name within that target. multiplicity handling which defines how many of a particular value we are attempting to handle. the transformation chain of function composition which forms a specification for converting one type to another. This is done in code using the map() method defined on the Lens. the optionality of a Lens denotes the behaviour if/when a value cannot be found in the target. To define a Lens instance through the http4k Lens API, we take an initial target specification, decide it's multiplicity , provide any transformations with map() , and finally reify the specification into a Lens instance by deciding it's optionality. It sounds involved, but it is consistent and the fluent API has been designed to make it simpler. By way of an example, here we define a bi-directional Lens for custom type Page , extracted from a querystring value and defaulting to Page 1. package tutorials . typesafe_configuration . post import org.http4k.core.Method.GET import org.http4k.core.Request import org.http4k.lens.BiDiLens import org.http4k.lens.Query import org.http4k.lens.int data class Page ( val value : Int ) { init { require ( value > 1 ) { \"Page number must be positive\" } } } val lens : BiDiLens < Request , Page > = Query . int () . map (:: Page , Page :: value ) . defaulted ( \"pageNumber\" , Page ( 1 )) val pageNumber : Page = lens ( Request ( GET , \"http://abc/search?pageNumber=55\" )) val updatedRequest : Request = lens ( pageNumber , Request ( GET , \"http://abc/search\" )) In http4k , Lenses are typically used to provide typesafe conversion of typed values into and out of HTTP messages, although this concept has been extended within the http4k ecosystem to support that of a form handling and request contexts.","title":"Lenses - a recap"},{"location":"tutorials/typesafe_configuration/#http4k-environments","text":"in http4k , an Environment object is a context which holds configuration values. It effectively behaves like a Map , in that it can be composed with other Environment objects to provide a consolidated view of all of it's component values. package tutorials . typesafe_configuration . post import org.http4k.cloudnative.env.Environment import java.io.File val systemEnv : Environment = Environment . ENV val jvmFlags : Environment = Environment . JVM_PROPERTIES val jar : Environment = Environment . fromResource ( \"jar.properties\" ) val filesystem : Environment = Environment . from ( File ( \"fs.properties\" )) val codeBased : Environment = Environment . from ( \"key1\" to \"value1\" , \"key2\" to \"value2\" ) val consolidated : Environment = jvmFlags overrides systemEnv overrides codeBased overrides filesystem overrides jar If you're using any of the other Kotlin-based configuration libraries, the above should look pretty familiar. The difference starts to become apparent when attempting to retrieve values from the Environment instance. This is done using EnviromentKey Lenses, which are an extension of the http4k Lens system that specifically targets Environment objects. package tutorials . typesafe_configuration . post import org.http4k.cloudnative.env.Environment import org.http4k.cloudnative.env.EnvironmentKey import org.http4k.lens.Lens import org.http4k.lens.duration import org.http4k.lens.int import java.time.Duration data class Timeout ( val value : Duration ) data class Port ( val value : Int ) data class Host ( val value : String ) // export TIMEOUT = PT30S // export PORT = 8080 // export HOSTNAMES = eu - west1 . aws . com , eu - west2 . aws . com , eu - west3 . aws . com val env = Environment . ENV val portLens : Lens < Environment , Port > = EnvironmentKey . int () . map (:: Port ) . defaulted ( \"PORT\" , Port ( 9000 )) val timeoutLens : Lens < Environment , Timeout ? > = EnvironmentKey . duration () . map (:: Timeout ) . optional ( \"TIMEOUT\" ) val hostsLens : Lens < Environment , List < Host >> = EnvironmentKey . map (:: Host ) . multi . required ( \"HOSTNAMES\" ) val timeout : Timeout ? = timeoutLens ( env ) val port : Port = portLens ( env ) val hosts : List < Host > = hostsLens ( env )","title":"http4k Environments"},{"location":"tutorials/typesafe_configuration/#handling-failure","text":"When using the http4k Environment to define config, missing or values which cannot be deserialised all now cause a LensFailure to be thrown with a descriptive error message. As before, this results in the application failing to start, but as the exception if both consistent and explicit, diagnosing the problem becomes much simpler.","title":"Handling failure"},{"location":"tutorials/typesafe_configuration/#single-shot-secrets","text":"In order to avoid the accidental exposure of sensitive information such as passwords into the application runtime, a new type Secret has been introduced, which tries as much as possible to avoid exposing it's internal value as a readable String . The Secret class is designed to only have the string version of it's value read once, and only within a specific use() block, after which the underlying value is internally overwritten and further attempts to read it throw an IllegalStateException . The typical use-case for this block is to set-up a SQL Datasource or to create a Filter which adds authentication to all outbound requests, as in the example below: package tutorials . typesafe_configuration . post import org.http4k.client.OkHttp import org.http4k.cloudnative.env.Environment import org.http4k.cloudnative.env.EnvironmentKey import org.http4k.cloudnative.env.Secret import org.http4k.core.Filter import org.http4k.core.HttpHandler import org.http4k.core.then import org.http4k.filter.ServerFilters import org.http4k.lens.Lens import org.http4k.lens.secret // export USER_PASSWORD = 12345 val accessToken : Lens < Environment , Secret > = EnvironmentKey . secret () . required ( \"USER_PASSWORD\" ) val secret : Secret = accessToken ( Environment . ENV ) val authFilter : Filter = secret . use { value : String -> ServerFilters . BearerAuth ( value ) } val authedHttp : HttpHandler = authFilter . then ( OkHttp ()) As with other supported primitives, Secret is available by default in all supported Lens Locations.","title":"Single-shot Secrets"}]}