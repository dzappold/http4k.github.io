{
    "docs": [
        {
            "location": "/", 
            "text": "http4k\n is an HTTP toolkit written in \nKotlin\n that enables the serving and consuming of HTTP services in a functional and consistent way.\n\n\nIt consists of a core library \nhttp4k-core\n providing a base HTTP implementation + a number of abstractions for various functionalities (such as \nservers, clients, templating etc) that are provided as optional add-on libraries.\n\n\nThe principles of the toolkit are:\n\n\n\n\nApplication as a Function:\n Based on the Twitter paper \n\"Your Server as a Function\"\n, all HTTP services can be composed \nof 2 types of simple function:\n\n\nHttpHandler:\n \n(Request) -\n Response\n - provides a remote call for processing a Request. \n\n\nFilter:\n \n(HttpHandler) -\n HttpHandler\n - adds Request/Response pre/post processing. These filters are composed to make stacks of reusable behaviour that can \nthen be applied to an \nHttpHandler\n.\n\n\n\n\n\n\nImmutability:\n All entities in the library are immutable unless their function explicitly disallows this.\n\n\nSymmetric:\n The \nHttpHandler\n interface is identical for both HTTP services and clients. This allows for simple offline testability of applications, as well as \nplugging together of services without HTTP container being required.\n\n\nDependency-lite:\n Apart the from Kotlin StdLib, \nhttp4k-core\n module has ZERO dependencies and weighs in at ~500kb. Add-on modules only have dependencies required for specific implementation.\n\n\nTestability\n Built by \nTDD\n enthusiasts, so supports \nsuper-easy\n mechanisms for both In and Out of Container testing of:\n\n\nindividual endpoints\n\n\napplications\n\n\nfull suites of microservices\n\n\n\n\n\n\nModularity:\n Common behaviours are abstracted into the \nhttp4k-core\n module. Current add-ons cover:\n\n\nPluggable HTTP client adapters for Apache and OkHttp\n\n\nPluggable Server backends: Single LOC Server spinup for Jetty, Netty, Undertow and SunHttp\n\n\nTypesafe, auto-validating, self-documenting (via OpenApi/Swagger) contracts for HTTP services\n\n\nHTTP message adapters for Argo JSON, Gson JSON, Jackson JSON and XML - includes auto-marshalling capabilities to convert directly to Kotlin data classes.\n\n\nTemplating support: Caching and Hot-Reload engine support for Handlebars, Pebble, Dust and Thymeleaf\n\n\nAWS request signing: super-simple interactions with AWS services\n\n\nMultipart form handling.\n\n\nResilience features: Circuits, retrying, rate limiting, bulkheading - via Resilience4J integration.\n\n\nTesting: Selenium WebDriver implementation for lightning fast, browserless testing of \nhttp4k\n apps\n\n\nTesting: Hamkrest Matchers for \nhttp4k\n objects\n\n\n\n\n\n\n\n\nModule feature overview\n\n\n\n\nCore:\n \n\n\nBase HTTP handler and \nimmutable HTTP message\n objects, cookie handling. \n\n\nCommonly used HTTP functionalities provided as reusable Filters (caching, debugging, \nZipkin request tracing\n)\n\n\nPath-based routing\n, including nestable contexts\n\n\nTypesafe HTTP message construction/desconstruction and Request Contexts\n using Lenses\n\n\nStatic file-serving\n capability with \nCaching and Hot-Reload\n \n\n\nServlet implementation to allow \n\n-dependency plugin to any Servlet container\n\n\nLaunch applications in \n1LOC\n with an embedded \nSunHttp\n server backend (recommended for development use only)\n\n\nAPIs to \nrecord and replay\n HTTP traffic to disk or memory\n\n\nCore \nabstraction APIs\n implemented by the other modules \n\n\n\n\n\n\nClient:\n \n\n\n1LOC\n HTTP client adapters \n\n\nApache\n\n\nOkHttp\n\n\n\n\n\n\n\n\n\n\nServer:\n\n\n1LOC\n server backend spinup for:\n\n\nJetty\n\n\nNetty\n\n\nUndertow\n\n\nSunHttp\n (bundled with \nhttp4k-core\n)\n\n\n\n\n\n\nAPI design allows for plugging into configurable instances of each\n\n\n\n\n\n\nContracts:\n \n\n\nDefinite \nTypesafe\n HTTP contracts, defining required and optional path/query/header/bodies\n\n\nTypesafe\n path matching\n\n\nAuto-validation\n of incoming requests == \nzero boilerplate validation code\n\n\nSelf-documenting for all routes - eg. Built in support for live \nOpenApi/Swagger\n description endpoints including \nJSON Schema\n model breakdown. \n\n\n\n\n\n\nTemplating:\n \n\n\nPluggable\n templating system support for:\n\n\nDust\n \n\n\nHandlebars\n \n\n\nPebble\n\n\nThymeleaf\n\n\n\n\n\n\nCaching and \nHot-Reload\n template support\n\n\n\n\n\n\nMessage formats:\n \n\n\nConsistent API provides first class support for marshalling JSON to/from HTTP messages for:\n\n\nJackson\n - includes support for \nfully \nautomatic marshalling\n of Data classes\n)\n\n\nGson\n - includes support for \nfully \nautomatic marshalling\n of Data classes\n)\n\n\nArgo\n - lightweight Java JSON API with zero dependencies.\n\n\nXml\n - includes support for \none way \nautomatic marshalling\n of Data classes\n)\n\n\n\n\n\n\n\n\n\n\nResilience:\n \n\n\nSupport for Circuits, Retrying, Rate-Limiting, Bulkheading via Resilience4J integration.\n\n\n\n\n\n\nMultipart:\n \n\n\nSupport for Multipart HTML forms, including Lens extensions for type-safe marshalling of fields.\n\n\n\n\n\n\nAWS:\n \n\n\nClient filter to allow super-simple interaction with AWS services (via request signing)\n\n\n\n\n\n\nWebDriver:\n \n\n\nUltra-lightweight Selenium WebDriver implementation for \nhttp4k\n application.\n\n\n\n\n\n\nHamkrest:\n \n\n\nA set of Hamkrest matchers for testing \nhttp4k\n Request and Response messages.\n\n\n\n\n\n\n\n\nExample\n\n\nThis quick example is designed to convey the simplicity \n features of \nhttp4k\n. See also the \nquickstart\n for the simplest possible starting point.\n\n\nTo install, add these dependencies to your \nGradle\n file:\n\n\ndependencies\n \n{\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-core\n,\n \nversion:\n \n2.38.0\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-server-jetty\n,\n \nversion:\n \n2.38.0\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-client-okhttp\n,\n \nversion:\n \n2.38.0\n\n\n}\n\n\n\n\n\n\nThis \"Hello World\" style example demonstrates how to serve and consume HTTP services with dynamic routing:\n\n\npackage\n \ncookbook\n\n\n\nimport\n \norg.http4k.client.OkHttp\n\n\nimport\n \norg.http4k.core.Filter\n\n\nimport\n \norg.http4k.core.HttpHandler\n\n\nimport\n \norg.http4k.core.Method.GET\n\n\nimport\n \norg.http4k.core.Request\n\n\nimport\n \norg.http4k.core.Response\n\n\nimport\n \norg.http4k.core.Status.Companion.OK\n\n\nimport\n \norg.http4k.core.then\n\n\nimport\n \norg.http4k.filter.CachingFilters\n\n\nimport\n \norg.http4k.routing.bind\n\n\nimport\n \norg.http4k.routing.path\n\n\nimport\n \norg.http4k.routing.routes\n\n\nimport\n \norg.http4k.server.Jetty\n\n\nimport\n \norg.http4k.server.asServer\n\n\n\nfun\n \nmain\n(\nargs\n:\n \nArray\nString\n)\n \n{\n\n    \n// we can bind HttpHandlers (which are just functions from  Request -\n Response) to paths/methods to create a Route,\n\n    \n// then combine many Routes together to make another HttpHandler\n\n    \nval\n \napp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n        \n/ping\n \nbind\n \nGET\n \nto\n \n{\n \n_\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\npong!\n)\n \n},\n\n        \n/greet/{name}\n \nbind\n \nGET\n \nto\n \n{\n \nreq\n:\n \nRequest\n \n-\n\n            \nval\n \npath\n:\n \nString\n?\n \n=\n \nreq\n.\npath\n(\nname\n)\n\n            \nResponse\n(\nOK\n).\nbody\n(\nhello ${path ?: \nanon\n!\n}\n)\n\n        \n}\n\n    \n)\n\n\n    \n// call the handler in-memory without spinning up a server\n\n    \nval\n \ninMemoryResponse\n:\n \nResponse\n \n=\n \napp\n(\nRequest\n(\nGET\n,\n \n/greet/Bob\n))\n\n    \nprintln\n(\ninMemoryResponse\n)\n\n\n\n// Produces:\n\n\n//    HTTP/1.1 200 OK\n\n\n//\n\n\n//\n\n\n//    hello Bob\n\n\n    \n// this is a Filter - it performs pre/post processing on a request or response\n\n    \nval\n \ntimingFilter\n \n=\n \nFilter\n \n{\n\n        \nnext\n:\n \nHttpHandler\n \n-\n\n        \n{\n\n            \nrequest\n:\n \nRequest\n \n-\n\n            \nval\n \nstart\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n\n            \nval\n \nresponse\n \n=\n \nnext\n(\nrequest\n)\n\n            \nval\n \nlatency\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n \n-\n \nstart\n\n            \nprintln\n(\nRequest to ${request.uri} took ${latency}ms\n)\n\n            \nresponse\n\n        \n}\n\n    \n}\n\n\n    \n// we can \nstack\n filters to create reusable units, and then apply them to an HttpHandler\n\n    \nval\n \ncompositeFilter\n \n=\n \nCachingFilters\n.\nResponse\n.\nNoCache\n().\nthen\n(\ntimingFilter\n)\n\n    \nval\n \nfilteredApp\n:\n \nHttpHandler\n \n=\n \ncompositeFilter\n.\nthen\n(\napp\n)\n\n\n    \n// only 1 LOC to mount an app and start it in a container\n\n    \nfilteredApp\n.\nasServer\n(\nJetty\n(\n9000\n)).\nstart\n()\n\n\n    \n// HTTP clients are also HttpHandlers!\n\n    \nval\n \nclient\n:\n \nHttpHandler\n \n=\n \nOkHttp\n()\n\n\n    \nval\n \nnetworkResponse\n:\n \nResponse\n \n=\n \nclient\n(\nRequest\n(\nGET\n,\n \nhttp://localhost:9000/greet/Bob\n))\n\n    \nprintln\n(\nnetworkResponse\n)\n\n\n\n// Produces:\n\n\n//    Request to /api/greet/Bob took 1ms\n\n\n//    HTTP/1.1 200\n\n\n//    cache-control: private, must-revalidate\n\n\n//    content-length: 9\n\n\n//    date: Thu, 08 Jun 2.38.03:01:13 GMT\n\n\n//    expires: 0\n\n\n//    server: Jetty(9.3.16.v2.38.020)\n\n\n//\n\n\n//    hello Bob\n\n\n}\n\n\n\n\n\n\nAcknowledgments\n\n\n\n\nDan Bodart\n's \nutterlyidle\n\n\nIvan Moore\n for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\"\n\n\n\n\n\n\nContributors\n\n\nThis project exists thanks to all the people who \ncontribute\n.\n\n\n\nBackers \n Sponsors\n\n\nIf you use http4k in your project or enterprise and would like to support ongoing development, please consider becoming a backer or a sponsor. Sponsor logos will show up here with a link to your website.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#module-feature-overview", 
            "text": "Core:    Base HTTP handler and  immutable HTTP message  objects, cookie handling.   Commonly used HTTP functionalities provided as reusable Filters (caching, debugging,  Zipkin request tracing )  Path-based routing , including nestable contexts  Typesafe HTTP message construction/desconstruction and Request Contexts  using Lenses  Static file-serving  capability with  Caching and Hot-Reload    Servlet implementation to allow  \n-dependency plugin to any Servlet container  Launch applications in  1LOC  with an embedded  SunHttp  server backend (recommended for development use only)  APIs to  record and replay  HTTP traffic to disk or memory  Core  abstraction APIs  implemented by the other modules     Client:    1LOC  HTTP client adapters   Apache  OkHttp      Server:  1LOC  server backend spinup for:  Jetty  Netty  Undertow  SunHttp  (bundled with  http4k-core )    API design allows for plugging into configurable instances of each    Contracts:    Definite  Typesafe  HTTP contracts, defining required and optional path/query/header/bodies  Typesafe  path matching  Auto-validation  of incoming requests ==  zero boilerplate validation code  Self-documenting for all routes - eg. Built in support for live  OpenApi/Swagger  description endpoints including  JSON Schema  model breakdown.     Templating:    Pluggable  templating system support for:  Dust    Handlebars    Pebble  Thymeleaf    Caching and  Hot-Reload  template support    Message formats:    Consistent API provides first class support for marshalling JSON to/from HTTP messages for:  Jackson  - includes support for  fully  automatic marshalling  of Data classes )  Gson  - includes support for  fully  automatic marshalling  of Data classes )  Argo  - lightweight Java JSON API with zero dependencies.  Xml  - includes support for  one way  automatic marshalling  of Data classes )      Resilience:    Support for Circuits, Retrying, Rate-Limiting, Bulkheading via Resilience4J integration.    Multipart:    Support for Multipart HTML forms, including Lens extensions for type-safe marshalling of fields.    AWS:    Client filter to allow super-simple interaction with AWS services (via request signing)    WebDriver:    Ultra-lightweight Selenium WebDriver implementation for  http4k  application.    Hamkrest:    A set of Hamkrest matchers for testing  http4k  Request and Response messages.", 
            "title": "Module feature overview"
        }, 
        {
            "location": "/#example", 
            "text": "This quick example is designed to convey the simplicity   features of  http4k . See also the  quickstart  for the simplest possible starting point.  To install, add these dependencies to your  Gradle  file:  dependencies   { \n     compile   group:   org.http4k ,   name:   http4k-core ,   version:   2.38.0 \n     compile   group:   org.http4k ,   name:   http4k-server-jetty ,   version:   2.38.0 \n     compile   group:   org.http4k ,   name:   http4k-client-okhttp ,   version:   2.38.0  }   This \"Hello World\" style example demonstrates how to serve and consume HTTP services with dynamic routing:  package   cookbook  import   org.http4k.client.OkHttp  import   org.http4k.core.Filter  import   org.http4k.core.HttpHandler  import   org.http4k.core.Method.GET  import   org.http4k.core.Request  import   org.http4k.core.Response  import   org.http4k.core.Status.Companion.OK  import   org.http4k.core.then  import   org.http4k.filter.CachingFilters  import   org.http4k.routing.bind  import   org.http4k.routing.path  import   org.http4k.routing.routes  import   org.http4k.server.Jetty  import   org.http4k.server.asServer  fun   main ( args :   Array String )   { \n     // we can bind HttpHandlers (which are just functions from  Request -  Response) to paths/methods to create a Route, \n     // then combine many Routes together to make another HttpHandler \n     val   app :   HttpHandler   =   routes ( \n         /ping   bind   GET   to   {   _ :   Request   -   Response ( OK ). body ( pong! )   }, \n         /greet/{name}   bind   GET   to   {   req :   Request   - \n             val   path :   String ?   =   req . path ( name ) \n             Response ( OK ). body ( hello ${path ?:  anon ! } ) \n         } \n     ) \n\n     // call the handler in-memory without spinning up a server \n     val   inMemoryResponse :   Response   =   app ( Request ( GET ,   /greet/Bob )) \n     println ( inMemoryResponse )  // Produces:  //    HTTP/1.1 200 OK  //  //  //    hello Bob \n\n     // this is a Filter - it performs pre/post processing on a request or response \n     val   timingFilter   =   Filter   { \n         next :   HttpHandler   - \n         { \n             request :   Request   - \n             val   start   =   System . currentTimeMillis () \n             val   response   =   next ( request ) \n             val   latency   =   System . currentTimeMillis ()   -   start \n             println ( Request to ${request.uri} took ${latency}ms ) \n             response \n         } \n     } \n\n     // we can  stack  filters to create reusable units, and then apply them to an HttpHandler \n     val   compositeFilter   =   CachingFilters . Response . NoCache (). then ( timingFilter ) \n     val   filteredApp :   HttpHandler   =   compositeFilter . then ( app ) \n\n     // only 1 LOC to mount an app and start it in a container \n     filteredApp . asServer ( Jetty ( 9000 )). start () \n\n     // HTTP clients are also HttpHandlers! \n     val   client :   HttpHandler   =   OkHttp () \n\n     val   networkResponse :   Response   =   client ( Request ( GET ,   http://localhost:9000/greet/Bob )) \n     println ( networkResponse )  // Produces:  //    Request to /api/greet/Bob took 1ms  //    HTTP/1.1 200  //    cache-control: private, must-revalidate  //    content-length: 9  //    date: Thu, 08 Jun 2.38.03:01:13 GMT  //    expires: 0  //    server: Jetty(9.3.16.v2.38.020)  //  //    hello Bob  }", 
            "title": "Example"
        }, 
        {
            "location": "/#acknowledgments", 
            "text": "Dan Bodart 's  utterlyidle  Ivan Moore  for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\"", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/#contributors", 
            "text": "This project exists thanks to all the people who  contribute .", 
            "title": "Contributors"
        }, 
        {
            "location": "/#backers-sponsors", 
            "text": "If you use http4k in your project or enterprise and would like to support ongoing development, please consider becoming a backer or a sponsor. Sponsor logos will show up here with a link to your website.", 
            "title": "Backers &amp; Sponsors"
        }, 
        {
            "location": "/rationale/", 
            "text": "tldr;\n\n\nPresentation\n about the development of http4k given at the Kotlin London meetup.\n\n\nAbout\n\n\nhttp4k\n is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - \nthe routing module is inspired by \nUtterlyIdle\n, the \"Server as a function\" and filter model is stolen from \n\nFinagle\n, and the contract module OpenApi/Swagger generator is ported from \nFintrospect\n. With the growing \nadoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch.\n\n\nFor our purposes, we needed something that:\n\n\n\n\nStarts/stops ultra quickly.\n\n\nEasily testable outside of an HTTP container, and testing should require little to no custom infrastructure.\n\n\nProvides typesafe HTTP message deconstruction/construction (in this case via Lenses).\n\n\nAutomatically deals with contract breaches (missing/invalid params etc) to remove boilerplate.\n\n\nAbsolutely no magic involved: No reflection. No annotations.\n\n\nMinimal dependencies (apart from the Kotlin StdLib, \nhttp4k-core\n has zero).\n\n\nAutomatic generation of OpenApi/Swagger documentation (including JSON Schema models).\n\n\nHas a symmetric server/client API (\nHttpHandler\n should just be \nRequest -\n Response\n).\n\n\nHas immutable Request/Response objects.\n\n\n\n\nhttp4k\n ticks all of these boxes. \n\n\nIt allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers using a single line of code. The symmetric HTTP API also allows Filter chains (often called \"Middleware\" or \"Interceptors\" in other frameworks) to be constructed into reusable units/stacks for both \nserver and client sides (eg. logging/metrics/caching...) since they can be composed together for later use. \n\n\nAs a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests).\n\n\nScenarios such as \"what happens if this HTTP dependency continually takes \n 5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary.\n\n\nConcepts\n\n\n\n\nAll incoming and outgoing HTTP services are modelled as \nHttpHandler\n, which is modelled as \n(Request) -\n Response\n:\n\n\n\n\nval\n \nhandler\n:\n \nHttpHandler\n \n=\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n)\n \n}\n\n\n\n\n\n\n\n\nPre/post processing is done using a \nFilter\n, which is modelled as \n(HttpHandler) -\n HttpHandler\n. Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating \nHttpHandler\n - to yield \na decorated \nHttpHandl\ner\n:\n\n\n\n\n    \nval\n \nfilter\n:\n \nFilter\n \n=\n \nFilter\n \n{\n \nnext\n:\n \nHttpHandler\n \n-\n\n        \n{\n \nrequest\n:\n \nRequest\n \n-\n \nnext\n(\nrequest\n).\nheader\n(\nmy response header\n,\n \nvalue\n)\n \n}\n\n    \n}\n\n    \nval\n \ndecorated\n:\n \nHttpHandler\n \n=\n \nfilter\n.\nthen\n(\nhandler\n)\n\n\n\n\n\n\n\n\nBinding an \nHttpHandler\n to a path and HTTP verb yields a \nRoutingHttpHandler\n, which is both an \nHttpHandler\n and a\nRouter\n:\n\n\n\n\nval\n \nroute\n:\n \nRoutingHttpHandler\n \n=\n \n/path\n \nbind\n \nGET\n \nto\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou GET bob\n)\n \n}\n\n\n\n\n\n\n\n\nRoutingHttpHandler\ns can be grouped together:\n\n\n\n\nval\n \napp\n:\n \nRoutingHttpHandler\n \n=\n \nroutes\n(\n\n    \nbob\n \nbind\n \nGET\n \nto\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou GET bob\n)\n \n},\n\n    \nrita\n \nbind\n \nPOST\n \nto\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou POST rita\n)\n \n},\n\n    \nsue\n \nbind\n \nDELETE\n \nto\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou DELETE sue\n)\n \n}\n\n\n)\n\n\n\n\n\n\n\n\nA \nRouter\n is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next \nRouter\n in the list.\n\n\nRouters\n can be combined together (under particular context roots) to form another \nRoutingHttpHandler\n:\n\n\n\n\nval\n \nbigApp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n    \n/this\n \nbind\n \napp\n,\n \n    \n/other\n \nbind\n \napp\n\n\n)\n\n\n\n\n\n\n\n\nHttpHandlers\n can be bound to a container (to create an \nHttp4kServer\n) with 1 LOC. The decouples the server implementation from the business logic:\n\n\n\n\nval\n \njettyServer\n \n=\n \napp\n.\nasServer\n(\nJetty\n(\n9000\n)).\nstart\n()\n\n\n\n\n\n\n\n\nAn Http client is also a \nHttpHandler\n:\n\n\n\n\nval\n \nclient\n:\n \nHttpHandler\n \n=\n \nApacheClient\n()\n\n\n\n\n\n\n\n\nBecause the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other:\n\n\n\n\n    \nval\n \napp1\n:\n \nHttpHandler\n \n=\n \nMyApp1\n()\n\n    \nval\n \napp2\n:\n \nHttpHandler\n \n=\n \nMyApp2\n(\napp1\n)", 
            "title": "Rationale & Concepts"
        }, 
        {
            "location": "/rationale/#tldr", 
            "text": "Presentation  about the development of http4k given at the Kotlin London meetup.", 
            "title": "tldr;"
        }, 
        {
            "location": "/rationale/#about", 
            "text": "http4k  is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - \nthe routing module is inspired by  UtterlyIdle , the \"Server as a function\" and filter model is stolen from  Finagle , and the contract module OpenApi/Swagger generator is ported from  Fintrospect . With the growing \nadoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch.  For our purposes, we needed something that:   Starts/stops ultra quickly.  Easily testable outside of an HTTP container, and testing should require little to no custom infrastructure.  Provides typesafe HTTP message deconstruction/construction (in this case via Lenses).  Automatically deals with contract breaches (missing/invalid params etc) to remove boilerplate.  Absolutely no magic involved: No reflection. No annotations.  Minimal dependencies (apart from the Kotlin StdLib,  http4k-core  has zero).  Automatic generation of OpenApi/Swagger documentation (including JSON Schema models).  Has a symmetric server/client API ( HttpHandler  should just be  Request -  Response ).  Has immutable Request/Response objects.   http4k  ticks all of these boxes.   It allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers using a single line of code. The symmetric HTTP API also allows Filter chains (often called \"Middleware\" or \"Interceptors\" in other frameworks) to be constructed into reusable units/stacks for both \nserver and client sides (eg. logging/metrics/caching...) since they can be composed together for later use.   As a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests).  Scenarios such as \"what happens if this HTTP dependency continually takes   5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary.", 
            "title": "About"
        }, 
        {
            "location": "/rationale/#concepts", 
            "text": "All incoming and outgoing HTTP services are modelled as  HttpHandler , which is modelled as  (Request) -  Response :   val   handler :   HttpHandler   =   {   request :   Request   -   Response ( OK )   }    Pre/post processing is done using a  Filter , which is modelled as  (HttpHandler) -  HttpHandler . Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating  HttpHandler  - to yield \na decorated  HttpHandl\ner :        val   filter :   Filter   =   Filter   {   next :   HttpHandler   - \n         {   request :   Request   -   next ( request ). header ( my response header ,   value )   } \n     } \n     val   decorated :   HttpHandler   =   filter . then ( handler )    Binding an  HttpHandler  to a path and HTTP verb yields a  RoutingHttpHandler , which is both an  HttpHandler  and a Router :   val   route :   RoutingHttpHandler   =   /path   bind   GET   to   {   Response ( OK ). body ( you GET bob )   }    RoutingHttpHandler s can be grouped together:   val   app :   RoutingHttpHandler   =   routes ( \n     bob   bind   GET   to   {   Response ( OK ). body ( you GET bob )   }, \n     rita   bind   POST   to   {   Response ( OK ). body ( you POST rita )   }, \n     sue   bind   DELETE   to   {   Response ( OK ). body ( you DELETE sue )   }  )    A  Router  is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next  Router  in the list.  Routers  can be combined together (under particular context roots) to form another  RoutingHttpHandler :   val   bigApp :   HttpHandler   =   routes ( \n     /this   bind   app ,  \n     /other   bind   app  )    HttpHandlers  can be bound to a container (to create an  Http4kServer ) with 1 LOC. The decouples the server implementation from the business logic:   val   jettyServer   =   app . asServer ( Jetty ( 9000 )). start ()    An Http client is also a  HttpHandler :   val   client :   HttpHandler   =   ApacheClient ()    Because the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other:        val   app1 :   HttpHandler   =   MyApp1 () \n     val   app2 :   HttpHandler   =   MyApp2 ( app1 )", 
            "title": "Concepts"
        }, 
        {
            "location": "/installation/", 
            "text": "All \nhttp4k\n libraries are available on Maven Central and JCenter and are released under a single version. For the core module, add the following to your Gradle file:\n\n\ncompile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0", 
            "title": "Installation"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quickstart\n\n\nThis simple example demonstates how to serve and consume HTTP services using \nhttp4k\n. \n\n\nTo install, add these dependencies to your \nGradle\n file:\n\n\ndependencies\n \n{\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-core\n,\n \nversion:\n \n2.38.0\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-server-jetty\n,\n \nversion:\n \n2.38.0\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-client-apache\n,\n \nversion:\n \n2.38.0\n\n\n}\n\n\n\n\n\n\nThe following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it.\n\n\n\n\n\nSingle-line CD Bootstrap\n\n\nRun the single command in the readme of \nthis repo\n to create a HelloWorld \nhttp4k\n app with a full CD pipeline using Github -\n TravisCI -\n Heroku.\n\n\nWhy should I use this library?\n\n\nPresentation\n about the development of http4k given at the Kotlin London meetup.", 
            "title": "Getting started"
        }, 
        {
            "location": "/quickstart/#quickstart", 
            "text": "This simple example demonstates how to serve and consume HTTP services using  http4k .   To install, add these dependencies to your  Gradle  file:  dependencies   { \n     compile   group:   org.http4k ,   name:   http4k-core ,   version:   2.38.0 \n     compile   group:   org.http4k ,   name:   http4k-server-jetty ,   version:   2.38.0 \n     compile   group:   org.http4k ,   name:   http4k-client-apache ,   version:   2.38.0  }   The following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/quickstart/#single-line-cd-bootstrap", 
            "text": "Run the single command in the readme of  this repo  to create a HelloWorld  http4k  app with a full CD pipeline using Github -  TravisCI -  Heroku.", 
            "title": "Single-line CD Bootstrap"
        }, 
        {
            "location": "/quickstart/#why-should-i-use-this-library", 
            "text": "Presentation  about the development of http4k given at the Kotlin London meetup.", 
            "title": "Why should I use this library?"
        }, 
        {
            "location": "/guide/modules/core/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-core\", version: \"2.38.0\"\n\n\nAbout\n\n\nApart from Kotlin StdLib, the core module has ZERO dependencies and provides the following:\n\n\n\n\nImmutable versions of the HTTP spec objects (Request, Response, Cookies etc).\n\n\nHTTP handler and filter abstractions which models services as simple, composable functions.\n\n\nSimple routing implementation, plus \nHttpHandlerServlet\n to enable plugging into any Servlet engine. \n\n\nLens\n mechanism for typesafe destructuring and construction of HTTP messages.\n\n\nTypesafe Request Context operations using Lenses.\n\n\nAbstractions for Servers, Clients, JSON Message formats, Templating etc.\n\n\nSunHttp\n Single-LOC development Server-backend\n\n\nStatic file-serving capability with \nCaching\n and \nHot-Reload\n\n\nAPIs to \nrecord and replay\n HTTP traffic to disk or memory\n\n\n\n\nHttpHandlers\n\n\nIn \nhttp4k\n, an HTTP service is just a typealias of a simple function:\n\n\ntypealias\n \nHttpHandler\n \n=\n \n(\nRequest\n)\n \n-\n \nResponse\n\n\n\n\n\n\nFirst described in this Twitter paper \n\"Your Server as a Function\"\n, this abstraction allows us lots of \nflexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an \nHttpHandler\n, neither do we \nneed to launch a real HTTP container to exercise it:\n\n\nval\n \nhandler\n \n=\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello, ${request.query(\nname\n)}!\n)\n \n}\n\n\nval\n \nget\n \n=\n \nRequest\n(\nMethod\n.\nGET\n,\n \n/\n).\nquery\n(\nname\n,\n \nJohn Doe\n)\n\n\nval\n \nresponse\n \n=\n \napp\n(\nget\n)\n\n\n\nprintln\n(\nresponse\n.\nstatus\n)\n\n\nprintln\n(\nresponse\n.\nbodyString\n())\n\n\n\n\n\n\nTo mount the \nHttpHandler\n in a container, the can simply be converted to a Servlet by calling \nhandler.asServlet()\n\n\nFilters\n\n\nFilters add extra processing to either the Request or Response. In \nhttp4k\n, they are modelled as:\n\n\ninterface\n \nFilter\n \n:\n \n(\nHttpHandler\n)\n \n-\n \nHttpHandler\n\n\n\n\n\n\nFilters are designed to simply compose together (using \nthen()\n) , creating reusable stacks of behaviour which can then be applied to any \nHttpHandler\n. \nFor example, to add Basic Auth and latency reporting to a service:\n\n\nval\n \nhandler\n \n=\n \n{\n \n_\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n)\n \n}\n\n\n\nval\n \nmyFilter\n \n=\n \nFilter\n \n{\n\n    \nnext\n:\n \nHttpHandler\n \n-\n \n{\n\n        \nrequest\n:\n \nRequest\n \n-\n \n            \nval\n \nstart\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n\n            \nval\n \nresponse\n \n=\n \nnext\n(\nit\n)\n\n            \nval\n \nlatency\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n \n-\n \nstart\n\n            \nprintln\n(\nI took $latency ms\n)\n\n            \nresponse\n\n    \n}\n\n\n}\n\n\nval\n \nlatencyAndBasicAuth\n:\n \nHttpHandler\n \n=\n \nServerFilters\n.\nBasicAuth\n(\nmy realm\n,\n \nuser\n,\n \npassword\n).\nthen\n(\nmyFilter\n)\n\n\nval\n \napp\n:\n \nHttpHandler\n \n=\n \nlatencyAndBasicAuth\n.\nthen\n(\nhandler\n)\n\n\n\n\n\n\nThe \nhttp4k-core\n module comes with a set of handy Filters for application to both Server and Client \nHttpHandlers\n, covering common things like:\n\n\n\n\nRequest tracing headers (x-b3-traceid etc)\n\n\nBasic Auth\n\n\nCache Control\n\n\nCORS\n\n\nCookie handling\n\n\nDebugging request and responses\n\n\n\n\nCheck out the \norg.http4k.filter\n package for the exact list.\n\n\nRouters - Nestable, path-based Routing\n\n\nCreate a Router using routes() to bind a static or dynamic path to either an HttpHandler, or to another sub-Router. These Routers can be nested infinitely deep and \nhttp4k\n will search for a matching route using a depth-first search algorithm, before falling back finally to a 404:\n\n\nroutes\n(\n\n    \n/hello\n \nbind\n \nroutes\n(\n\n        \n/{name:*}\n \nbind\n \nGET\n \nto\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello, ${request.path(\nname\n)}!\n)\n \n}\n\n    \n),\n\n    \n/fail\n \nbind\n \nPOST\n \nto\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nINTERNAL_SERVER_ERROR\n)\n \n}\n\n\n).\nasServer\n(\nJetty\n(\n8000\n)).\nstart\n()\n\n\n\n\n\n\nNote that the \nhttp4k-contract\n module contains a more typesafe implementation of routing functionality, with runtime-generated live documentation in OpenApi/Swagger format.\n\n\nTypesafe parameter destructuring/construction of HTTP messages with Lenses\n\n\nGetting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. \nFor this purpose, we can use a \nLens\n. \n\n\nA Lens is a bi-directional entity which can be used to either \nget\n or \nset\n a particular value from/onto an HTTP message. \nhttp4k\n provides a DSL \nto configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional). \n\n\nTo utilise a lens, first you have to declare it with the form \nLocation\n.\nconfiguration and mapping operations\n.\nterminator\n.\n\n\nThere is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location:\n\n\n\n\n\n\n\n\nLocation\n\n\nStarting type\n\n\nApplicable to\n\n\nMultiplicity\n\n\nRequirement terminator\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nQuery\n\n\nString\n\n\nRequest\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nQuery.optional(\"name\")\nQuery.required(\"name\")\nQuery.int().required(\"name\")\nQuery.localDate().multi.required(\"name\")\nQuery.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nHeader\n\n\nString\n\n\nRequest\n or \nResponse\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nHeader.optional(\"name\")\nHeader.required(\"name\")\nHeader.int().required(\"name\")\nHeader.localDate().multi.required(\"name\")\nHeader.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nPath\n\n\nString\n\n\nRequest\n\n\nSingular\n\n\nRequired\n\n\nPath.of(\"name\")\nPath.int().of(\"name\")\nPath.map(::CustomType, { it.value }).of(\"name\")\n\n\n\n\n\n\nFormField\n\n\nString\n\n\nWebForm\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nFormField.optional(\"name\")\nFormField.required(\"name\")\nFormField.int().required(\"name\")\nFormField.localDate().multi.required(\"name\")\nFormField.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nBody\n\n\nByteBuffer\n\n\nRequest\n or \nResponse\n\n\nSingular\n\n\nRequired\n\n\nBody.string(ContentType.TEXT_PLAIN).toLens()\nBody.json().toLens()\nBody.webForm(Validator.Strict, FormField.required(\"name\")).toLens()\n\n\n\n\n\n\n\n\nOnce the lens is declared, you can use it on a target object to either get or set the value:\n\n\n\n\nRetrieving a value: use \nlens\n.extract(\ntarget\n)\n, or the more concise invoke form: \nlens\n(\ntarget\n)\n\n\nSetting a value: use \nlens\n.inject(\nvalue\n, \ntarget\n)\n, or the more concise invoke form: \nlens\n(\nvalue\n, \ntarget\n)\n\n\n\n\n\n\n\nServing static assets\n\n\nFor serving static assets, just bind a path to a Static block as below, using either a Classpath or HotReload based ResourceLoader instance. Typically, HotReload is used during development and the Classpath strategy is used to serve assets in production from an UberJar. This is usually based on a \"devmode\" flag when constructing your app\":\n\n\nroutes\n(\n\n    \n/static\n \nbind\n \nstatic\n(\nClasspath\n(\norg.http4k.some.package.name\n))\n\n    \n/hotreload\n \nbind\n \nstatic\n(\nHotReload\n(\npath/to/static/dir/goes/here\n))\n\n\n)\n\n\n\n\n\n\nRequest and Response toString()\n\n\nThe HttpMessages used by \nhttp4k\n toString in the HTTP wire format, which it simple to capture and replay HTTP message streams later in a similar way to tools like \nMountebank\n.\n\n\nCURL format\n\n\nCreates \ncurl\n command for a given request - this is useful to include in audit logs so exact requests can be replayed if required:\n\n\nval\n \ncurl\n \n=\n \nRequest\n(\nPOST\n,\n \nhttp://httpbin.org/post\n).\nbody\n(\nlistOf\n(\nfoo\n \nto\n \nbar\n).\ntoBody\n()).\ntoCurl\n()\n\n\n// curl -X POST --data \nfoo=bar\n \nhttp://httpbin.org/post", 
            "title": "Core"
        }, 
        {
            "location": "/guide/modules/core/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-core\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/core/#about", 
            "text": "Apart from Kotlin StdLib, the core module has ZERO dependencies and provides the following:   Immutable versions of the HTTP spec objects (Request, Response, Cookies etc).  HTTP handler and filter abstractions which models services as simple, composable functions.  Simple routing implementation, plus  HttpHandlerServlet  to enable plugging into any Servlet engine.   Lens  mechanism for typesafe destructuring and construction of HTTP messages.  Typesafe Request Context operations using Lenses.  Abstractions for Servers, Clients, JSON Message formats, Templating etc.  SunHttp  Single-LOC development Server-backend  Static file-serving capability with  Caching  and  Hot-Reload  APIs to  record and replay  HTTP traffic to disk or memory", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/core/#httphandlers", 
            "text": "In  http4k , an HTTP service is just a typealias of a simple function:  typealias   HttpHandler   =   ( Request )   -   Response   First described in this Twitter paper  \"Your Server as a Function\" , this abstraction allows us lots of \nflexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an  HttpHandler , neither do we \nneed to launch a real HTTP container to exercise it:  val   handler   =   {   request :   Request   -   Response ( OK ). body ( Hello, ${request.query( name )}! )   }  val   get   =   Request ( Method . GET ,   / ). query ( name ,   John Doe )  val   response   =   app ( get )  println ( response . status )  println ( response . bodyString ())   To mount the  HttpHandler  in a container, the can simply be converted to a Servlet by calling  handler.asServlet()", 
            "title": "HttpHandlers"
        }, 
        {
            "location": "/guide/modules/core/#filters", 
            "text": "Filters add extra processing to either the Request or Response. In  http4k , they are modelled as:  interface   Filter   :   ( HttpHandler )   -   HttpHandler   Filters are designed to simply compose together (using  then() ) , creating reusable stacks of behaviour which can then be applied to any  HttpHandler . \nFor example, to add Basic Auth and latency reporting to a service:  val   handler   =   {   _ :   Request   -   Response ( OK )   }  val   myFilter   =   Filter   { \n     next :   HttpHandler   -   { \n         request :   Request   -  \n             val   start   =   System . currentTimeMillis () \n             val   response   =   next ( it ) \n             val   latency   =   System . currentTimeMillis ()   -   start \n             println ( I took $latency ms ) \n             response \n     }  }  val   latencyAndBasicAuth :   HttpHandler   =   ServerFilters . BasicAuth ( my realm ,   user ,   password ). then ( myFilter )  val   app :   HttpHandler   =   latencyAndBasicAuth . then ( handler )   The  http4k-core  module comes with a set of handy Filters for application to both Server and Client  HttpHandlers , covering common things like:   Request tracing headers (x-b3-traceid etc)  Basic Auth  Cache Control  CORS  Cookie handling  Debugging request and responses   Check out the  org.http4k.filter  package for the exact list.", 
            "title": "Filters"
        }, 
        {
            "location": "/guide/modules/core/#routers-nestable-path-based-routing", 
            "text": "Create a Router using routes() to bind a static or dynamic path to either an HttpHandler, or to another sub-Router. These Routers can be nested infinitely deep and  http4k  will search for a matching route using a depth-first search algorithm, before falling back finally to a 404:  routes ( \n     /hello   bind   routes ( \n         /{name:*}   bind   GET   to   {   request :   Request   -   Response ( OK ). body ( Hello, ${request.path( name )}! )   } \n     ), \n     /fail   bind   POST   to   {   request :   Request   -   Response ( INTERNAL_SERVER_ERROR )   }  ). asServer ( Jetty ( 8000 )). start ()   Note that the  http4k-contract  module contains a more typesafe implementation of routing functionality, with runtime-generated live documentation in OpenApi/Swagger format.", 
            "title": "Routers - Nestable, path-based Routing"
        }, 
        {
            "location": "/guide/modules/core/#typesafe-parameter-destructuringconstruction-of-http-messages-with-lenses", 
            "text": "Getting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. \nFor this purpose, we can use a  Lens .   A Lens is a bi-directional entity which can be used to either  get  or  set  a particular value from/onto an HTTP message.  http4k  provides a DSL \nto configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional).   To utilise a lens, first you have to declare it with the form  Location . configuration and mapping operations . terminator .  There is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location:     Location  Starting type  Applicable to  Multiplicity  Requirement terminator  Examples      Query  String  Request  Singular or multiple  Optional or Required  Query.optional(\"name\") Query.required(\"name\") Query.int().required(\"name\") Query.localDate().multi.required(\"name\") Query.map(::CustomType, { it.value }).required(\"name\")    Header  String  Request  or  Response  Singular or multiple  Optional or Required  Header.optional(\"name\") Header.required(\"name\") Header.int().required(\"name\") Header.localDate().multi.required(\"name\") Header.map(::CustomType, { it.value }).required(\"name\")    Path  String  Request  Singular  Required  Path.of(\"name\") Path.int().of(\"name\") Path.map(::CustomType, { it.value }).of(\"name\")    FormField  String  WebForm  Singular or multiple  Optional or Required  FormField.optional(\"name\") FormField.required(\"name\") FormField.int().required(\"name\") FormField.localDate().multi.required(\"name\") FormField.map(::CustomType, { it.value }).required(\"name\")    Body  ByteBuffer  Request  or  Response  Singular  Required  Body.string(ContentType.TEXT_PLAIN).toLens() Body.json().toLens() Body.webForm(Validator.Strict, FormField.required(\"name\")).toLens()     Once the lens is declared, you can use it on a target object to either get or set the value:   Retrieving a value: use  lens .extract( target ) , or the more concise invoke form:  lens ( target )  Setting a value: use  lens .inject( value ,  target ) , or the more concise invoke form:  lens ( value ,  target )", 
            "title": "Typesafe parameter destructuring/construction of HTTP messages with Lenses"
        }, 
        {
            "location": "/guide/modules/core/#serving-static-assets", 
            "text": "For serving static assets, just bind a path to a Static block as below, using either a Classpath or HotReload based ResourceLoader instance. Typically, HotReload is used during development and the Classpath strategy is used to serve assets in production from an UberJar. This is usually based on a \"devmode\" flag when constructing your app\":  routes ( \n     /static   bind   static ( Classpath ( org.http4k.some.package.name )) \n     /hotreload   bind   static ( HotReload ( path/to/static/dir/goes/here ))  )", 
            "title": "Serving static assets"
        }, 
        {
            "location": "/guide/modules/core/#request-and-response-tostring", 
            "text": "The HttpMessages used by  http4k  toString in the HTTP wire format, which it simple to capture and replay HTTP message streams later in a similar way to tools like  Mountebank .", 
            "title": "Request and Response toString()"
        }, 
        {
            "location": "/guide/modules/core/#curl-format", 
            "text": "Creates  curl  command for a given request - this is useful to include in audit logs so exact requests can be replayed if required:  val   curl   =   Request ( POST ,   http://httpbin.org/post ). body ( listOf ( foo   to   bar ). toBody ()). toCurl ()  // curl -X POST --data  foo=bar   http://httpbin.org/post", 
            "title": "CURL format"
        }, 
        {
            "location": "/guide/modules/servers/", 
            "text": "Installation (Gradle)\n\n\nSunHttp (for development only):\n \ncompile group: \"org.http4k\", name: \"http4k-core\", version: \"2.38.0\"\n\n\nJetty:\n \ncompile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"2.38.0\"\n\n\nNetty:\n \ncompile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"2.38.0\"\n\n\nUndertow:\n \ncompile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"2.38.0\"\n\n\nAbout\n\n\nServer-backend modules provide a consistent API mount HttpHandlers into the specified container in 1 LOC, by simply passing a \nServerConfig\n implementation (in this case \nJetty\n):\n\n\n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello World\n)\n \n}.\nasServer\n(\nJetty\n(\n8000\n)).\nstart\n().\nblock\n()\n\n\n\n\n\n\nAlteratively, all server-backend modules allow for plugging \nhttp4k\n handlers into the relevant server API, which allows for custom Server configuration.", 
            "title": "Server backend"
        }, 
        {
            "location": "/guide/modules/servers/#installation-gradle", 
            "text": "SunHttp (for development only):   compile group: \"org.http4k\", name: \"http4k-core\", version: \"2.38.0\"  Jetty:   compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"2.38.0\"  Netty:   compile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"2.38.0\"  Undertow:   compile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/servers/#about", 
            "text": "Server-backend modules provide a consistent API mount HttpHandlers into the specified container in 1 LOC, by simply passing a  ServerConfig  implementation (in this case  Jetty ):  {   request :   Request   -   Response ( OK ). body ( Hello World )   }. asServer ( Jetty ( 8000 )). start (). block ()   Alteratively, all server-backend modules allow for plugging  http4k  handlers into the relevant server API, which allows for custom Server configuration.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/clients/", 
            "text": "Installation (Gradle)\n\n\nApache:\n \ncompile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"2.38.0\"\n\n\nOkHttp:\n \ncompile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"2.38.0\"\n\n\nAbout\n\n\nSupported HTTP client adapter APIs are wrapped to provide an \nHttpHandler\n interface in 1 LOC.\n\n\nActivate streaming mode by passing a \nBodyMode\n (default is non-streaming).\n\n\nThese examples are for the Apache HTTP client, but the API is similar for the others:\n\n\n\n\n\nAlternatively, all client adapter modules allow for custom configuration of the relevant Client configuration by", 
            "title": "HTTP client"
        }, 
        {
            "location": "/guide/modules/clients/#installation-gradle", 
            "text": "Apache:   compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"2.38.0\"  OkHttp:   compile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/clients/#about", 
            "text": "Supported HTTP client adapter APIs are wrapped to provide an  HttpHandler  interface in 1 LOC.  Activate streaming mode by passing a  BodyMode  (default is non-streaming).  These examples are for the Apache HTTP client, but the API is similar for the others:   Alternatively, all client adapter modules allow for custom configuration of the relevant Client configuration by", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/message_formats/", 
            "text": "Installation (Gradle)\n\n\nArgo:\n  \ncompile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"2.38.0\"\n\n\nGson:\n  \ncompile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"2.38.0\"\n\n\nJackson:\n \ncompile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"2.38.0\"\n\n\nXml:\n \ncompile group: \"org.http4k\", name: \"http4k-format-xml\", version: \"2.38.0\"\n\n\nAbout\n\n\nThese modules add the ability to use JSON/XML as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of \nstandard methods and extension methods for converting common types into native JSON/XML objects, including custom Lens methods for each library so that \nJSON/XML node objects can be written and read directly from HTTP messages:\n\n\n\n\n\nAuto-marshalling capabilities\n\n\nSome of the message libraries (eg. GSON, Jackson, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection.\n\n\nWe can use this facility in \nhttp4k\n to automatically marshall objects to/from HTTP message bodies using \nLenses\n:\n\n\nJSON\n\n\n\n\n\nXML\n\n\n\n\n\nThere is a utility to generate Kotlin code for JSON and XML data class code \nhere\n . These data classes are compatible with using the \nBody.auto\nT\n()\n functionality. \n\n\nFAQ (aka gotchas) regarding Auto-marshalling capabilities\n\n\nUppercase JSON key names\n\n\nThe Jackson version of the automarshalling does NOT work for objects with uppercase key names - this is a known issue with the Jackson library and we are unable to fix it. Either use the GSON alternative, or annotate your Data class fields with \nJsonAlias\n annotations to work around this.\n\n\nJSON arrays\n\n\nWhen handling raw JSON array messages, such as: \n[123, 456, 567]\n, there is a slight gotcha when auto-marshalling messages from JSON.\n\n\nThis is demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list.\n\n\nAs shown, a workaround to this is to use \nBody.auto\nArray\nMyIntWrapper\n().toLens()\n instead, and then compare using \nArrays.equal()", 
            "title": "Message formats"
        }, 
        {
            "location": "/guide/modules/message_formats/#installation-gradle", 
            "text": "Argo:    compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"2.38.0\"  Gson:    compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"2.38.0\"  Jackson:   compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"2.38.0\"  Xml:   compile group: \"org.http4k\", name: \"http4k-format-xml\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/message_formats/#about", 
            "text": "These modules add the ability to use JSON/XML as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of \nstandard methods and extension methods for converting common types into native JSON/XML objects, including custom Lens methods for each library so that \nJSON/XML node objects can be written and read directly from HTTP messages:", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/message_formats/#auto-marshalling-capabilities", 
            "text": "Some of the message libraries (eg. GSON, Jackson, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection.  We can use this facility in  http4k  to automatically marshall objects to/from HTTP message bodies using  Lenses :", 
            "title": "Auto-marshalling capabilities"
        }, 
        {
            "location": "/guide/modules/message_formats/#json", 
            "text": "", 
            "title": "JSON"
        }, 
        {
            "location": "/guide/modules/message_formats/#xml", 
            "text": "There is a utility to generate Kotlin code for JSON and XML data class code  here  . These data classes are compatible with using the  Body.auto T ()  functionality.", 
            "title": "XML"
        }, 
        {
            "location": "/guide/modules/message_formats/#faq-aka-gotchas-regarding-auto-marshalling-capabilities", 
            "text": "", 
            "title": "FAQ (aka gotchas) regarding Auto-marshalling capabilities"
        }, 
        {
            "location": "/guide/modules/message_formats/#uppercase-json-key-names", 
            "text": "The Jackson version of the automarshalling does NOT work for objects with uppercase key names - this is a known issue with the Jackson library and we are unable to fix it. Either use the GSON alternative, or annotate your Data class fields with  JsonAlias  annotations to work around this.", 
            "title": "Uppercase JSON key names"
        }, 
        {
            "location": "/guide/modules/message_formats/#json-arrays", 
            "text": "When handling raw JSON array messages, such as:  [123, 456, 567] , there is a slight gotcha when auto-marshalling messages from JSON.  This is demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list.  As shown, a workaround to this is to use  Body.auto Array MyIntWrapper ().toLens()  instead, and then compare using  Arrays.equal()", 
            "title": "JSON arrays"
        }, 
        {
            "location": "/guide/modules/templating/", 
            "text": "Installation (Gradle)\n\n\nDust:\n \ncompile group: \"org.http4k\", name: \"http4k-template-dust\", version: \"2.38.0\"\n\n\nHandlebars:\n \ncompile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"2.38.0\"\n\n\nPebble:\n \ncompile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"2.38.0\"\n\n\nThymeleaf:\n \ncompile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"2.38.0\"\n\n\nAbout\n\n\nThe \nhttp4k\n templating API provides a standard mechanism for rendering using common templating libraries. Simply implement the \nViewModel\n interface on a model class and pass it to the renderer to get a string. All of the implementations support view rendering using the following strategies:\n\n\n\n\nCached on the classpath\n\n\nCached from the filesystem\n\n\nHot-Reloading from the filesystem\n\n\n\n\nThe examples below are for Handlebars, but the others have the same APIs:", 
            "title": "Templating"
        }, 
        {
            "location": "/guide/modules/templating/#installation-gradle", 
            "text": "Dust:   compile group: \"org.http4k\", name: \"http4k-template-dust\", version: \"2.38.0\"  Handlebars:   compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"2.38.0\"  Pebble:   compile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"2.38.0\"  Thymeleaf:   compile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/templating/#about", 
            "text": "The  http4k  templating API provides a standard mechanism for rendering using common templating libraries. Simply implement the  ViewModel  interface on a model class and pass it to the renderer to get a string. All of the implementations support view rendering using the following strategies:   Cached on the classpath  Cached from the filesystem  Hot-Reloading from the filesystem   The examples below are for Handlebars, but the others have the same APIs:", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/contracts/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-contract\", version: \"2.38.0\"\n\n\nAbout\n\n\nThe \nhttp4k-contract\n module adds a much more sophisticated routing mechanism to that available in \nhttp4k-core\n. It adds the facility \nto declare server-side \nRoutes\n in a completely typesafe way, leveraging the Lens functionality from the core. These \nRoutes\n are \ncombined into \nRouteModules\n, which have the following features:\n\n\n\n\nAuto-validating\n - the \nRoute\n contract is automatically validated on each call for required-fields and type conversions, removing the requirement  for any validation code to be written by the API user. Invalid calls result in a \nHTTP 400\n (BAD_REQUEST)\n response.     \n\n\nSelf-describing:\n - a generated endpoint is provided which describes all of the \nRoutes\n in that module. Implementations include \nOpenApi/Swagger\n documentation, including generation of [JSON schema]\n(http://json-schema.org/) models for messages.\n\n\nSecurity:\n to secure the \nRoutes\n  against unauthorised access. Current implementations include \nApiKey\n.\n\n\n\n\n\n\n\nWhen launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module.\n\n\nFor a more extended example, see the following example apps: \n\n\n\n\nTodo backend (typesafe contract version)\n\n\nTDD'd example application", 
            "title": "Typesafe contracts"
        }, 
        {
            "location": "/guide/modules/contracts/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-contract\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/contracts/#about", 
            "text": "The  http4k-contract  module adds a much more sophisticated routing mechanism to that available in  http4k-core . It adds the facility \nto declare server-side  Routes  in a completely typesafe way, leveraging the Lens functionality from the core. These  Routes  are \ncombined into  RouteModules , which have the following features:   Auto-validating  - the  Route  contract is automatically validated on each call for required-fields and type conversions, removing the requirement  for any validation code to be written by the API user. Invalid calls result in a  HTTP 400\n (BAD_REQUEST)  response.       Self-describing:  - a generated endpoint is provided which describes all of the  Routes  in that module. Implementations include  OpenApi/Swagger  documentation, including generation of [JSON schema]\n(http://json-schema.org/) models for messages.  Security:  to secure the  Routes   against unauthorised access. Current implementations include  ApiKey .    When launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module.  For a more extended example, see the following example apps:    Todo backend (typesafe contract version)  TDD'd example application", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/aws/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-aws\", version: \"2.38.0\"\n\n\nAbout\n\n\nThis module provides super-simple AWS request signing functionality for talking to AWS services. This is implemented as a standard \nFilter\n which can be used to wrap a standard \nHttpHandler\n client:", 
            "title": "AWS"
        }, 
        {
            "location": "/guide/modules/aws/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-aws\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/aws/#about", 
            "text": "This module provides super-simple AWS request signing functionality for talking to AWS services. This is implemented as a standard  Filter  which can be used to wrap a standard  HttpHandler  client:", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/multipart/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-multipart\", version: \"2.38.0\"\n\n\nAbout\n\n\nMultipart form support for fields and files, including a set of lens extensions for fields/files.\n\n\nSee the \ncookbook\n for example use.", 
            "title": "Multipart forms"
        }, 
        {
            "location": "/guide/modules/multipart/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-multipart\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/multipart/#about", 
            "text": "Multipart form support for fields and files, including a set of lens extensions for fields/files.  See the  cookbook  for example use.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/resilience/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-resilience4j\", version: \"2.38.0\"\n\n\nAbout\n\n\nThis module provides configurable Filters to provide CircuitBreaking, RateLimiting, Retrying and Bulkheading, by integrating with the awesome \nResilience4J\n library.\n\n\nCircuit Breaking\n\n\nA Circuit Filter detects failures and then Opens for a set period to allow the underlying system to recover.\n\n\n\n\n\nRate Limiting\n\n\nA RateLimit Filter monitors the number of requests over a set window.\n\n\n\n\n\nRetrying\n\n\nA Retrying Filter retries requests if a failure is generated.\n\n\n\n\n\nBulkheading\n\n\nA Bulkhead Filter limits the amount of parallel calls that can be executed.", 
            "title": "Resilience"
        }, 
        {
            "location": "/guide/modules/resilience/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-resilience4j\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/resilience/#about", 
            "text": "This module provides configurable Filters to provide CircuitBreaking, RateLimiting, Retrying and Bulkheading, by integrating with the awesome  Resilience4J  library.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/resilience/#circuit-breaking", 
            "text": "A Circuit Filter detects failures and then Opens for a set period to allow the underlying system to recover.", 
            "title": "Circuit Breaking"
        }, 
        {
            "location": "/guide/modules/resilience/#rate-limiting", 
            "text": "A RateLimit Filter monitors the number of requests over a set window.", 
            "title": "Rate Limiting"
        }, 
        {
            "location": "/guide/modules/resilience/#retrying", 
            "text": "A Retrying Filter retries requests if a failure is generated.", 
            "title": "Retrying"
        }, 
        {
            "location": "/guide/modules/resilience/#bulkheading", 
            "text": "A Bulkhead Filter limits the amount of parallel calls that can be executed.", 
            "title": "Bulkheading"
        }, 
        {
            "location": "/guide/modules/hamkrest/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-testing-hamkrest\", version: \"2.38.0\"\n\n\nAbout\n\n\nA set of Hamkrest matchers for use when testing \nhttp4k\n apps.", 
            "title": "Hamkrest"
        }, 
        {
            "location": "/guide/modules/hamkrest/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-testing-hamkrest\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/hamkrest/#about", 
            "text": "A set of Hamkrest matchers for use when testing  http4k  apps.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/webdriver/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-testing-webdriver\", version: \"2.38.0\"\n\n\nAbout\n\n\nA basic Selenium WebDriver API implementation for \nhttp4k\n HttpHandlers, which runs completely out of container (no network) for ultra fast tests.\n\n\n\n\n\n\n\n\nFeature\n\n\nSupported\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nNavigation\n\n\nyes\n\n\nsimple back/forward/refresh history\n\n\n\n\n\n\nCSS selectors\n\n\nyes\n\n\n\n\n\n\n\n\nLink navigation\n\n\nyes\n\n\n\n\n\n\n\n\nForm field entry and submission\n\n\nyes\n\n\n\n\n\n\n\n\nCookie storage\n\n\nyes\n\n\nmanual expiry management\n\n\n\n\n\n\nJavaScript\n\n\nno\n\n\n\n\n\n\n\n\nAlerts\n\n\nno\n\n\n\n\n\n\n\n\nScreenshots\n\n\nno\n\n\n\n\n\n\n\n\nFrames\n\n\nno\n\n\n\n\n\n\n\n\nMultiple windows\n\n\nno\n\n\n\n\n\n\n\n\n\n\nUse the API like any other WebDriver implementation, by simply passing your app HttpHandler to construct it:", 
            "title": "WebDriver"
        }, 
        {
            "location": "/guide/modules/webdriver/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-testing-webdriver\", version: \"2.38.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/webdriver/#about", 
            "text": "A basic Selenium WebDriver API implementation for  http4k  HttpHandlers, which runs completely out of container (no network) for ultra fast tests.     Feature  Supported  Notes      Navigation  yes  simple back/forward/refresh history    CSS selectors  yes     Link navigation  yes     Form field entry and submission  yes     Cookie storage  yes  manual expiry management    JavaScript  no     Alerts  no     Screenshots  no     Frames  no     Multiple windows  no      Use the API like any other WebDriver implementation, by simply passing your app HttpHandler to construct it:", 
            "title": "About"
        }, 
        {
            "location": "/guide/testing/", 
            "text": "The creators of \nhttp4k\n takes testing very seriously - so seriously that there really isn't that much to say here! \nThe API has been designed to make it as simple as possible to test both individual endpoints and entire applications in a consistent fashion, which is aided by remembering that:\n\n\n\n\nThe input and output \nRequest/Response\n objects are immutable.\n\n\nHttpHandlers\n are just functions.\n\n\nAn entire \nhttp4k\n application is \njust\n an \nHttpHandler\n.\n\n\n\n\nBecause of the above, there really isn't much required in the way of \"testing infrastructure\" - no magic containers or test fixtures that you might find in other frameworks. \nTesting is just matter of calling the correct function! Additionally, because the server and client HttpHandler interfaces are symmetrical - moving between in and out of container contexts \n(or indeed even to another HTTP framework entirely) is just a matter of switching out the HttpHandler implementation from the constructed app (out of container) to an HTTP client (in-container).\n\n\nThat said, possibly the most useful thing is to demonstrate the process that we have developed to test micro-services. A simple example of the development process can be found \n\nhere\n.\n\n\nTesting modules\n\n\nWe have developed the following modules to help with testing:\n\n\n\n\nhttp4k-testing-hamkrest\n: a set of composable Hamkrest matchers for matching \nhttp4k\n message objects against.\n\n\nhttp4k-testing-webdriver\n: an ultra-lightweight Selenium WebDriver implementation which can be used to test-drive \nhttp4k\n apps (ie. HttpHandlers).\n\n\n\n\nExample code for testing\n\n\nTesting HttpHandlers with static paths\n\n\n\n\nTesting HttpHandlers with dynamic paths\n\n\n\n\nTesting Filters", 
            "title": "Application Testing"
        }, 
        {
            "location": "/guide/testing/#testing-modules", 
            "text": "We have developed the following modules to help with testing:   http4k-testing-hamkrest : a set of composable Hamkrest matchers for matching  http4k  message objects against.  http4k-testing-webdriver : an ultra-lightweight Selenium WebDriver implementation which can be used to test-drive  http4k  apps (ie. HttpHandlers).", 
            "title": "Testing modules"
        }, 
        {
            "location": "/guide/testing/#example-code-for-testing", 
            "text": "", 
            "title": "Example code for testing"
        }, 
        {
            "location": "/guide/testing/#testing-httphandlers-with-static-paths", 
            "text": "", 
            "title": "Testing HttpHandlers with static paths"
        }, 
        {
            "location": "/guide/testing/#testing-httphandlers-with-dynamic-paths", 
            "text": "", 
            "title": "Testing HttpHandlers with dynamic paths"
        }, 
        {
            "location": "/guide/testing/#testing-filters", 
            "text": "", 
            "title": "Testing Filters"
        }, 
        {
            "location": "/guide/example/", 
            "text": "Application Design\n\n\nWhat follows is a guide to \nhow\n we build \nhttp4k\n applications test first to provide excellent test coverage driven by decoupled tests. \n\n\nFor this example, we will use an example of a Maths app with the following requirements:\n\n\n\n\nThe app must add 2 numbers together via an HTTP call\n\n\nThe app must multiply 2 numbers together via an HTTP call\n\n\nAnswers generated by the service will be logged (via HTTP POST) to another server - the Recorder.\n\n\n\n\nApps can generally be split into 3 tiers:\n\n\n\n\nEndpoint: \nHttpHandlers\n are constructed individually, by providing a builder function which takes the business-level dependencies. \n\n\nApplication: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier.\n\n\nServer: Builder function which takes the configuration for environmental concerns such as ports and downstream urls.", 
            "title": "Introduction"
        }, 
        {
            "location": "/guide/example/#application-design", 
            "text": "What follows is a guide to  how  we build  http4k  applications test first to provide excellent test coverage driven by decoupled tests.   For this example, we will use an example of a Maths app with the following requirements:   The app must add 2 numbers together via an HTTP call  The app must multiply 2 numbers together via an HTTP call  Answers generated by the service will be logged (via HTTP POST) to another server - the Recorder.   Apps can generally be split into 3 tiers:   Endpoint:  HttpHandlers  are constructed individually, by providing a builder function which takes the business-level dependencies.   Application: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier.  Server: Builder function which takes the configuration for environmental concerns such as ports and downstream urls.", 
            "title": "Application Design"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/", 
            "text": "Until we have an application that can be deployed, we cannot create any business value. The Walking Skeleton\nmodel dictates that putting the most trivial endpoint into a production environment will prove our deployment\npipeline is sound, and helps to set the direction for the testing strategy that we will use going forward.\n\n\nWe start with in ICT (In-Container-Test), which have the job of testing server-level concerns such as monitoring,\ndocumentation, and checking in a high-level way that the business endpoints are wired correctly.\n\n\nRequirements:\n\n\n\n\nThe service can be pinged over HTTP to prove that is still alive.\n\n\n\n\nProduction:\n\n\n\n\nTests:", 
            "title": "1. Building a walking skeleton"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#requirements", 
            "text": "The service can be pinged over HTTP to prove that is still alive.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/", 
            "text": "Starting with another EndToEnd test, we can then drill-down into the functional behaviour of the system by introducing\nOCT (Out of Container) tests and converting the e2e test to just test endpoint wiring (so far). The common assertions have\nalso been converted to reusable extension methods on Response.\n\n\nRequirements:\n\n\n\n\nImplement an \"add\" service, which will sum a number of integer values.\n\n\n\n\nProduction:\n\n\n\n\nTests:", 
            "title": "2. Adding an endpoint"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#requirements", 
            "text": "Implement an \"add\" service, which will sum a number of integer values.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/", 
            "text": "Requirements:\n\n\n\n\nImplement a \"multiply\" service, which will find the product of a number of integer values.\n\n\n\n\nProduction:\n\n\n\n\nTests:", 
            "title": "3. Adding another endpoint"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#requirements", 
            "text": "Implement a \"multiply\" service, which will find the product of a number of integer values.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/", 
            "text": "At this point, the separation of the layers starts to become clear:\n- The server layer is responsible for taking external configuration and instantiating the app layer.\n- The application layer API is only in terms of HTTP transports - it constructs business level abstractions\nwhich are passed down into to the individual endpoints\n\n\nThe process here is to create fake versions of the dependency which can be tested against through the business interface.\nThis requires another style of testing, CDCs (Consumer Driven Contracts), to be created. These contract tests ensure that our\ninteractions with the external service are valid.\n\n\nRequirements:\n\n\n\n\nResults from calculations should be POSTed via HTTP to another \"answer recording\" service.\n\n\n\n\nImplementation Notes:\n\n\nThe following process is followed to us to the final state, whilst always allowing us to keep the build green:\n\n\n\n\nDetermine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer}\n\n\nCreate RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder\n\n\nCreate FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement\n\n\nInclude the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything)\n\n\nPass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler\n\n\nFactor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done\n\n\nIntroduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment\n\n\nAlter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp\n\n\nIn MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record()\n\n\n\n\nProduction:\n\n\n\n\nTests:", 
            "title": "4. An external dependency"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#requirements", 
            "text": "Results from calculations should be POSTed via HTTP to another \"answer recording\" service.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#implementation-notes", 
            "text": "The following process is followed to us to the final state, whilst always allowing us to keep the build green:   Determine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer}  Create RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder  Create FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement  Include the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything)  Pass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler  Factor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done  Introduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment  Alter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp  In MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record()", 
            "title": "Implementation Notes:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/cookbook/server_as_a_function/", 
            "text": "This example is the simplest possible \"server\" implementation. Note that we are not spinning up a server-backend here - but the entire application(!) is testable but firing HTTP requests at it as if it were. \n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "Server as a function"
        }, 
        {
            "location": "/cookbook/server_as_a_function/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/server_as_a_function/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/client_as_a_function/", 
            "text": "This example demonstrates a client module (in this case the Apache Client). A client is just another HttpHandler.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-client-apache\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "Client as a function"
        }, 
        {
            "location": "/cookbook/client_as_a_function/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0 \n    compile group:  org.http4k , name:  http4k-client-apache , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/client_as_a_function/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/container_integration/", 
            "text": "This example shows how to both how to serve an application HttpHandler using an embedded an HTTP server and to query it using an HTTP client. All server-backend implementations are launched in an identical manner (in 1LOC). Additionally, server instances can be customised using classes available in the implementation JARs - in the case of Jetty, the application is mounted using the \nasServlet()\n extension method into the Jetty container.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-client-apache\n, version: \n2.38.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-server-jetty\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "Container integration"
        }, 
        {
            "location": "/cookbook/container_integration/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0 \n    compile group:  org.http4k , name:  http4k-client-apache , version:  2.38.0 \n    compile group:  org.http4k , name:  http4k-server-jetty , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/container_integration/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/simple_routing/", 
            "text": "This example shows how to use the simple routing functionality to bind several routes\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "Simple routing"
        }, 
        {
            "location": "/cookbook/simple_routing/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/simple_routing/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/nestable_routes/", 
            "text": "This is a fairly comprehensive example of the core-routing logic available:\n\n\n\n\nIndividual HTTP endpoints are represented as \nHttpHandlers\n.\n\n\nBinding an \nHttpHandler\n to a path and HTTP verb yields a \nRoute\n.\n\n\nRoutes\n can be combined together into a \nRoutingHttpHandler\n, which is both an \nHttpHandler\n and a\nRouter\n.\n\n\nA \nRouter\n is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next \nRouter\n in the list.\n\n\nRouters can be combined together to form another \nHttpHandler\n\n\nUsage of supplied core library \nFilters\n\n\nServing of static content using a \nClasspath\n resource loader\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "Nestable routes"
        }, 
        {
            "location": "/cookbook/nestable_routes/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/nestable_routes/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/using_json/", 
            "text": "Example of how to use the JSON library API wrappers, in this case the module used is Jackson. \nhttp4k\n provides an identical interface for all JSON implementations.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-format-jackson\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "JSON messaging"
        }, 
        {
            "location": "/cookbook/using_json/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0 \n    compile group:  org.http4k , name:  http4k-format-jackson , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/using_json/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/using_templates/", 
            "text": "Example showing how to use the Templating modules - in this case Handlebars, both by standard response manipulation and via a typesafe view lens.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-template-handlebars\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "Templating engines"
        }, 
        {
            "location": "/cookbook/using_templates/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0 \n    compile group:  org.http4k , name:  http4k-template-handlebars , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/using_templates/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/request_context/", 
            "text": "A \nRequestContext\n makes it possible to attach objects to a request whilst it is being passed down through the layers of an application.\n\n\nThe basic concept is that there is a global shared object which holds a bag of state (indexed by Request). This state can be modified in Filters and then \nthat state accessed inside other Filters or the terminating HttpHandler. There are 2 available choices for manipulating this data:\n\n\n\n\nUsing simple Strings to represent the keys.\n\n\nUsing \nRequestContextKey\ns and the Lens mechanism from the \nhttp4k-core\n module.\n\n\n\n\nWhilst the first method looks technically simpler, the use of simple Strings does not provide the type-safety of the second, which uses unique shared Key objects to guarantee non-clashing of keys and type-safety of the state.\nRegardless of which of the above mechanisms are used, an instance of the \nServerFilters.InitialiseRequestContext\n Filter must wrap the HttpHandler(s) to activate\nthe shared bag of state for each request, and to remove the state after the request is complete.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n\n\n\n\n\nCode\n\n\nString-based keys\n\n\n\n\nLens-based keys", 
            "title": "Typesafe RequestContexts"
        }, 
        {
            "location": "/cookbook/request_context/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/request_context/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/request_context/#string-based-keys", 
            "text": "", 
            "title": "String-based keys"
        }, 
        {
            "location": "/cookbook/request_context/#lens-based-keys", 
            "text": "", 
            "title": "Lens-based keys"
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/", 
            "text": "Example showing how to create and apply lenses to requests and responses to both extract and inject typesafe values out of and into HTTP messages. Note that since the \nhttp4k\n \nRequest/Response\n objects are immutable, all injection occurs via copy.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n\n\n\n\n\nStandard (exception based) approach\n\n\nErrors in extracting Lenses are propagated as exceptions which are caught and handled by the \nCatchLensFailure\n Filter.\n\n\n\n\n\nUsing custom \"Result\" ADTs\n\n\nAn alternative approach to using Exceptions to automatically produce \nBadRequests\n is to use an Either-type structure, and this would be easy to implement - but the lack of an in-built Result/Either type in the standard Kotlin library means that we \ndon't have a single representation to use without shackling ourselves to another Either-containing library such as Funktionale or Result4k.\n\n\nAdditionally, the lack of Higher Kinded Types in Kotlin means that we are unable to provide a generic method for converting standard lenses. However, it is easy to implement an extension method to use in specific use cases.\n\n\nBelow is an example which uses a custom Result ADT - this will work for all extraction Lenses that you define:", 
            "title": "Typesafe HTTP requests with lenses"
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/#standard-exception-based-approach", 
            "text": "Errors in extracting Lenses are propagated as exceptions which are caught and handled by the  CatchLensFailure  Filter.", 
            "title": "Standard (exception based) approach"
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/#using-custom-result-adts", 
            "text": "An alternative approach to using Exceptions to automatically produce  BadRequests  is to use an Either-type structure, and this would be easy to implement - but the lack of an in-built Result/Either type in the standard Kotlin library means that we \ndon't have a single representation to use without shackling ourselves to another Either-containing library such as Funktionale or Result4k.  Additionally, the lack of Higher Kinded Types in Kotlin means that we are unable to provide a generic method for converting standard lenses. However, it is easy to implement an extension method to use in specific use cases.  Below is an example which uses a custom Result ADT - this will work for all extraction Lenses that you define:", 
            "title": "Using custom \"Result\" ADTs"
        }, 
        {
            "location": "/cookbook/html_forms/", 
            "text": "HTML form support is provided on 2 levels:\n\n\n\n\nThrough the use of \nform()\n extension methods on \nRequest\n to get/set String values.\n\n\nUsing the Lens system, which adds the facility to define form fields in a typesafe way, and to validate form contents (in either a strict (400) or \"feedback\" mode).\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n\n\n\n\n\nStandard (non-typesafe) API\n\n\n\n\nLens (typesafe, validating) API", 
            "title": "HTML forms"
        }, 
        {
            "location": "/cookbook/html_forms/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/html_forms/#standard-non-typesafe-api", 
            "text": "", 
            "title": "Standard (non-typesafe) API"
        }, 
        {
            "location": "/cookbook/html_forms/#lens-typesafe-validating-api", 
            "text": "", 
            "title": "Lens (typesafe, validating) API"
        }, 
        {
            "location": "/cookbook/multipart_forms/", 
            "text": "Multipart form support is provided on 2 levels:\n\n\n\n\nThrough the creation of a \nMultipartFormBody\n which can be set on a \nRequest\n.\n\n\nUsing the Lens system, which adds the facility to define form fields in a typesafe way, and to validate form contents (in either a strict (400) or \"feedback\" mode).\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-multipart\n, version: \n2.38.0\n\n\n\n\n\n\nStandard (non-typesafe) API\n\n\n\n\nLens (typesafe, validating) API - reads ALL contents onto disk/memory\n\n\n\n\nStreaming - iterate over Multiparts\n\n\n\n\nProcessing Files with a Filter and convert to standard form", 
            "title": "Multipart forms"
        }, 
        {
            "location": "/cookbook/multipart_forms/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0 \n    compile group:  org.http4k , name:  http4k-multipart , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/multipart_forms/#standard-non-typesafe-api", 
            "text": "", 
            "title": "Standard (non-typesafe) API"
        }, 
        {
            "location": "/cookbook/multipart_forms/#lens-typesafe-validating-api-reads-all-contents-onto-diskmemory", 
            "text": "", 
            "title": "Lens (typesafe, validating) API - reads ALL contents onto disk/memory"
        }, 
        {
            "location": "/cookbook/multipart_forms/#streaming-iterate-over-multiparts", 
            "text": "", 
            "title": "Streaming - iterate over Multiparts"
        }, 
        {
            "location": "/cookbook/multipart_forms/#processing-files-with-a-filter-and-convert-to-standard-form", 
            "text": "", 
            "title": "Processing Files with a Filter and convert to standard form"
        }, 
        {
            "location": "/cookbook/generating_data_classes/", 
            "text": "On the web...\n\n\nThis \nHeroku\n app demonstrates how to use JSON and XML automarshalling to communicate using typesafe Body lenses.\n\n\nOr manually using a filter...\n\n\nThis example show the usage of the \nGenerateDataClasses\n to generate Kotlin data class code for JSON messages from a remote endpoint. When used in conjunction with the \"auto body-marshalling\" functionality available with JSON libraries such as Jackson and GSON, this provides a super-fast way to integrate with upstream remote APIs in a typesafe way.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-format-gson\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "Generating data classes for messages"
        }, 
        {
            "location": "/cookbook/generating_data_classes/#on-the-web", 
            "text": "This  Heroku  app demonstrates how to use JSON and XML automarshalling to communicate using typesafe Body lenses.", 
            "title": "On the web..."
        }, 
        {
            "location": "/cookbook/generating_data_classes/#or-manually-using-a-filter", 
            "text": "This example show the usage of the  GenerateDataClasses  to generate Kotlin data class code for JSON messages from a remote endpoint. When used in conjunction with the \"auto body-marshalling\" functionality available with JSON libraries such as Jackson and GSON, this provides a super-fast way to integrate with upstream remote APIs in a typesafe way.", 
            "title": "Or manually using a filter..."
        }, 
        {
            "location": "/cookbook/generating_data_classes/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0 \n    compile group:  org.http4k , name:  http4k-format-gson , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/generating_data_classes/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/typesafe_http_contracts/", 
            "text": "This contract example shows:\n\n\n\n\n2 endpoints with typesafe contracts (marshalling of path parameters and bodies)\n\n\nCustom filters (reporting latency)\n\n\nAPI key security via a typesafe Query parameter (this can be a header or a body parameter as well)\n\n\nOpenApi/Swagger API documentation - Run this example and point a browser \nhere\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-contract\n, version: \n2.38.0\n\n\n\n\n\n\nCode", 
            "title": "Typesafe HTTP contracts"
        }, 
        {
            "location": "/cookbook/typesafe_http_contracts/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0 \n    compile group:  org.http4k , name:  http4k-contract , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/typesafe_http_contracts/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/record_and_replay/", 
            "text": "A set of classes to provide simple recording/replaying of HTTP traffic. This is perfect for testing purposes, or in short lived, low traffic environments where no proper caches are available.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.38.0\n\n\n\n\n\n\nCaching HTTP Traffic\n\n\nUsing \nFilters\n it's possible to record traffic and then return recorded content instead of making repeated calls. Note that the provided storage \nimplementations DO NOT have any facility for Cache Control or eviction, or respect any response headers around caching. Requests are indexed in a way optimised for retrieval.\n\n\n\n\n\nRecording Streams of HTTP Traffic\n\n\nUsing \nFilters\n it's possible to record a stream traffic and then replay recorded content instead. Requests are indexed in a way optimised for iteration.\n\n\n\n\n\nConcepts\n\n\nThe \norg.http4k.traffic\n package contains the interfaces which make up the core concepts for traffic capture and replay. These interfaces are:\n\n\n\n\nA \nSink\n consumes request/response pairs for storage. \n\n\nA \nSource\n provides lookup of pre-stored Response based on an HTTP Request.\n\n\nReplay\n instances provide streams of HTTP messages as they were received.\n\n\nA \nReadWriteCache\n combines \nSink\n and \nSource\n to provide cache-like storage.\n\n\nA \nReadWriteStream\n combines \nSink\n and \nReplay\n to provide a stream of traffic which can be replayed.\n\n\n\n\nThe API has been designed to be modular so API users can provide their own implementations (store in S3 etc..).", 
            "title": "Recording/replaying HTTP traffic"
        }, 
        {
            "location": "/cookbook/record_and_replay/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.38.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/record_and_replay/#caching-http-traffic", 
            "text": "Using  Filters  it's possible to record traffic and then return recorded content instead of making repeated calls. Note that the provided storage \nimplementations DO NOT have any facility for Cache Control or eviction, or respect any response headers around caching. Requests are indexed in a way optimised for retrieval.", 
            "title": "Caching HTTP Traffic"
        }, 
        {
            "location": "/cookbook/record_and_replay/#recording-streams-of-http-traffic", 
            "text": "Using  Filters  it's possible to record a stream traffic and then replay recorded content instead. Requests are indexed in a way optimised for iteration.", 
            "title": "Recording Streams of HTTP Traffic"
        }, 
        {
            "location": "/cookbook/record_and_replay/#concepts", 
            "text": "The  org.http4k.traffic  package contains the interfaces which make up the core concepts for traffic capture and replay. These interfaces are:   A  Sink  consumes request/response pairs for storage.   A  Source  provides lookup of pre-stored Response based on an HTTP Request.  Replay  instances provide streams of HTTP messages as they were received.  A  ReadWriteCache  combines  Sink  and  Source  to provide cache-like storage.  A  ReadWriteStream  combines  Sink  and  Replay  to provide a stream of traffic which can be replayed.   The API has been designed to be modular so API users can provide their own implementations (store in S3 etc..).", 
            "title": "Concepts"
        }, 
        {
            "location": "/cookbook/test_driven_apps/", 
            "text": "This example shows the various styles of testing endpoints, and requires both the \nhttp4k-core\n and \nhttp4k-testing-hamkrest\n modules:", 
            "title": "Test driven apps"
        }, 
        {
            "location": "/performance/", 
            "text": "The \nhttp4k\n server-backend modules provide a very thin adapter layer over the raw APIs of the underlying servers, so \ngenerally performs at a very low overhead compared to the raw server.\n\n\nTech Empower Benchmarks\n\n\nWe have entered \nhttp4k\n into the prominent \nTech Empower Framework Benchmarks\n \nproject, which assesses frameworks over a series of realistic tests, including:\n\n\n\n\nJSON response processing\n\n\nRandom data-updates (database)\n\n\nRandom data reads (database)\n\n\nTemplate-rendering (HTML)\n\n\nPlain-text pipelining\n\n\n\n\nFor this benchmark, no customisation or performance tuning of the underlying servers was done - the default Server \nconstruction mechanic was used, as below:\n\n\nfun\n \nmain\n(\nargs\n:\n \nArray\nString\n)\n \n{\n\n    \nHttp4kBenchmarkServer\n.\nstart\n(\nNetty\n(\n9000\n))\n\n\n}\n\n\n\n\n\n\nCommand-line JVM options, however, were tuned for the test to take advantage of various JVM features.\n\n\nThe full implementation of the benchmark can be found \nhere\n.\n\n\nResults\n\n\nResults and analysis will be posted here when the next round (R15) of the benchmarks is published.", 
            "title": "Performance"
        }, 
        {
            "location": "/performance/#tech-empower-benchmarks", 
            "text": "We have entered  http4k  into the prominent  Tech Empower Framework Benchmarks  \nproject, which assesses frameworks over a series of realistic tests, including:   JSON response processing  Random data-updates (database)  Random data reads (database)  Template-rendering (HTML)  Plain-text pipelining   For this benchmark, no customisation or performance tuning of the underlying servers was done - the default Server \nconstruction mechanic was used, as below:  fun   main ( args :   Array String )   { \n     Http4kBenchmarkServer . start ( Netty ( 9000 ))  }   Command-line JVM options, however, were tuned for the test to take advantage of various JVM features.  The full implementation of the benchmark can be found  here .", 
            "title": "Tech Empower Benchmarks"
        }, 
        {
            "location": "/performance/#results", 
            "text": "Results and analysis will be posted here when the next round (R15) of the benchmarks is published.", 
            "title": "Results"
        }, 
        {
            "location": "/in_action/", 
            "text": "Rationale \n design\n\n\nPresentation about the development of http4k given at the Kotlin London meetup\n\n\nSee http4k in action in these example projects:\n\n\n\n\nSuper quick start \"Hello World\" Github/Travis/Heroku CD pipeline)\n\n\nTodo backend (standard routing version)\n\n\nTodo backend (contract routing version)\n\n\nTDD'd example application\n\n\nStage-by-stage example of development process (London TDD style)", 
            "title": "In action"
        }, 
        {
            "location": "/in_action/#rationale-design", 
            "text": "Presentation about the development of http4k given at the Kotlin London meetup", 
            "title": "Rationale &amp; design"
        }, 
        {
            "location": "/in_action/#see-http4k-in-action-in-these-example-projects", 
            "text": "Super quick start \"Hello World\" Github/Travis/Heroku CD pipeline)  Todo backend (standard routing version)  Todo backend (contract routing version)  TDD'd example application  Stage-by-stage example of development process (London TDD style)", 
            "title": "See http4k in action in these example projects:"
        }, 
        {
            "location": "/blog/why_http4k/", 
            "text": "{{WORK IN PROGRESS}}\n\n\nServer as a Function. In Kotlin. Typesafe. Without the Server.\n\n\n@daviddenton\n / november 2017\n\n\nMeet \nhttp4k\n.\n\n\nWhenever (yet another) new JVM HTTP framework is released, the inevitable question that rightly get asked is \n\"How it this different to X?\"\n. In this post, I'm going to briefly cover what \nhttp4k\n is, how we think it's different, and address some of those \nbold claims\n from the title.\n\n\nHere's a quick rundown of what we think those differences are:\n\n\n\n\nhttp4k\n is small. Written in pure Kotlin, with zero dependencies.\n\n\nhttp4k\n is simple. Like, really simple. No static API magic, no annotations, no reflection.\n\n\nhttp4k\n is immutable. It relies on an immutable HTTP model, which makes it a snap to test and debug.\n\n\nhttp4k\n is symmetric. The remote HTTP model is the same as the incoming model.\n\n\nhttp4k\n is typesafe. Say goodbye to boilerplate and hello to auto-generated documentation.\n\n\nhttp4k\n is serverless. Or rather - server independent. Test an app locally and then deploy it into AWS Lambda with no changes.\n\n\n\n\nWhy does it even exist?!?\n\n\nThe first thing to say is that (not very much) of \nhttp4k\n is new - rather the distillation of 15 years worth of experience of using various server-side libraries and hence most of the good ideas are stolen. For instance - the routing module is inspired by \nUtterlyIdle\n, the basic \"Server as a function\" model is stolen from \nFinagle\n, and the contract module OpenApi/Swagger generator is ported from \nFintrospect\n. With the growing adoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch, whilst avoiding the \nmagic\n that plagues other frameworks.\n\n\nClaim A: Small, simple, immutable.\n\n\nBased on the awesome \n\"Your Server as a Function\"\n paper from Twitter, \nhttp4k\n apps are modelled by composing 2 types of simple function. This simplicity turns out to be very powerful.\n\n\nFunction 1: HttpHandler\n\n\nAn \nHttpHandler\n and represents an HTTP endpoint. It's not even an Interface, modelled merely as a \ntypealias\n:\n\n\ntypealias\n \nHttpHandler\n \n=\n \n(\nRequest\n)\n \n-\n \nResponse\n\n\n\n\n\n\nHere's a entire \nhttp4k\n application, which echoes request body back a the user. It only relies on the \nhttp4k-core\n module, which itself has zero dependencies:\n\n\nval\n \napp\n \n=\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nrequest\n.\nbody\n)\n \n}\n\n\nval\n \nserver\n \n=\n \napp\n.\nasServer\n(\nSunHttp\n(\n8000\n)).\nstart\n()\n\n\n\n\n\n\nThe \nRequest\n and \nResponse\n objects in there are immutable data classes/POKOs, so testing the app requires absolutely no extra infrastructure, and is as easy as:\n\n\nclass\n \nAppTest\n \n{\n\n    \n@Test\n\n    \nfun\n \n`\nresponds\n \nas\n \nexpected\n`\n()\n \n{\n\n        \nassertThat\n(\napp\n(\nRequest\n(\nPOST\n,\n \n/\n).\nbody\n(\nhello\n)),\n \nequalTo\n(\nResponse\n(\nOK\n).\nbody\n(\nhello\n)))\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTo plug it into a different Server-backend, just depend on the relevant module (Jetty, Undertow, Netty) and change the call to \nasServer()\n.\n\n\nFunction 2: Filter\n\n\nFilters\n provides pre and post Request processing:\n\n\ninterface\n \nFilter\n \n:\n \n(\nHttpHandler\n)\n \n-\n \nHttpHandler\n\n\n\n\n\n\nFor discoverability reasons this is modelled as an Interface and not a \ntypealias\n - it also has a couple of Kotlin \nextension methods\n to allow you to compose \nFilters\n with \nHttpHandlers\n and other \nFilters\n:\n\n\nval\n \nsetContentType\n \n=\n \nFilter\n \n{\n \nnext\n \n-\n\n        \n{\n \nrequest\n \n-\n \nnext\n(\nrequest\n).\nheader\n(\nContent-Type\n,\n \ntext/plain\n)\n \n}\n\n    \n}\n\n\nval\n \nrepeatBody\n \n=\n \nFilter\n \n{\n \nnext\n \n-\n\n        \n{\n \nrequest\n \n-\n \nnext\n(\nrequest\n.\nbody\n(\nrequest\n.\nbodyString\n()\n \n+\n \nrequest\n.\nbodyString\n()\n \n}\n\n    \n}\n\n\nval\n \ncomposedFilter\n:\n \nFilter\n \n=\n \nrepeatBody\n.\nthen\n(\nsetContentType\n)\n\n\nval\n \ndecoratedApp\n:\n \nHttpHandler\n \n=\n \ncomposedFilter\n.\nthen\n(\napp\n)\n\n\n\n\n\n\nRouting\n\n\nhttp4k\n's nestable routing looks a lot like every other Sinatra-style framework these days - and you can infinitely nest \nHttpHandlers\n - this just exposes another \nHttpHandler\n, so you can easily extract, test and reuse sets of routes as easily as you could with one:\n\n\nval\n \napp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n    \n/app\n \nbind\n \nGET\n \nto\n \ndecoratedApp\n,\n\n    \n/{name}\n \nbind\n \nPOST\n \nto\n \n{\n \nrequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nyou POSTed to ${request.path(\nname\n)}\n)\n \n}\n\n\n)\n\n\n\n\n\n\nClaim B. Symmetric HTTP\n\n\nOut of the multitude of JVM http frameworks out there, not many actually consider how you app talks to other services, yet in this Microservice\u2122 world that's an absolutely massive part of what many apps do!\n\n\nAs per a core principle behind \"Server as a Function\", \nhttp4k\n provides a symmetric API for HTTP clients - ie. it's \nexactly\n the same API as is exposed in \nhttp4k\n server applications - the \nHttpHandler\n. Here's that entire API again, just in case you've forgotten:\n\n\ntypealias\n \nHttpHandler\n \n=\n \n(\nRequest\n)\n \n-\n \nResponse\n\n\n\n\n\n\nWhat does that mean in practice? Well - for one thing, it's less for your brain to think about because you already know the API:\n\n\nval\n \nclient\n:\n \nHttpHandler\n \n=\n \nApacheClient\n()\n\n\nval\n \nresponse\n:\n \nResponse\n \n=\n \nclient\n(\nRequest\n(\nGET\n,\n \nhttp://server/path\n))\n\n\n\n\n\n\nFor another, it means that if applications and clients are interchangeable, you can plug them together in memory without putting them on the network - which makes testing insanely fast:\n\n\nfun\n \nMyApp1\n():\n \nHttpHandler\n \n=\n \n{\n \nResponse\n(\nOK\n)\n \n}\n\n\nfun\n \nMyApp2\n(\napp1\n:\n \nHttpHandler\n):\n \nHttpHandler\n \n=\n \n{\n \napp1\n(\nit\n)\n \n}\n\n\n\nval\n \napp1\n:\n \nHttpHandler\n \n=\n \nMyApp1\n()\n\n\nval\n \napp2\n:\n \nHttpHandler\n \n=\n \nMyApp2\n(\napp1\n)\n\n\n\n\n\n\nhttp4k\n provides a HTTP client adapters for both Apache and OkHttp.\n\n\nClaim C. Typesafe HTTP\n\n\n{{tumbleweed}}\n\n\nClaim D. Serverless\n\n\n{{tumbleweed}}\n\n\nThe final word!\n\n\nThe \nhttp4k-core\n module rocks in at \n1000 lines of code (about 600kb), and has zero dependencies (other than the Kotlin language itself). Additionally, everything in the core is functional and predictable - there is no static API magic going on under the covers (making it impossible to have multiple apps in the same JVM), no compiler-plugins, and no reflection. It also provides:\n\n\n\n\nSupport for static file serving with HotReload\n\n\nA bunch of useful Filters for stuff like \nZipkin\n Request Tracing\n\n\nA RequestContext mechanism for\n\n\nFacilities to record and replay HTTP traffic\n\n\n\n\nThere are also a bunch of other modules available, all presented with the same concentration on Testability, API simplicity and consistency:\n\n\n\n\nTemplating engines with HotReload\n\n\nPopular JSON/XML library support\n\n\nTypesafe, multipart forms processing\n\n\nAWS\n request signing\n\n\nResilience4j\n integration, including Circuit Breakers \n Rate Limiting\n\n\nTesting support via \nHamkrest\n matchers and an in-memory \nWebDriver\n implementation.\n\n\n\n\nLastly, \nhttp4k\n is proven in production, driving traffic for a major publishing website (easily serving 10's of million hits per day on a few nodes) since March 2017. \n\n\nFootnotes\n\n\n\n\n\"But... but... but... asynchronous! And Webscale!\"*, I heard them froth. Yes, you are correct - \"Server as a Function\" is based on asynchronous functions and \nhttp4k\n is synchronous. However, we tried this already and found that for 99% of apps it actually makes things harder unless you've got async all the way down. We found that this plainly didn't matter for our use-case so went for Simple\u2122... maybe Kotlin co-routines will make this simpler - we'll see.", 
            "title": "Why http4k"
        }, 
        {
            "location": "/blog/why_http4k/#work-in-progress", 
            "text": "", 
            "title": "{{WORK IN PROGRESS}}"
        }, 
        {
            "location": "/blog/why_http4k/#server-as-a-function-in-kotlin-typesafe-without-the-server", 
            "text": "", 
            "title": "Server as a Function. In Kotlin. Typesafe. Without the Server."
        }, 
        {
            "location": "/blog/why_http4k/#daviddenton-november-2017", 
            "text": "", 
            "title": "@daviddenton / november 2017"
        }, 
        {
            "location": "/blog/why_http4k/#meet-http4k", 
            "text": "Whenever (yet another) new JVM HTTP framework is released, the inevitable question that rightly get asked is  \"How it this different to X?\" . In this post, I'm going to briefly cover what  http4k  is, how we think it's different, and address some of those  bold claims  from the title.  Here's a quick rundown of what we think those differences are:   http4k  is small. Written in pure Kotlin, with zero dependencies.  http4k  is simple. Like, really simple. No static API magic, no annotations, no reflection.  http4k  is immutable. It relies on an immutable HTTP model, which makes it a snap to test and debug.  http4k  is symmetric. The remote HTTP model is the same as the incoming model.  http4k  is typesafe. Say goodbye to boilerplate and hello to auto-generated documentation.  http4k  is serverless. Or rather - server independent. Test an app locally and then deploy it into AWS Lambda with no changes.", 
            "title": "Meet http4k."
        }, 
        {
            "location": "/blog/why_http4k/#why-does-it-even-exist", 
            "text": "The first thing to say is that (not very much) of  http4k  is new - rather the distillation of 15 years worth of experience of using various server-side libraries and hence most of the good ideas are stolen. For instance - the routing module is inspired by  UtterlyIdle , the basic \"Server as a function\" model is stolen from  Finagle , and the contract module OpenApi/Swagger generator is ported from  Fintrospect . With the growing adoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch, whilst avoiding the  magic  that plagues other frameworks.", 
            "title": "Why does it even exist?!?"
        }, 
        {
            "location": "/blog/why_http4k/#claim-a-small-simple-immutable", 
            "text": "Based on the awesome  \"Your Server as a Function\"  paper from Twitter,  http4k  apps are modelled by composing 2 types of simple function. This simplicity turns out to be very powerful.", 
            "title": "Claim A: Small, simple, immutable."
        }, 
        {
            "location": "/blog/why_http4k/#function-1-httphandler", 
            "text": "An  HttpHandler  and represents an HTTP endpoint. It's not even an Interface, modelled merely as a  typealias :  typealias   HttpHandler   =   ( Request )   -   Response   Here's a entire  http4k  application, which echoes request body back a the user. It only relies on the  http4k-core  module, which itself has zero dependencies:  val   app   =   {   request :   Request   -   Response ( OK ). body ( request . body )   }  val   server   =   app . asServer ( SunHttp ( 8000 )). start ()   The  Request  and  Response  objects in there are immutable data classes/POKOs, so testing the app requires absolutely no extra infrastructure, and is as easy as:  class   AppTest   { \n     @Test \n     fun   ` responds   as   expected ` ()   { \n         assertThat ( app ( Request ( POST ,   / ). body ( hello )),   equalTo ( Response ( OK ). body ( hello ))) \n     }  }   To plug it into a different Server-backend, just depend on the relevant module (Jetty, Undertow, Netty) and change the call to  asServer() .", 
            "title": "Function 1: HttpHandler"
        }, 
        {
            "location": "/blog/why_http4k/#function-2-filter", 
            "text": "Filters  provides pre and post Request processing:  interface   Filter   :   ( HttpHandler )   -   HttpHandler   For discoverability reasons this is modelled as an Interface and not a  typealias  - it also has a couple of Kotlin  extension methods  to allow you to compose  Filters  with  HttpHandlers  and other  Filters :  val   setContentType   =   Filter   {   next   - \n         {   request   -   next ( request ). header ( Content-Type ,   text/plain )   } \n     }  val   repeatBody   =   Filter   {   next   - \n         {   request   -   next ( request . body ( request . bodyString ()   +   request . bodyString ()   } \n     }  val   composedFilter :   Filter   =   repeatBody . then ( setContentType )  val   decoratedApp :   HttpHandler   =   composedFilter . then ( app )", 
            "title": "Function 2: Filter"
        }, 
        {
            "location": "/blog/why_http4k/#routing", 
            "text": "http4k 's nestable routing looks a lot like every other Sinatra-style framework these days - and you can infinitely nest  HttpHandlers  - this just exposes another  HttpHandler , so you can easily extract, test and reuse sets of routes as easily as you could with one:  val   app :   HttpHandler   =   routes ( \n     /app   bind   GET   to   decoratedApp , \n     /{name}   bind   POST   to   {   request   -   Response ( OK ). body ( you POSTed to ${request.path( name )} )   }  )", 
            "title": "Routing"
        }, 
        {
            "location": "/blog/why_http4k/#claim-b-symmetric-http", 
            "text": "Out of the multitude of JVM http frameworks out there, not many actually consider how you app talks to other services, yet in this Microservice\u2122 world that's an absolutely massive part of what many apps do!  As per a core principle behind \"Server as a Function\",  http4k  provides a symmetric API for HTTP clients - ie. it's  exactly  the same API as is exposed in  http4k  server applications - the  HttpHandler . Here's that entire API again, just in case you've forgotten:  typealias   HttpHandler   =   ( Request )   -   Response   What does that mean in practice? Well - for one thing, it's less for your brain to think about because you already know the API:  val   client :   HttpHandler   =   ApacheClient ()  val   response :   Response   =   client ( Request ( GET ,   http://server/path ))   For another, it means that if applications and clients are interchangeable, you can plug them together in memory without putting them on the network - which makes testing insanely fast:  fun   MyApp1 ():   HttpHandler   =   {   Response ( OK )   }  fun   MyApp2 ( app1 :   HttpHandler ):   HttpHandler   =   {   app1 ( it )   }  val   app1 :   HttpHandler   =   MyApp1 ()  val   app2 :   HttpHandler   =   MyApp2 ( app1 )   http4k  provides a HTTP client adapters for both Apache and OkHttp.", 
            "title": "Claim B. Symmetric HTTP"
        }, 
        {
            "location": "/blog/why_http4k/#claim-c-typesafe-http", 
            "text": "{{tumbleweed}}", 
            "title": "Claim C. Typesafe HTTP"
        }, 
        {
            "location": "/blog/why_http4k/#claim-d-serverless", 
            "text": "{{tumbleweed}}", 
            "title": "Claim D. Serverless"
        }, 
        {
            "location": "/blog/why_http4k/#the-final-word", 
            "text": "The  http4k-core  module rocks in at  1000 lines of code (about 600kb), and has zero dependencies (other than the Kotlin language itself). Additionally, everything in the core is functional and predictable - there is no static API magic going on under the covers (making it impossible to have multiple apps in the same JVM), no compiler-plugins, and no reflection. It also provides:   Support for static file serving with HotReload  A bunch of useful Filters for stuff like  Zipkin  Request Tracing  A RequestContext mechanism for  Facilities to record and replay HTTP traffic   There are also a bunch of other modules available, all presented with the same concentration on Testability, API simplicity and consistency:   Templating engines with HotReload  Popular JSON/XML library support  Typesafe, multipart forms processing  AWS  request signing  Resilience4j  integration, including Circuit Breakers   Rate Limiting  Testing support via  Hamkrest  matchers and an in-memory  WebDriver  implementation.   Lastly,  http4k  is proven in production, driving traffic for a major publishing website (easily serving 10's of million hits per day on a few nodes) since March 2017.", 
            "title": "The final word!"
        }, 
        {
            "location": "/blog/why_http4k/#footnotes", 
            "text": "\"But... but... but... asynchronous! And Webscale!\"*, I heard them froth. Yes, you are correct - \"Server as a Function\" is based on asynchronous functions and  http4k  is synchronous. However, we tried this already and found that for 99% of apps it actually makes things harder unless you've got async all the way down. We found that this plainly didn't matter for our use-case so went for Simple\u2122... maybe Kotlin co-routines will make this simpler - we'll see.", 
            "title": "Footnotes"
        }, 
        {
            "location": "/changelog/", 
            "text": "Changelog\n\n\n\nThis list is not currently intended to be all-encompassing - it will document major and breaking API changes with their rationale when appropriate:\n\n\nv2.38.0\n\n\n\n\nRequestContextKey\n now follow the standardised Lens structure of required, optional, defaulted, and can now be removed (set to null). Replace calls\nto \nRequestContextKey.of()\n with \nRequestContextKey.required()\n \n\n\nRemoved previously deprecated values. See below for details on replacements.\n\n\n\n\nv2.37.0\n\n\n\n\nAdded \nhttp4k-resilience4j\n module, which adds Circuits, RateLimiters, Retrying and Bulkheading.\n\n\nFix #60 (H/T @michaelhixson for the spot).\n\n\n\n\nv2.36.0\n\n\n\n\nAdded a couple of useful \nServerFilters\n.\n\n\nUpgrade various dependency versions.\n\n\nTidying of Multipart code.\n\n\n\n\nv2.35.1\n\n\n\n\nFix #57. Static handlers behave oddly when combined with an HTTP verb in the routing tree.\n\n\n\n\nv2.35.0\n\n\n\n\nFix #56. Altered behaviour of \nCatchLensFailure\n to NOT catch errors from unmarshalling Response objects. This was causing BAD_REQUEST to be incorrectly generated.\n\n\nSimplification of generics around LensSpecs. This should not be a breaking change, (there were 3 generics, now the MID has been removed so there are just 2) but could break if signatures are used explicitly.\n\n\n\n\nv2.34.0\n\n\n\n\nReordered generics in LensInjector to make sense. This should have no effect on most code-bases, but could break if signatures are used explicitly. Just flip the generic types to switch.\n\n\n\n\nv2.33.1\n\n\n\n\nAdded support for unsigned AWS requests, which enables streaming content to S3. \n\n\n\n\nv2.33.0\n\n\n\n\nAdded \nBodyMode.Request\n to configure streaming for clients.\n\n\nResponseBodyMode\n is now \nBodyMode.Response\n (Breaking change. Fixable with simple find/replace).\n\n\n\n\nv2.32.0\n\n\n\n\nAdded \nServerFilter.ProcessFiles\n filter to stream Multipart Files, convert them into references and replace inline in the Form.\n\n\n\n\nv2.31.4\n\n\n\n\nAvoid realising StreamBody unless necessary, which could break common usages of streaming. \n\n\n\n\nv2.31.3\n\n\n\n\nTweaks to Server backends to improve efficiency.\n\n\n\n\nv2.31.2\n\n\n\n\nWebdriver will keep only the final URI after redirects.\n\n\n\n\nv2.31.1\n\n\n\n\nIncreased granularity of \nReplay.DiskStream\n and ensure that traffic is returned in exact order on all OSes.\n\n\nAdd support for redirects to Webdriver.\n\n\n\n\nv2.31.0\n\n\n\n\nMultipart module tweaked to provide a more consistent API.\n\n\nFix FollowRedirects for POST/PUT request.\n\n\n\n\nv2.30.0\n\n\n\n\nMultipart form support through new module \nhttp4k-multipart\n.\n\n\nDeprecation: Replaced \nSwagger\n with \nOpenApi\n and deprecated the former (via typealias).\n\n\nDeprecation: Replaced \nFormValidator\n with \nValidator\n and deprecated the former (via typealias).\n\n\n\n\nv2.29.4\n\n\n\n\nRefactor release.\n\n\n\n\nv2.29.3\n\n\n\n\nFix #50 - Webdriver does not normalise relative links correctly.\n\n\n\n\nv2.29.2\n\n\n\n\nHttp client modules now catch and convert Socket Timeout exceptions to HTTP 504s (with a custom message)\n\n\n\n\nv2.29.1\n\n\n\n\nTweaks to how recorded traffic is stored on disk. Thanks to @dkandalov for the PR around this.\n\n\n\n\nv2.29.0\n\n\n\n\nAdded \nTrafficFilters\n for recording and replaying HTTP traffic. See \norg.http4k.traffic\n package for details.\n\n\n\n\nv2.28.0\n\n\n\n\nAdded \nhttp4k-template-dust\n for Dust template engine support. Thanks to @npryce for the PR to add this.\n\n\n\n\nv2.27.2\n\n\n\n\nFix #44 - Use quotes around cookie values\n\n\n\n\nv2.27.1\n\n\n\n\nRaise proper Exception (instead of LensFailure) when RequestContexts are not set up correctly, so we don't accidentally classify developer errors as BadRequests\n\n\n\n\nv2.27.0\n\n\n\n\nAdded facility to assign values into a \nRequestContext\n which is passed down the Filter chain. \n\n\n\n\nv2.26.3\n\n\n\n\nFix #44 - Request cookies should not be wrapped in quotes.\n\n\n\n\nv2.26.2\n\n\n\n\nFix #43 - AWS does not sign binary requests correctly.\n\n\n\n\nv2.26.1\n\n\n\n\nFix #41 - Sending binary body alters the size of the payload.\n\n\n\n\nv2.26.0\n\n\n\n\nAdded \"catch all\" routing option, which matches all methods to a handler.\n\n\n\n\nv2.25.4\n\n\n\n\nFix #40 - GZip filters now use content-encoding headers instead of transfer-encoding.\n\n\n\n\nv2.25.3\n\n\n\n\nFix #39 - ResponseBodyMode.Memory properly closes streams (breaks jetty + gzip).\n\n\n\n\nv2.25.2\n\n\n\n\nEnsure that streams are closed properly when consuming from an upstream client.\n\n\n\n\nv2.25.1\n\n\n\n\nRemove Apache client request streaming because it may not release connections properly. \n\n\n\n\nv2.25.0\n\n\n\n\nAdd streaming support to HTTP Server and Client modules.\n\n\nRemove CatchLensFailure ClientFilter as it will never be used.\n\n\n\n\nv2.24.0\n\n\n\n\nAdded CatchLensFailure for ClientFilters - which catches un-deserializable invalid responses from clients and generates a BAD_GATEWAY error.\n\n\n\n\nv2.23.4\n\n\n\n\nSwitch XML generation to Gson over Jackson because Jackson doesn't handle uppercase field names well.\n\n\nSwitch native XML parsed type to Document over Node.\n\n\n\n\nv2.23.3\n\n\n\n\nNew algorithm for XML data class deserialisation, so un-deprecated XML methods.\n\n\n\n\nv2.23.2\n\n\n\n\nDeprecated methods in XML support due to limitation with underlying Jackson implementation.\n\n\n\n\nv2.23.1\n\n\n\n\nFixed bug with GenerateXmlDataClasses filter\n\n\n\n\nv2.23.0\n\n\n\n\nRenamed \nhttp4k-format-jackson-xml\n module to \nhttp4k-format-xml\n.\n\n\nImproved XML unmarshalling support.\n\n\n\n\nv2.22.1\n\n\n\n\nFixed 36: Form entry is too strict with content encoding.\n\n\n\n\nv2.22.0\n\n\n\n\nAdded \nhttp4k-format-jackson-xml\n module, with XML parsing support.\n\n\nUpgrade several dependencies\n\n\n\n\nv2.21.2\n\n\n\n\nFixed Hamkrest matchers to be on HttpMessage and not Http Request.\n\n\n\n\nv2.21.1\n\n\n\n\nDefault body Content Negotiation strategy changed to None\n\n\n\n\nv2.21.0\n\n\n\n\nConverted Content-Negotiation strategy from an Enum to an interface, so that users can define their own strategies. We also now check encoding so there are 4-built in strategies to choose from: Strict, StrictNoDirective, NonStrict and None.\n\n\n\n\nv2.20.1\n\n\n\n\nFixed #31 - Matching of segments in URIs is done after URLs are decoded, which results in not capturing encoded slashes in the path segments.\n\n\n\n\nv2.20.0\n\n\n\n\nFixed #30 - CachingClasspath template ResourceLoader not working with non-root packages.\n\n\n\n\nv2.19.0\n\n\n\n\nFixed #29 - webdriver submission of text area.\n\n\nHttp clients now use a new instance of the default for each instantiation. Previously there was a shared instance.\n\n\nAdd regex body type for parsing values out of bodies, and \"None\" option for content negotiation.\n\n\n\n\nv2.18.3\n\n\n\n\nFix AWS request signing for requests containing empty path \n\n\n\n\nv2.18.2\n\n\n\n\nFix AWS request signing for requests containing path with special characters \n\n\n\n\nv2.18.1\n\n\n\n\nAdded support for newRequest() in new \nRouteBinder\n mechanic.\n\n\n\n\nv2.18.0\n\n\n\n\nAdd support for unlimited nesting for \nroutes()\n blocks. Removed the raw \nRoute\n object, which can be replaced with \nRouter\n or \nRoutingHttpHandler\n where appropriate.\n\n\nAs part of above, rejigged route setup logic. Deprecated old routing structure, so now  \n\"/path\" to GET bind\n is \n\"/path\" bind GET to\n. To fix deprecation, simply switch the calls to \"to\" and \"bind\" in routing setup. \n\n\nRename of \nbind()\n in \nhttp4k-contract\n to be \nbindContract()\n\n\n\n\nv2.17.2\n\n\n\n\nAdded missing eclectic HTTP method. :)\n\n\n\n\nv2.17.1\n\n\n\n\nAdded GZip filters to \nhttp4k-core\n to zip request and response bodies.\n\n\n\n\nv2.16.1\n\n\n\n\nImproved messages for \nhttp4k-testing-hamkrest\n matchers.\n\n\n\n\nv2.16.0\n\n\n\n\nAdded \nhttp4k-testing-hamkrest\n which contains a set of Hamkrest matchers for Http4k objects.\n\n\n\n\nv2.15.0\n\n\n\n\nMore features for \nhttp4k-testing-webdriver\n. Cookie support added.\n\n\n\n\nv2.14.0\n\n\n\n\nMore features for \nhttp4k-testing-webdriver\n. We now support Form entry and submission.\n\n\n\n\nv2.13.0\n\n\n\n\nMore features for \nhttp4k-testing-webdriver\n.\n\n\n\n\nv2.12.0\n\n\n\n\nAdded \nhttp4k-testing-webdriver\n module, an ultralight Selenium WebDriver for \nhttp4k\n apps\n\n\n\n\nv2.11.3\n\n\n\n\nFix #26 - GenerateDataClasses does not recurse into nested object trees\n\n\n\n\nv2.11.2\n\n\n\n\nFix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with \nthen(RoutingHttpHandler()\n\n\n\n\nv2.11.1\n\n\n\n\nFix static routes not defaulting to index.html when in root context\n\n\n\n\nv2.11.0\n\n\n\n\nAdded \nSunHttp\n server implementation (for development use only)\n\n\n\n\nv2.10.1\n\n\n\n\nFix cookie parsing when value contains '='\n\n\n\n\nv2.10.0\n\n\n\n\nAdd method to set form values in the request\n\n\n\n\nv2.9.0\n\n\n\n\nAdded PURGE HTTP method as it's used commonly by various caches.\n\n\n\n\nv2.8.1\n\n\n\n\nRepackage AWS classes for consistency with rest of project\n\n\n\n\nv2.7.1\n\n\n\n\nAlter AWS Auth filter creation. Now use \nClientFilters.AwsAuth\n\n\n\n\nv2.7.0\n\n\n\n\nAdd AWS module\n\n\n\n\nv2.6.0\n\n\n\n\nNewly created Zipkin traces are now populated onto incoming request in ServerFilters.\n\n\n\n\nv2.5.1\n\n\n\n\nSlight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling\n\n\n\n\nv2.5.0\n\n\n\n\nAdd \nThymeleaf\n templating support\n\n\n\n\nv2.4.0\n\n\n\n\nAdd \nPebble\n templating support\n\n\n\n\nv2.3.0\n\n\n\n\nMake Route a Router so we can nest them together.\n\n\n\n\nv2.2.1\n\n\n\n\nRemove excess \"charset\" from headers in Undertow.\n\n\n\n\nv2.2.0\n\n\n\n\nRename  \nby()\n to \nbind()\n in routing for clarity. \n\n\n\n\nv2.1.2\n\n\n\n\nFix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex.\n\n\n\n\nv2.1.0\n\n\n\n\nAdded GSON full-auto functions to convert arbitary objects to/from JSON.\n\n\n\n\nv2.0.5\n\n\n\n\nFix #23. Contract now supports multi-part URL params (for hardcoded parts)\n\n\n\n\nv2.0.4\n\n\n\n\nFix #22. Uri template does not parse out correct path params when URL starts with a path part.\n\n\n\n\nv2.0.3\n\n\n\n\ntoString() implementations to aid debugging\n\n\n\n\nv2.0.1\n\n\n\n\nReadded missing default parameter for \nnewRequest()\n on RouteSpec\n\n\n\n\nv2.0.0\n\n\n\n\nBreaking: Inversion of routing API. \nGET to \"/someUri\"\n is now \n\"/someUri\" to GET\n for consistency across the entire API.\n\n\n\n\nv1.33.1\n\n\n\n\nReimplementation of \nhttp4k-contract\n API to match main routing API. Contracts are now nestable.\n\n\n\n\nv1.32.2\n\n\n\n\nFix Filters being applied twice in \nContractRoutingHttpHandler\n\n\n\n\nv1.32.1\n\n\n\n\nMore work on \nhttp4k-contract\n contract API\n\n\n\n\nv1.31.0\n\n\n\n\nRework \nhttp4k-contract\n routing to be mounted in the same way as other \nRoutingHttpHandlers\n\n\n\n\nv1.30.0\n\n\n\n\nFilters are now applied consistently to all Routers\n\n\n\n\nv1.29.0\n\n\n\n\nTweak to DSL for defining StaticRouters\n\n\n\n\nv1.28.1\n\n\n\n\nFix for #18: FollowRedirect will now work if location header includes charset information.  \n\n\n\n\nv1.28.0\n\n\n\n\nNew DSL for defining StaticRouters\n\n\n\n\nv1.27.0\n\n\n\n\nMerged StaticContent and StaticRouter and repackage of contract API into other packages\n\n\n\n\nv1.26.2\n\n\n\n\nExtend fix for #17 to request \nCookie\n header.\n\n\n\n\nv1.26.1\n\n\n\n\nFix for #17. Cookie can now parse a cookie without attributes and ending in semicolon.\n\n\n\n\nv1.26.0\n\n\n\n\nAdded nestable Routers.\n\n\nMerging of Modules and Routers. \nRouter\n is the new \nModule\n! \nRouteModule\n is now \nContractRouter\n, so rename in code will be required.\n\n\n\n\nv1.25.1\n\n\n\n\nFix for #15. OkHttp client handling of POSTs with no body.\n\n\n\n\nv1.25.0\n\n\n\n\nCan add custom mime types to Static Content\n\n\nGenerateDataClasses is capable of more complex object graphs\n\n\n\n\nv1.24.0\n\n\n\n\nRemove \nHttpHandler.asServer\n in favour of \nHttpHandler.startServer\n to avoid confusion.\n\n\nIntroduce \nStatus.description()\n.\n\n\n\n\nv1.23.0\n\n\n\n\nNetty sets content-length header.\n\n\n\n\nv1.22.2\n\n\n\n\nFix for #12. Undertow not constructing response correctly.\n\n\n\n\nv1.22.0\n\n\n\n\nNew module with Undertow.io support \nhttp4k-server-undertow\n\n\nJackson implementation now ignores unknown properties in incoming messages\n\n\nNetty implementation tidied up\n\n\n\n\nv1.21.1\n\n\n\n\nFix for #11. Netty implementation returns incorrect status codes.\n\n\n\n\nv1.21.0\n\n\n\n\nAdd synonym methods for Lenses to aid readability. We now have \ninvoke(IN)/extract(IN)\n and `invoke(IN, TARGET)/inject(IN, TARGET)\n\n\n\n\nv1.20.0\n\n\n\n\nhttp4k-contracts\n: Add option to change the route of the module description route\n\n\n\n\nv1.19.1\n\n\n\n\nhttp4k-contracts\n: Fix for contract module description routes not being authenticated via security filter\n\n\n\n\nv1.19.0\n\n\n\n\nhttp4k-contracts\n: Add \nSwagger\n module rendering with JSON schema models for messages.\n\n\n\n\nv1.18.0\n\n\n\n\nAdd \nnonEmptyString()\n lens type to all request parts.\n\n\n\n\nv1.17.0\n\n\n\n\nGeneral rework\n\n\n\n\nv1.16.0\n\n\n\n\nFurther work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios.\n\n\n\n\nv1.15.0\n\n\n\n\nPath lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc.\n\n\nRoutes can now create shell Requests for themselves, using \nroute.newRequest()\n\n\n\n\nv1.14.0\n\n\n\n\nBody is now non-nullable (use \nBody.EMPTY\n instead)\n\n\nRename methods \nBodyLens\n API for consistency and clarity. \nrequired()\n is now \ntoLens()\n. \nto()' binding method is now\nof().\n\n\n\n\nv1.13.0\n\n\n\n\nNew client module: \nhttp4k-client-okhttp\n\n\n\n\nv1.12.0\n\n\n\n\nTidying\n\n\n\n\nv1.11.0\n\n\n\n\nAdded option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :)\n\n\n\n\nv1.10.0\n\n\n\n\nMoved \nCredentials\n to \norg.http4k.core\n package.\n\n\nAdd various filters, including \nSetHostFrom\n and \nCatchAll\n.\n\n\n\n\nv1.9.0\n\n\n\n\nAdded \nGenerateDataClasses\n so you can generate Kotlin data classes from JSON messages.\n\n\n\n\nv1.8.0\n\n\n\n\nAdded CORs support\n\n\n\n\nv1.7.0\n\n\n\n\nAdded auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses\n\n\n\n\nv1.6.0\n\n\n\n\nAdded CachingFilters\n\n\n\n\nv1.5.0\n\n\n\n\nRemoved static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions.\n\n\nMerge \norg.http4k.core.Body\n and \norg.http4k.lens.Body\n.\n\n\nAdd Request/Response message parsers.\n\n\n\n\nv1.4.0\n\n\n\n\nTurn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected.\n\n\n\n\nv1.3.0\n\n\n\n\nRemoved non-mandatory parameters from Request and Response constructors. This is aid API clarity.\nand force users to use the API methods for properly constructing the objects.\n\n\nRegex Lens added.\n\n\n\n\nv1.0.0\n\n\n\n\nInitial major release.", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#v2380", 
            "text": "RequestContextKey  now follow the standardised Lens structure of required, optional, defaulted, and can now be removed (set to null). Replace calls\nto  RequestContextKey.of()  with  RequestContextKey.required()    Removed previously deprecated values. See below for details on replacements.", 
            "title": "v2.38.0"
        }, 
        {
            "location": "/changelog/#v2370", 
            "text": "Added  http4k-resilience4j  module, which adds Circuits, RateLimiters, Retrying and Bulkheading.  Fix #60 (H/T @michaelhixson for the spot).", 
            "title": "v2.37.0"
        }, 
        {
            "location": "/changelog/#v2360", 
            "text": "Added a couple of useful  ServerFilters .  Upgrade various dependency versions.  Tidying of Multipart code.", 
            "title": "v2.36.0"
        }, 
        {
            "location": "/changelog/#v2351", 
            "text": "Fix #57. Static handlers behave oddly when combined with an HTTP verb in the routing tree.", 
            "title": "v2.35.1"
        }, 
        {
            "location": "/changelog/#v2350", 
            "text": "Fix #56. Altered behaviour of  CatchLensFailure  to NOT catch errors from unmarshalling Response objects. This was causing BAD_REQUEST to be incorrectly generated.  Simplification of generics around LensSpecs. This should not be a breaking change, (there were 3 generics, now the MID has been removed so there are just 2) but could break if signatures are used explicitly.", 
            "title": "v2.35.0"
        }, 
        {
            "location": "/changelog/#v2340", 
            "text": "Reordered generics in LensInjector to make sense. This should have no effect on most code-bases, but could break if signatures are used explicitly. Just flip the generic types to switch.", 
            "title": "v2.34.0"
        }, 
        {
            "location": "/changelog/#v2331", 
            "text": "Added support for unsigned AWS requests, which enables streaming content to S3.", 
            "title": "v2.33.1"
        }, 
        {
            "location": "/changelog/#v2330", 
            "text": "Added  BodyMode.Request  to configure streaming for clients.  ResponseBodyMode  is now  BodyMode.Response  (Breaking change. Fixable with simple find/replace).", 
            "title": "v2.33.0"
        }, 
        {
            "location": "/changelog/#v2320", 
            "text": "Added  ServerFilter.ProcessFiles  filter to stream Multipart Files, convert them into references and replace inline in the Form.", 
            "title": "v2.32.0"
        }, 
        {
            "location": "/changelog/#v2314", 
            "text": "Avoid realising StreamBody unless necessary, which could break common usages of streaming.", 
            "title": "v2.31.4"
        }, 
        {
            "location": "/changelog/#v2313", 
            "text": "Tweaks to Server backends to improve efficiency.", 
            "title": "v2.31.3"
        }, 
        {
            "location": "/changelog/#v2312", 
            "text": "Webdriver will keep only the final URI after redirects.", 
            "title": "v2.31.2"
        }, 
        {
            "location": "/changelog/#v2311", 
            "text": "Increased granularity of  Replay.DiskStream  and ensure that traffic is returned in exact order on all OSes.  Add support for redirects to Webdriver.", 
            "title": "v2.31.1"
        }, 
        {
            "location": "/changelog/#v2310", 
            "text": "Multipart module tweaked to provide a more consistent API.  Fix FollowRedirects for POST/PUT request.", 
            "title": "v2.31.0"
        }, 
        {
            "location": "/changelog/#v2300", 
            "text": "Multipart form support through new module  http4k-multipart .  Deprecation: Replaced  Swagger  with  OpenApi  and deprecated the former (via typealias).  Deprecation: Replaced  FormValidator  with  Validator  and deprecated the former (via typealias).", 
            "title": "v2.30.0"
        }, 
        {
            "location": "/changelog/#v2294", 
            "text": "Refactor release.", 
            "title": "v2.29.4"
        }, 
        {
            "location": "/changelog/#v2293", 
            "text": "Fix #50 - Webdriver does not normalise relative links correctly.", 
            "title": "v2.29.3"
        }, 
        {
            "location": "/changelog/#v2292", 
            "text": "Http client modules now catch and convert Socket Timeout exceptions to HTTP 504s (with a custom message)", 
            "title": "v2.29.2"
        }, 
        {
            "location": "/changelog/#v2291", 
            "text": "Tweaks to how recorded traffic is stored on disk. Thanks to @dkandalov for the PR around this.", 
            "title": "v2.29.1"
        }, 
        {
            "location": "/changelog/#v2290", 
            "text": "Added  TrafficFilters  for recording and replaying HTTP traffic. See  org.http4k.traffic  package for details.", 
            "title": "v2.29.0"
        }, 
        {
            "location": "/changelog/#v2280", 
            "text": "Added  http4k-template-dust  for Dust template engine support. Thanks to @npryce for the PR to add this.", 
            "title": "v2.28.0"
        }, 
        {
            "location": "/changelog/#v2272", 
            "text": "Fix #44 - Use quotes around cookie values", 
            "title": "v2.27.2"
        }, 
        {
            "location": "/changelog/#v2271", 
            "text": "Raise proper Exception (instead of LensFailure) when RequestContexts are not set up correctly, so we don't accidentally classify developer errors as BadRequests", 
            "title": "v2.27.1"
        }, 
        {
            "location": "/changelog/#v2270", 
            "text": "Added facility to assign values into a  RequestContext  which is passed down the Filter chain.", 
            "title": "v2.27.0"
        }, 
        {
            "location": "/changelog/#v2263", 
            "text": "Fix #44 - Request cookies should not be wrapped in quotes.", 
            "title": "v2.26.3"
        }, 
        {
            "location": "/changelog/#v2262", 
            "text": "Fix #43 - AWS does not sign binary requests correctly.", 
            "title": "v2.26.2"
        }, 
        {
            "location": "/changelog/#v2261", 
            "text": "Fix #41 - Sending binary body alters the size of the payload.", 
            "title": "v2.26.1"
        }, 
        {
            "location": "/changelog/#v2260", 
            "text": "Added \"catch all\" routing option, which matches all methods to a handler.", 
            "title": "v2.26.0"
        }, 
        {
            "location": "/changelog/#v2254", 
            "text": "Fix #40 - GZip filters now use content-encoding headers instead of transfer-encoding.", 
            "title": "v2.25.4"
        }, 
        {
            "location": "/changelog/#v2253", 
            "text": "Fix #39 - ResponseBodyMode.Memory properly closes streams (breaks jetty + gzip).", 
            "title": "v2.25.3"
        }, 
        {
            "location": "/changelog/#v2252", 
            "text": "Ensure that streams are closed properly when consuming from an upstream client.", 
            "title": "v2.25.2"
        }, 
        {
            "location": "/changelog/#v2251", 
            "text": "Remove Apache client request streaming because it may not release connections properly.", 
            "title": "v2.25.1"
        }, 
        {
            "location": "/changelog/#v2250", 
            "text": "Add streaming support to HTTP Server and Client modules.  Remove CatchLensFailure ClientFilter as it will never be used.", 
            "title": "v2.25.0"
        }, 
        {
            "location": "/changelog/#v2240", 
            "text": "Added CatchLensFailure for ClientFilters - which catches un-deserializable invalid responses from clients and generates a BAD_GATEWAY error.", 
            "title": "v2.24.0"
        }, 
        {
            "location": "/changelog/#v2234", 
            "text": "Switch XML generation to Gson over Jackson because Jackson doesn't handle uppercase field names well.  Switch native XML parsed type to Document over Node.", 
            "title": "v2.23.4"
        }, 
        {
            "location": "/changelog/#v2233", 
            "text": "New algorithm for XML data class deserialisation, so un-deprecated XML methods.", 
            "title": "v2.23.3"
        }, 
        {
            "location": "/changelog/#v2232", 
            "text": "Deprecated methods in XML support due to limitation with underlying Jackson implementation.", 
            "title": "v2.23.2"
        }, 
        {
            "location": "/changelog/#v2231", 
            "text": "Fixed bug with GenerateXmlDataClasses filter", 
            "title": "v2.23.1"
        }, 
        {
            "location": "/changelog/#v2230", 
            "text": "Renamed  http4k-format-jackson-xml  module to  http4k-format-xml .  Improved XML unmarshalling support.", 
            "title": "v2.23.0"
        }, 
        {
            "location": "/changelog/#v2221", 
            "text": "Fixed 36: Form entry is too strict with content encoding.", 
            "title": "v2.22.1"
        }, 
        {
            "location": "/changelog/#v2220", 
            "text": "Added  http4k-format-jackson-xml  module, with XML parsing support.  Upgrade several dependencies", 
            "title": "v2.22.0"
        }, 
        {
            "location": "/changelog/#v2212", 
            "text": "Fixed Hamkrest matchers to be on HttpMessage and not Http Request.", 
            "title": "v2.21.2"
        }, 
        {
            "location": "/changelog/#v2211", 
            "text": "Default body Content Negotiation strategy changed to None", 
            "title": "v2.21.1"
        }, 
        {
            "location": "/changelog/#v2210", 
            "text": "Converted Content-Negotiation strategy from an Enum to an interface, so that users can define their own strategies. We also now check encoding so there are 4-built in strategies to choose from: Strict, StrictNoDirective, NonStrict and None.", 
            "title": "v2.21.0"
        }, 
        {
            "location": "/changelog/#v2201", 
            "text": "Fixed #31 - Matching of segments in URIs is done after URLs are decoded, which results in not capturing encoded slashes in the path segments.", 
            "title": "v2.20.1"
        }, 
        {
            "location": "/changelog/#v2200", 
            "text": "Fixed #30 - CachingClasspath template ResourceLoader not working with non-root packages.", 
            "title": "v2.20.0"
        }, 
        {
            "location": "/changelog/#v2190", 
            "text": "Fixed #29 - webdriver submission of text area.  Http clients now use a new instance of the default for each instantiation. Previously there was a shared instance.  Add regex body type for parsing values out of bodies, and \"None\" option for content negotiation.", 
            "title": "v2.19.0"
        }, 
        {
            "location": "/changelog/#v2183", 
            "text": "Fix AWS request signing for requests containing empty path", 
            "title": "v2.18.3"
        }, 
        {
            "location": "/changelog/#v2182", 
            "text": "Fix AWS request signing for requests containing path with special characters", 
            "title": "v2.18.2"
        }, 
        {
            "location": "/changelog/#v2181", 
            "text": "Added support for newRequest() in new  RouteBinder  mechanic.", 
            "title": "v2.18.1"
        }, 
        {
            "location": "/changelog/#v2180", 
            "text": "Add support for unlimited nesting for  routes()  blocks. Removed the raw  Route  object, which can be replaced with  Router  or  RoutingHttpHandler  where appropriate.  As part of above, rejigged route setup logic. Deprecated old routing structure, so now   \"/path\" to GET bind  is  \"/path\" bind GET to . To fix deprecation, simply switch the calls to \"to\" and \"bind\" in routing setup.   Rename of  bind()  in  http4k-contract  to be  bindContract()", 
            "title": "v2.18.0"
        }, 
        {
            "location": "/changelog/#v2172", 
            "text": "Added missing eclectic HTTP method. :)", 
            "title": "v2.17.2"
        }, 
        {
            "location": "/changelog/#v2171", 
            "text": "Added GZip filters to  http4k-core  to zip request and response bodies.", 
            "title": "v2.17.1"
        }, 
        {
            "location": "/changelog/#v2161", 
            "text": "Improved messages for  http4k-testing-hamkrest  matchers.", 
            "title": "v2.16.1"
        }, 
        {
            "location": "/changelog/#v2160", 
            "text": "Added  http4k-testing-hamkrest  which contains a set of Hamkrest matchers for Http4k objects.", 
            "title": "v2.16.0"
        }, 
        {
            "location": "/changelog/#v2150", 
            "text": "More features for  http4k-testing-webdriver . Cookie support added.", 
            "title": "v2.15.0"
        }, 
        {
            "location": "/changelog/#v2140", 
            "text": "More features for  http4k-testing-webdriver . We now support Form entry and submission.", 
            "title": "v2.14.0"
        }, 
        {
            "location": "/changelog/#v2130", 
            "text": "More features for  http4k-testing-webdriver .", 
            "title": "v2.13.0"
        }, 
        {
            "location": "/changelog/#v2120", 
            "text": "Added  http4k-testing-webdriver  module, an ultralight Selenium WebDriver for  http4k  apps", 
            "title": "v2.12.0"
        }, 
        {
            "location": "/changelog/#v2113", 
            "text": "Fix #26 - GenerateDataClasses does not recurse into nested object trees", 
            "title": "v2.11.3"
        }, 
        {
            "location": "/changelog/#v2112", 
            "text": "Fix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with  then(RoutingHttpHandler()", 
            "title": "v2.11.2"
        }, 
        {
            "location": "/changelog/#v2111", 
            "text": "Fix static routes not defaulting to index.html when in root context", 
            "title": "v2.11.1"
        }, 
        {
            "location": "/changelog/#v2110", 
            "text": "Added  SunHttp  server implementation (for development use only)", 
            "title": "v2.11.0"
        }, 
        {
            "location": "/changelog/#v2101", 
            "text": "Fix cookie parsing when value contains '='", 
            "title": "v2.10.1"
        }, 
        {
            "location": "/changelog/#v2100", 
            "text": "Add method to set form values in the request", 
            "title": "v2.10.0"
        }, 
        {
            "location": "/changelog/#v290", 
            "text": "Added PURGE HTTP method as it's used commonly by various caches.", 
            "title": "v2.9.0"
        }, 
        {
            "location": "/changelog/#v281", 
            "text": "Repackage AWS classes for consistency with rest of project", 
            "title": "v2.8.1"
        }, 
        {
            "location": "/changelog/#v271", 
            "text": "Alter AWS Auth filter creation. Now use  ClientFilters.AwsAuth", 
            "title": "v2.7.1"
        }, 
        {
            "location": "/changelog/#v270", 
            "text": "Add AWS module", 
            "title": "v2.7.0"
        }, 
        {
            "location": "/changelog/#v260", 
            "text": "Newly created Zipkin traces are now populated onto incoming request in ServerFilters.", 
            "title": "v2.6.0"
        }, 
        {
            "location": "/changelog/#v251", 
            "text": "Slight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling", 
            "title": "v2.5.1"
        }, 
        {
            "location": "/changelog/#v250", 
            "text": "Add  Thymeleaf  templating support", 
            "title": "v2.5.0"
        }, 
        {
            "location": "/changelog/#v240", 
            "text": "Add  Pebble  templating support", 
            "title": "v2.4.0"
        }, 
        {
            "location": "/changelog/#v230", 
            "text": "Make Route a Router so we can nest them together.", 
            "title": "v2.3.0"
        }, 
        {
            "location": "/changelog/#v221", 
            "text": "Remove excess \"charset\" from headers in Undertow.", 
            "title": "v2.2.1"
        }, 
        {
            "location": "/changelog/#v220", 
            "text": "Rename   by()  to  bind()  in routing for clarity.", 
            "title": "v2.2.0"
        }, 
        {
            "location": "/changelog/#v212", 
            "text": "Fix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex.", 
            "title": "v2.1.2"
        }, 
        {
            "location": "/changelog/#v210", 
            "text": "Added GSON full-auto functions to convert arbitary objects to/from JSON.", 
            "title": "v2.1.0"
        }, 
        {
            "location": "/changelog/#v205", 
            "text": "Fix #23. Contract now supports multi-part URL params (for hardcoded parts)", 
            "title": "v2.0.5"
        }, 
        {
            "location": "/changelog/#v204", 
            "text": "Fix #22. Uri template does not parse out correct path params when URL starts with a path part.", 
            "title": "v2.0.4"
        }, 
        {
            "location": "/changelog/#v203", 
            "text": "toString() implementations to aid debugging", 
            "title": "v2.0.3"
        }, 
        {
            "location": "/changelog/#v201", 
            "text": "Readded missing default parameter for  newRequest()  on RouteSpec", 
            "title": "v2.0.1"
        }, 
        {
            "location": "/changelog/#v200", 
            "text": "Breaking: Inversion of routing API.  GET to \"/someUri\"  is now  \"/someUri\" to GET  for consistency across the entire API.", 
            "title": "v2.0.0"
        }, 
        {
            "location": "/changelog/#v1331", 
            "text": "Reimplementation of  http4k-contract  API to match main routing API. Contracts are now nestable.", 
            "title": "v1.33.1"
        }, 
        {
            "location": "/changelog/#v1322", 
            "text": "Fix Filters being applied twice in  ContractRoutingHttpHandler", 
            "title": "v1.32.2"
        }, 
        {
            "location": "/changelog/#v1321", 
            "text": "More work on  http4k-contract  contract API", 
            "title": "v1.32.1"
        }, 
        {
            "location": "/changelog/#v1310", 
            "text": "Rework  http4k-contract  routing to be mounted in the same way as other  RoutingHttpHandlers", 
            "title": "v1.31.0"
        }, 
        {
            "location": "/changelog/#v1300", 
            "text": "Filters are now applied consistently to all Routers", 
            "title": "v1.30.0"
        }, 
        {
            "location": "/changelog/#v1290", 
            "text": "Tweak to DSL for defining StaticRouters", 
            "title": "v1.29.0"
        }, 
        {
            "location": "/changelog/#v1281", 
            "text": "Fix for #18: FollowRedirect will now work if location header includes charset information.", 
            "title": "v1.28.1"
        }, 
        {
            "location": "/changelog/#v1280", 
            "text": "New DSL for defining StaticRouters", 
            "title": "v1.28.0"
        }, 
        {
            "location": "/changelog/#v1270", 
            "text": "Merged StaticContent and StaticRouter and repackage of contract API into other packages", 
            "title": "v1.27.0"
        }, 
        {
            "location": "/changelog/#v1262", 
            "text": "Extend fix for #17 to request  Cookie  header.", 
            "title": "v1.26.2"
        }, 
        {
            "location": "/changelog/#v1261", 
            "text": "Fix for #17. Cookie can now parse a cookie without attributes and ending in semicolon.", 
            "title": "v1.26.1"
        }, 
        {
            "location": "/changelog/#v1260", 
            "text": "Added nestable Routers.  Merging of Modules and Routers.  Router  is the new  Module !  RouteModule  is now  ContractRouter , so rename in code will be required.", 
            "title": "v1.26.0"
        }, 
        {
            "location": "/changelog/#v1251", 
            "text": "Fix for #15. OkHttp client handling of POSTs with no body.", 
            "title": "v1.25.1"
        }, 
        {
            "location": "/changelog/#v1250", 
            "text": "Can add custom mime types to Static Content  GenerateDataClasses is capable of more complex object graphs", 
            "title": "v1.25.0"
        }, 
        {
            "location": "/changelog/#v1240", 
            "text": "Remove  HttpHandler.asServer  in favour of  HttpHandler.startServer  to avoid confusion.  Introduce  Status.description() .", 
            "title": "v1.24.0"
        }, 
        {
            "location": "/changelog/#v1230", 
            "text": "Netty sets content-length header.", 
            "title": "v1.23.0"
        }, 
        {
            "location": "/changelog/#v1222", 
            "text": "Fix for #12. Undertow not constructing response correctly.", 
            "title": "v1.22.2"
        }, 
        {
            "location": "/changelog/#v1220", 
            "text": "New module with Undertow.io support  http4k-server-undertow  Jackson implementation now ignores unknown properties in incoming messages  Netty implementation tidied up", 
            "title": "v1.22.0"
        }, 
        {
            "location": "/changelog/#v1211", 
            "text": "Fix for #11. Netty implementation returns incorrect status codes.", 
            "title": "v1.21.1"
        }, 
        {
            "location": "/changelog/#v1210", 
            "text": "Add synonym methods for Lenses to aid readability. We now have  invoke(IN)/extract(IN)  and `invoke(IN, TARGET)/inject(IN, TARGET)", 
            "title": "v1.21.0"
        }, 
        {
            "location": "/changelog/#v1200", 
            "text": "http4k-contracts : Add option to change the route of the module description route", 
            "title": "v1.20.0"
        }, 
        {
            "location": "/changelog/#v1191", 
            "text": "http4k-contracts : Fix for contract module description routes not being authenticated via security filter", 
            "title": "v1.19.1"
        }, 
        {
            "location": "/changelog/#v1190", 
            "text": "http4k-contracts : Add  Swagger  module rendering with JSON schema models for messages.", 
            "title": "v1.19.0"
        }, 
        {
            "location": "/changelog/#v1180", 
            "text": "Add  nonEmptyString()  lens type to all request parts.", 
            "title": "v1.18.0"
        }, 
        {
            "location": "/changelog/#v1170", 
            "text": "General rework", 
            "title": "v1.17.0"
        }, 
        {
            "location": "/changelog/#v1160", 
            "text": "Further work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios.", 
            "title": "v1.16.0"
        }, 
        {
            "location": "/changelog/#v1150", 
            "text": "Path lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc.  Routes can now create shell Requests for themselves, using  route.newRequest()", 
            "title": "v1.15.0"
        }, 
        {
            "location": "/changelog/#v1140", 
            "text": "Body is now non-nullable (use  Body.EMPTY  instead)  Rename methods  BodyLens  API for consistency and clarity.  required()  is now  toLens() .  to()' binding method is now of().", 
            "title": "v1.14.0"
        }, 
        {
            "location": "/changelog/#v1130", 
            "text": "New client module:  http4k-client-okhttp", 
            "title": "v1.13.0"
        }, 
        {
            "location": "/changelog/#v1120", 
            "text": "Tidying", 
            "title": "v1.12.0"
        }, 
        {
            "location": "/changelog/#v1110", 
            "text": "Added option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :)", 
            "title": "v1.11.0"
        }, 
        {
            "location": "/changelog/#v1100", 
            "text": "Moved  Credentials  to  org.http4k.core  package.  Add various filters, including  SetHostFrom  and  CatchAll .", 
            "title": "v1.10.0"
        }, 
        {
            "location": "/changelog/#v190", 
            "text": "Added  GenerateDataClasses  so you can generate Kotlin data classes from JSON messages.", 
            "title": "v1.9.0"
        }, 
        {
            "location": "/changelog/#v180", 
            "text": "Added CORs support", 
            "title": "v1.8.0"
        }, 
        {
            "location": "/changelog/#v170", 
            "text": "Added auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses", 
            "title": "v1.7.0"
        }, 
        {
            "location": "/changelog/#v160", 
            "text": "Added CachingFilters", 
            "title": "v1.6.0"
        }, 
        {
            "location": "/changelog/#v150", 
            "text": "Removed static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions.  Merge  org.http4k.core.Body  and  org.http4k.lens.Body .  Add Request/Response message parsers.", 
            "title": "v1.5.0"
        }, 
        {
            "location": "/changelog/#v140", 
            "text": "Turn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected.", 
            "title": "v1.4.0"
        }, 
        {
            "location": "/changelog/#v130", 
            "text": "Removed non-mandatory parameters from Request and Response constructors. This is aid API clarity.\nand force users to use the API methods for properly constructing the objects.  Regex Lens added.", 
            "title": "v1.3.0"
        }, 
        {
            "location": "/changelog/#v100", 
            "text": "Initial major release.", 
            "title": "v1.0.0"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributers' Guide\n\n\n\nThere are many ways in which you can contribute to the development of the library:\n\n\n\n\nGive us a Star on Github - you know you want to ;)\n\n\nQuestions can be directed towards the Gitter channel, or on Twitter \n@http4k\n\n\nFor issues, please describe giving as much detail as you can - including version and steps to recreate\n\n\n\n\npull requests\n\n\nIf there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR. \n\n\n\n\nJSON formats: create a new module with an implementation of \nJson\n by following the \nArgo\n example in the source.\n\n\nTemplating engines: create a new module with a \nTemplates\nimplementation by following the \nHandlebarsTemplates\n example in the source\n\n\n\n\ngeneral guidelines\n\n\n\n\nAt the moment, PRs should be sent to the master branch - this might change in future so check back everytime!\n\n\nSource/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions\n\n\nPR changes should have test coverage\n\n\nAll the PRs must pass the Travis CI jobs before merging them\n\n\n\n\nhttps://travis-ci.org/http4k/http4k\n\n\nTesting with default settings is required when push changes:\n\n\nsh\n./gradlew check\n\n\nFinancial contributions\n\n\nWe also welcome financial contributions in full transparency on our \nopen collective\n.\nAnyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.\n\n\nCredits\n\n\nContributors\n\n\nThank you to all the people who have already contributed to http4k!\n\n\n\nBackers\n\n\nThank you to all our backers! [\nBecome a backer\n]\n\n\n\n\nSponsors\n\n\nThank you to all our sponsors! (please ask your company to also support this open source project by \nbecoming a sponsor\n)", 
            "title": "Contribute/Support http4k"
        }, 
        {
            "location": "/contributing/#pull-requests", 
            "text": "If there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR.    JSON formats: create a new module with an implementation of  Json  by following the  Argo  example in the source.  Templating engines: create a new module with a  Templates implementation by following the  HandlebarsTemplates  example in the source", 
            "title": "pull requests"
        }, 
        {
            "location": "/contributing/#general-guidelines", 
            "text": "At the moment, PRs should be sent to the master branch - this might change in future so check back everytime!  Source/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions  PR changes should have test coverage  All the PRs must pass the Travis CI jobs before merging them   https://travis-ci.org/http4k/http4k  Testing with default settings is required when push changes:  sh\n./gradlew check", 
            "title": "general guidelines"
        }, 
        {
            "location": "/contributing/#financial-contributions", 
            "text": "We also welcome financial contributions in full transparency on our  open collective .\nAnyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.", 
            "title": "Financial contributions"
        }, 
        {
            "location": "/contributing/#credits", 
            "text": "", 
            "title": "Credits"
        }, 
        {
            "location": "/contributing/#contributors", 
            "text": "Thank you to all the people who have already contributed to http4k!", 
            "title": "Contributors"
        }, 
        {
            "location": "/contributing/#backers", 
            "text": "Thank you to all our backers! [ Become a backer ]", 
            "title": "Backers"
        }, 
        {
            "location": "/contributing/#sponsors", 
            "text": "Thank you to all our sponsors! (please ask your company to also support this open source project by  becoming a sponsor )", 
            "title": "Sponsors"
        }, 
        {
            "location": "/faq/", 
            "text": "Find here answers to the most common questions that we get asked about \nhttp4k\n\n\nGeneral\n\n\nQ. Is http4k a library or a framework?\n\n\nA.\n Although it has many of the features of a framework, we consider http4k to be a library which adds a common HTTP routing layer. Is it incredibly unopinionated and has been designed to not enforce design decisions on the API user. We use http4k for applications both large and small, using no DI framework.\n\n\nQ. Is http4k currently used in production?\n\n\nA.\n Absolutely! The library is currently in use serving the global traffic for a large academic publisher (easily serving 10s of millions of requests per day on a few nodes) and is also being used in production in at least 2 global Investment Banks (that we know of). If you're running http4k in production and would like to be listed on the site as an adopter, please get in touch.\n\n\nQ. Does http4k support an Async model? I need webscale!\n\n\nA.\n Not at the moment. Adding Async support is a decision that we are thinking about carefully so that we don't end up complicating the API. When we do add it, it'll probably use co-routines and they're still marked as experimental which is another reason we are holding off. As for the scaling arguments, see the above answer relating to production usage.\n\n\nAPI\n\n\nQ. I'm attempting to build HTTP messages using the API, but changes don't affect the object (e.g. calling \nrequest.body(\"hello\")\n)?\n\n\nA.\n \nhttp4k\n HTTP message objects are \nimmutable\n, so you need to chain or reassign the value from the method call to get the updated version.\n\n\nQ. Where are all the useful Filters defined?\n\n\nA.\n Filters are all in the \nimport org.http4k.filter\n package and are located as methods on a singleton \nobject\n relevant to their use:\n\n\n\n\norg.http4k.filter.CachingFilters.Request\n \n \norg.http4k.filter.CachingFilters.Response\n \n\n\norg.http4k.filter.ClientFilters\n\n\norg.http4k.filter.DebuggingFilters\n\n\norg.http4k.filter.ServerFilters\n \n\n\norg.http4k.filter.TrafficFilters\n\n\n\n\nLenses \n Auto-Marshalling\n\n\nQ. Where is the \nBody.auto\n method defined?\n\n\nA.\n \nBody.auto\n is an extension method which is declared on the parent singleton \nobject\n for each of the message libraries that supports auto-marshalling - eg. \nJackson\n, \nGson\n and \nXml\n. All of these objects are declared in the same package, so you need to add an import similar to:\n\nimport org.http4k.format.Jackson.auto\n\n\nQ. Declared with \nBody.auto\nList\nXXX\n().toLens()\n, my auto-marshalled List doesn't extract properly!\n\n\nA.\n This is a Jackson-ism. Use \nBody.auto\nArray\nMyIntWrapper\n().toLens()\n instead. Yes, it's annoying but we haven't found a way to turn if off.\n\n\nQ. Using Jackson, the Data class auto-marshalling is not working correctly when my JSON fields start with capital letters\n\n\nA.\n Because of the way in which the Jackson library works, uppercase field names are NOT supported. Either switch out to use \nhttp4k-format-gson\n (which has the same API), or annotate your Data class fields with \n@JsonAlias\n to get the deserialisation to work correctly.\n\n\nQ. My application uses Lenses, but when they fail I get an HTTP 500 instead of the promised 400.\n\n\nA.\n You forgot to add the \nServerFilters.CatchLensFailure\n filter to your Server stack.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#general", 
            "text": "Q. Is http4k a library or a framework?  A.  Although it has many of the features of a framework, we consider http4k to be a library which adds a common HTTP routing layer. Is it incredibly unopinionated and has been designed to not enforce design decisions on the API user. We use http4k for applications both large and small, using no DI framework.  Q. Is http4k currently used in production?  A.  Absolutely! The library is currently in use serving the global traffic for a large academic publisher (easily serving 10s of millions of requests per day on a few nodes) and is also being used in production in at least 2 global Investment Banks (that we know of). If you're running http4k in production and would like to be listed on the site as an adopter, please get in touch.  Q. Does http4k support an Async model? I need webscale!  A.  Not at the moment. Adding Async support is a decision that we are thinking about carefully so that we don't end up complicating the API. When we do add it, it'll probably use co-routines and they're still marked as experimental which is another reason we are holding off. As for the scaling arguments, see the above answer relating to production usage.", 
            "title": "General"
        }, 
        {
            "location": "/faq/#api", 
            "text": "Q. I'm attempting to build HTTP messages using the API, but changes don't affect the object (e.g. calling  request.body(\"hello\") )?  A.   http4k  HTTP message objects are  immutable , so you need to chain or reassign the value from the method call to get the updated version.  Q. Where are all the useful Filters defined?  A.  Filters are all in the  import org.http4k.filter  package and are located as methods on a singleton  object  relevant to their use:   org.http4k.filter.CachingFilters.Request     org.http4k.filter.CachingFilters.Response    org.http4k.filter.ClientFilters  org.http4k.filter.DebuggingFilters  org.http4k.filter.ServerFilters    org.http4k.filter.TrafficFilters", 
            "title": "API"
        }, 
        {
            "location": "/faq/#lenses-auto-marshalling", 
            "text": "Q. Where is the  Body.auto  method defined?  A.   Body.auto  is an extension method which is declared on the parent singleton  object  for each of the message libraries that supports auto-marshalling - eg.  Jackson ,  Gson  and  Xml . All of these objects are declared in the same package, so you need to add an import similar to: import org.http4k.format.Jackson.auto  Q. Declared with  Body.auto List XXX ().toLens() , my auto-marshalled List doesn't extract properly!  A.  This is a Jackson-ism. Use  Body.auto Array MyIntWrapper ().toLens()  instead. Yes, it's annoying but we haven't found a way to turn if off.  Q. Using Jackson, the Data class auto-marshalling is not working correctly when my JSON fields start with capital letters  A.  Because of the way in which the Jackson library works, uppercase field names are NOT supported. Either switch out to use  http4k-format-gson  (which has the same API), or annotate your Data class fields with  @JsonAlias  to get the deserialisation to work correctly.  Q. My application uses Lenses, but when they fail I get an HTTP 500 instead of the promised 400.  A.  You forgot to add the  ServerFilters.CatchLensFailure  filter to your Server stack.", 
            "title": "Lenses &amp; Auto-Marshalling"
        }, 
        {
            "location": "/support/", 
            "text": "In the first instance, try and see if there is a relevant example in the cookbook - more and more are being added all the time!\n\n\nFor issues, please describe giving as much detail as you can - including version and steps to recreate\n\n\nSlack room:\n #http4k @ \nkotlinlang.slack.com\n\n\nGitter channel:\n http4k/http4k @ \ngitter.im\n\n\nTwitter:\n \n@http4k\n\n\n\n\nLogo usage\n\n\nThe http4k logo design and branding are copyright 2017 to http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant \nbranding guidelines\n.", 
            "title": "Help & Support"
        }, 
        {
            "location": "/support/#logo-usage", 
            "text": "The http4k logo design and branding are copyright 2017 to http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant  branding guidelines .", 
            "title": "Logo usage"
        }
    ]
}