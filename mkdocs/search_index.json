{
    "docs": [
        {
            "location": "/", 
            "text": "http4k\n is an lightweight but fully-featured HTTP toolkit written in pure \nKotlin\n that enables the serving and consuming of HTTP services in a functional and consistent way. \nhttp4k\n applications are \njust\n Kotlin functions which can be mounted into a running backend. For example, here's a simple echo server:\n\n\nkotlin\n val app: HttpHandler = { request: Request -\n Response(OK).body(request.body) }\n val server = app.asServer(SunHttp(8000)).start()\n\n\nhttp4k\n consists of a core library, \nhttp4k-core\n, providing a base HTTP implementation + a number of capability abstractions (such as servers, clients, templating, websockets etc). These capabilities are then implemented in add-on modules.\n\n\nThe principles of \nhttp4k\n are:\n\n\n\n\nApplication as a Function:\n Based on the Twitter paper \n\"Your Server as a Function\"\n, all HTTP services can be composed \nof 2 types of simple function:\n\n\nHttpHandler:\n \n(Request) -\n Response\n - provides a remote call for processing a Request. \n\n\nFilter:\n \n(HttpHandler) -\n HttpHandler\n - adds Request/Response pre/post processing. These filters are composed to make stacks of reusable behaviour that can \nthen be applied to an \nHttpHandler\n.\n\n\n\n\n\n\nImmutability:\n All entities in the library are immutable unless their function explicitly disallows this.\n\n\nSymmetric:\n The \nHttpHandler\n interface is identical for both HTTP services and clients. This allows for simple offline testability of applications, as well as \nplugging together of services without HTTP container being required.\n\n\nDependency-lite:\n Apart the from Kotlin StdLib, \nhttp4k-core\n module has ZERO dependencies and weighs in at ~700kb. Add-on modules only have dependencies required for specific implementation.\n\n\nTestability\n Built by \nTDD\n enthusiasts, so supports \nsuper-easy\n mechanisms for both In and Out of Container testing of:\n\n\nindividual endpoints\n\n\napplications\n\n\nwebsockets\n\n\nfull suites of microservices\n\n\n\n\n\n\nModularity:\n Common behaviours are abstracted into the \nhttp4k-core\n module. Current add-on modules provide:\n\n\nPluggable HTTP client adapters for Apache, Jetty, OkHttp and Websockets\n\n\nPluggable Server backends: Single LOC Server spinup for Jetty, Netty, Undertow, Apache (Httpcore) and SunHttp. \n\n\nServerless backends: Test your application locally and then deploy it to AWS Lambda.\n\n\nTemplating support: Caching and Hot-Reload engine support for Handlebars, Pebble, Dust and Thymeleaf\n\n\nHTTP message adapters for Argo JSON, Gson JSON, Jackson JSON, Moshi JSON and XML - includes auto-marshalling capabilities to convert directly to Kotlin data classes.\n\n\nTypesafe, auto-validating, self-documenting (via OpenApi/Swagger) contracts for HTTP services\n\n\nAWS request signing: super-simple interactions with AWS services.\n\n\nMetrics gathering for performance analysis.\n\n\nMultipart form handling, including stream processing for uploaded files.\n\n\nResilience features: Circuits, retrying, rate limiting, bulkheading - via Resilience4J integration.\n\n\nSecurity: Simple, pluggable support for OAuth Auth Code Grant flow and ready made configurations to integrate with popular OAuth providers.\n\n\nTesting: Selenium WebDriver implementation for lightning fast, browserless testing of \nhttp4k\n apps\n\n\nTesting: Hamkrest Matchers for \nhttp4k\n objects.\n\n\n\n\n\n\n\n\nModule feature overview\n\n\n\n\nCore:\n \n\n\nBase HTTP handler and \nimmutable HTTP message\n objects, cookie handling. \n\n\nCommonly used HTTP functionalities provided as reusable Filters (caching, debugging, \nZipkin request tracing\n)\n\n\nPath-based routing\n, including nestable contexts\n\n\nTypesafe HTTP message construction/desconstruction and Request Contexts\n using Lenses\n\n\nStatic file-serving\n capability with \nCaching and Hot-Reload\n \n\n\nServlet implementation to allow \nplugin to any Servlet container\n\n\nLaunch applications in \n1LOC\n with an embedded \nSunHttp\n server backend (recommended for development use only)\n\n\nPath-based websockets\n including typesafe message marshalling using Lenses\n\n\nAPIs to \nrecord and replay\n HTTP traffic to disk or memory\n\n\nCore \nabstraction APIs\n implemented by the other modules \n\n\n\n\n\n\nClient:\n \n\n\n1LOC\n client adapters \n\n\nApache\n sync + async HTTP\n\n\nJetty\n HTTP (supports sync and async HTTP)\n\n\nOkHttp\n HTTP (supports sync and async HTTP)\n\n\nJava\n (bundled with \nhttp4k-core\n)\n\n\n\n\n\n\n1LOC\n WebSocket client, with blocking and non-blocking modes\n\n\n\n\n\n\nServer:\n\n\n1LOC\n server backend spinup for:\n\n\nJetty\n (including websocket support)\n\n\nNetty\n\n\nUndertow\n\n\nApache\n (from httpcore)\n\n\nSunHttp\n (bundled with \nhttp4k-core\n)\n\n\n\n\n\n\nAPI design allows for plugging into configurable instances of each\n\n\n\n\n\n\nServerless:\n\n\nImplement a single Factory method, then upload your\nhttp4k\napplications to AWS Lambda to be called from API Gateway. \n\n\n\n\n\n\nContracts:\n \n\n\nDefine \nTypesafe\n HTTP contracts, with required and optional path/query/header/bodies\n\n\nTypesafe\n path matching\n\n\nAuto-validation\n of incoming requests == \nzero boilerplate validation code\n\n\nSelf-documenting for all routes - eg. Built in support for live \nOpenApi/Swagger\n description endpoints including \nJSON Schema\n model breakdown. \n\n\n\n\n\n\nTemplating:\n \n\n\nPluggable\n templating system support for:\n\n\nDust\n \n\n\nHandlebars\n \n\n\nPebble\n\n\nThymeleaf\n\n\n\n\n\n\nCaching and \nHot-Reload\n template support\n\n\n\n\n\n\nMessage formats:\n \n\n\nConsistent API provides first class support for marshalling JSON to/from HTTP messages for:\n\n\nJackson\n - includes support for \nfully \nautomatic marshalling\n of Data classes\n)\n\n\nGson\n - includes support for \nfully \nautomatic marshalling\n of Data classes\n)\n\n\nMoshi\n - includes support for \nfully \nautomatic marshalling\n of Data classes\n)\n\n\nArgo\n - lightweight Java JSON API with zero dependencies.\n\n\nXml\n - includes support for \none way \nautomatic marshalling\n of Data classes\n)\n\n\n\n\n\n\n\n\n\n\nResilience:\n \n\n\nSupport for Circuits, Retrying, Rate-Limiting, Bulkheading via Resilience4J integration.\n\n\n\n\n\n\nMetrics:\n \n\n\nSupport for plugging http4k apps into micrometer\n\n\n\n\n\n\nMultipart:\n \n\n\nSupport for Multipart HTML forms, including Lens extensions for type-safe marshalling of fields.\n\n\n\n\n\n\nAWS:\n \n\n\nClient filter to allow super-simple interaction with AWS services (via request signing)\n\n\n\n\n\n\nOAuth Security\n \n\n\nImplement OAuth Authorisation Code Grant flow with a single Interface\n\n\nPre-configured\n OAuth for following providers:\n\n\nAuth0\n \n\n\nDropbox\n \n\n\nGoogle\n \n\n\nSoundcloud\n\n\n\n\n\n\n\n\n\n\nWebDriver:\n \n\n\nUltra-lightweight Selenium WebDriver implementation for \nhttp4k\n  application.\n\n\n\n\n\n\nHamkrest:\n \n\n\nA set of Hamkrest matchers for testing \nhttp4k\n  Request and Response messages.\n\n\n\n\n\n\n\n\nExample\n\n\nThis quick example is designed to convey the simplicity \n features of \nhttp4k\n . See also the \nquickstart\n for the simplest possible starting point.\n\n\nTo install, add these dependencies to your \nGradle\n file:\n\n\ndependencies\n \n{\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-core\n,\n \nversion:\n \n3.29.0\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-server-jetty\n,\n \nversion:\n \n3.29.0\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-client-okhttp\n,\n \nversion:\n \n3.29.0\n\n\n}\n\n\n\n\n\n\nThis \"Hello World\" style example (\n) demonstrates how to serve and consume HTTP services with dynamic routing:\n\n\npackage\n \ncookbook\n\n\n\nimport\n \norg.http4k.client.OkHttp\n\n\nimport\n \norg.http4k.core.Filter\n\n\nimport\n \norg.http4k.core.HttpHandler\n\n\nimport\n \norg.http4k.core.Method.GET\n\n\nimport\n \norg.http4k.core.Request\n\n\nimport\n \norg.http4k.core.Response\n\n\nimport\n \norg.http4k.core.Status.Companion.OK\n\n\nimport\n \norg.http4k.core.then\n\n\nimport\n \norg.http4k.filter.CachingFilters\n\n\nimport\n \norg.http4k.routing.bind\n\n\nimport\n \norg.http4k.routing.path\n\n\nimport\n \norg.http4k.routing.routes\n\n\nimport\n \norg.http4k.server.Jetty\n\n\nimport\n \norg.http4k.server.asServer\n\n\n\nfun\n \nmain\n(\nargs\n:\n \nArray\nString\n)\n \n{\n\n    \n// we can bind HttpHandlers (which are just functions from  Request -\n Response) to paths/methods to create a Route,\n\n    \n// then combine many Routes together to make another HttpHandler\n\n    \nval\n \napp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n        \n/ping\n \nbind\n \nGET\n \nto\n \n{\n \n_\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\npong!\n)\n \n},\n\n        \n/greet/{name}\n \nbind\n \nGET\n \nto\n \n{\n \nreq\n:\n \nRequest\n \n-\n\n            \nval\n \npath\n:\n \nString\n?\n \n=\n \nreq\n.\npath\n(\nname\n)\n\n            \nResponse\n(\nOK\n).\nbody\n(\nhello ${path ?: \nanon\n!\n}\n)\n\n        \n}\n\n    \n)\n\n\n    \n// call the handler in-memory without spinning up a server\n\n    \nval\n \ninMemoryResponse\n:\n \nResponse\n \n=\n \napp\n(\nRequest\n(\nGET\n,\n \n/greet/Bob\n))\n\n    \nprintln\n(\ninMemoryResponse\n)\n\n\n\n// Produces:\n\n\n//    HTTP/1.1 200 OK\n\n\n//\n\n\n//\n\n\n//    hello Bob\n\n\n    \n// this is a Filter - it performs pre/post processing on a request or response\n\n    \nval\n \ntimingFilter\n \n=\n \nFilter\n \n{\n\n        \nnext\n:\n \nHttpHandler\n \n-\n\n        \n{\n\n            \nrequest\n:\n \nRequest\n \n-\n\n            \nval\n \nstart\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n\n            \nval\n \nresponse\n \n=\n \nnext\n(\nrequest\n)\n\n            \nval\n \nlatency\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n \n-\n \nstart\n\n            \nprintln\n(\nRequest to ${request.uri} took ${latency}ms\n)\n\n            \nresponse\n\n        \n}\n\n    \n}\n\n\n    \n// we can \nstack\n filters to create reusable units, and then apply them to an HttpHandler\n\n    \nval\n \ncompositeFilter\n \n=\n \nCachingFilters\n.\nResponse\n.\nNoCache\n().\nthen\n(\ntimingFilter\n)\n\n    \nval\n \nfilteredApp\n:\n \nHttpHandler\n \n=\n \ncompositeFilter\n.\nthen\n(\napp\n)\n\n\n    \n// only 1 LOC to mount an app and start it in a container\n\n    \nfilteredApp\n.\nasServer\n(\nJetty\n(\n9000\n)).\nstart\n()\n\n\n    \n// HTTP clients are also HttpHandlers!\n\n    \nval\n \nclient\n:\n \nHttpHandler\n \n=\n \nOkHttp\n()\n\n\n    \nval\n \nnetworkResponse\n:\n \nResponse\n \n=\n \nclient\n(\nRequest\n(\nGET\n,\n \nhttp://localhost:9000/greet/Bob\n))\n\n    \nprintln\n(\nnetworkResponse\n)\n\n\n\n// Produces:\n\n\n//    Request to /api/greet/Bob took 1ms\n\n\n//    HTTP/1.1 200\n\n\n//    cache-control: private, must-revalidate\n\n\n//    content-length: 9\n\n\n//    date: Thu, 08 Jun 3.29.03:01:13 GMT\n\n\n//    expires: 0\n\n\n//    server: Jetty(9.3.16.v3.29.020)\n\n\n//\n\n\n//    hello Bob\n\n\n}\n\n\n\n\n\n\nAcknowledgments\n\n\n\n\nDan Bodart\n's \nutterlyidle\n\n\nIvan Moore\n for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\"\n\n\n\n\n\n\nContributors\n\n\nThis project exists thanks to all the people who \ncontribute\n.\n\n\n\nBackers \n Sponsors\n\n\nIf you use \nhttp4k\n in your project or enterprise and would like to support ongoing development, please consider becoming a backer or a sponsor. Sponsor logos will show up here with a link to your website.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#module-feature-overview", 
            "text": "Core:    Base HTTP handler and  immutable HTTP message  objects, cookie handling.   Commonly used HTTP functionalities provided as reusable Filters (caching, debugging,  Zipkin request tracing )  Path-based routing , including nestable contexts  Typesafe HTTP message construction/desconstruction and Request Contexts  using Lenses  Static file-serving  capability with  Caching and Hot-Reload    Servlet implementation to allow  plugin to any Servlet container  Launch applications in  1LOC  with an embedded  SunHttp  server backend (recommended for development use only)  Path-based websockets  including typesafe message marshalling using Lenses  APIs to  record and replay  HTTP traffic to disk or memory  Core  abstraction APIs  implemented by the other modules     Client:    1LOC  client adapters   Apache  sync + async HTTP  Jetty  HTTP (supports sync and async HTTP)  OkHttp  HTTP (supports sync and async HTTP)  Java  (bundled with  http4k-core )    1LOC  WebSocket client, with blocking and non-blocking modes    Server:  1LOC  server backend spinup for:  Jetty  (including websocket support)  Netty  Undertow  Apache  (from httpcore)  SunHttp  (bundled with  http4k-core )    API design allows for plugging into configurable instances of each    Serverless:  Implement a single Factory method, then upload your http4k applications to AWS Lambda to be called from API Gateway.     Contracts:    Define  Typesafe  HTTP contracts, with required and optional path/query/header/bodies  Typesafe  path matching  Auto-validation  of incoming requests ==  zero boilerplate validation code  Self-documenting for all routes - eg. Built in support for live  OpenApi/Swagger  description endpoints including  JSON Schema  model breakdown.     Templating:    Pluggable  templating system support for:  Dust    Handlebars    Pebble  Thymeleaf    Caching and  Hot-Reload  template support    Message formats:    Consistent API provides first class support for marshalling JSON to/from HTTP messages for:  Jackson  - includes support for  fully  automatic marshalling  of Data classes )  Gson  - includes support for  fully  automatic marshalling  of Data classes )  Moshi  - includes support for  fully  automatic marshalling  of Data classes )  Argo  - lightweight Java JSON API with zero dependencies.  Xml  - includes support for  one way  automatic marshalling  of Data classes )      Resilience:    Support for Circuits, Retrying, Rate-Limiting, Bulkheading via Resilience4J integration.    Metrics:    Support for plugging http4k apps into micrometer    Multipart:    Support for Multipart HTML forms, including Lens extensions for type-safe marshalling of fields.    AWS:    Client filter to allow super-simple interaction with AWS services (via request signing)    OAuth Security    Implement OAuth Authorisation Code Grant flow with a single Interface  Pre-configured  OAuth for following providers:  Auth0    Dropbox    Google    Soundcloud      WebDriver:    Ultra-lightweight Selenium WebDriver implementation for  http4k   application.    Hamkrest:    A set of Hamkrest matchers for testing  http4k   Request and Response messages.", 
            "title": "Module feature overview"
        }, 
        {
            "location": "/#example", 
            "text": "This quick example is designed to convey the simplicity   features of  http4k  . See also the  quickstart  for the simplest possible starting point.  To install, add these dependencies to your  Gradle  file:  dependencies   { \n     compile   group:   org.http4k ,   name:   http4k-core ,   version:   3.29.0 \n     compile   group:   org.http4k ,   name:   http4k-server-jetty ,   version:   3.29.0 \n     compile   group:   org.http4k ,   name:   http4k-client-okhttp ,   version:   3.29.0  }   This \"Hello World\" style example ( ) demonstrates how to serve and consume HTTP services with dynamic routing:  package   cookbook  import   org.http4k.client.OkHttp  import   org.http4k.core.Filter  import   org.http4k.core.HttpHandler  import   org.http4k.core.Method.GET  import   org.http4k.core.Request  import   org.http4k.core.Response  import   org.http4k.core.Status.Companion.OK  import   org.http4k.core.then  import   org.http4k.filter.CachingFilters  import   org.http4k.routing.bind  import   org.http4k.routing.path  import   org.http4k.routing.routes  import   org.http4k.server.Jetty  import   org.http4k.server.asServer  fun   main ( args :   Array String )   { \n     // we can bind HttpHandlers (which are just functions from  Request -  Response) to paths/methods to create a Route, \n     // then combine many Routes together to make another HttpHandler \n     val   app :   HttpHandler   =   routes ( \n         /ping   bind   GET   to   {   _ :   Request   -   Response ( OK ). body ( pong! )   }, \n         /greet/{name}   bind   GET   to   {   req :   Request   - \n             val   path :   String ?   =   req . path ( name ) \n             Response ( OK ). body ( hello ${path ?:  anon ! } ) \n         } \n     ) \n\n     // call the handler in-memory without spinning up a server \n     val   inMemoryResponse :   Response   =   app ( Request ( GET ,   /greet/Bob )) \n     println ( inMemoryResponse )  // Produces:  //    HTTP/1.1 200 OK  //  //  //    hello Bob \n\n     // this is a Filter - it performs pre/post processing on a request or response \n     val   timingFilter   =   Filter   { \n         next :   HttpHandler   - \n         { \n             request :   Request   - \n             val   start   =   System . currentTimeMillis () \n             val   response   =   next ( request ) \n             val   latency   =   System . currentTimeMillis ()   -   start \n             println ( Request to ${request.uri} took ${latency}ms ) \n             response \n         } \n     } \n\n     // we can  stack  filters to create reusable units, and then apply them to an HttpHandler \n     val   compositeFilter   =   CachingFilters . Response . NoCache (). then ( timingFilter ) \n     val   filteredApp :   HttpHandler   =   compositeFilter . then ( app ) \n\n     // only 1 LOC to mount an app and start it in a container \n     filteredApp . asServer ( Jetty ( 9000 )). start () \n\n     // HTTP clients are also HttpHandlers! \n     val   client :   HttpHandler   =   OkHttp () \n\n     val   networkResponse :   Response   =   client ( Request ( GET ,   http://localhost:9000/greet/Bob )) \n     println ( networkResponse )  // Produces:  //    Request to /api/greet/Bob took 1ms  //    HTTP/1.1 200  //    cache-control: private, must-revalidate  //    content-length: 9  //    date: Thu, 08 Jun 3.29.03:01:13 GMT  //    expires: 0  //    server: Jetty(9.3.16.v3.29.020)  //  //    hello Bob  }", 
            "title": "Example"
        }, 
        {
            "location": "/#acknowledgments", 
            "text": "Dan Bodart 's  utterlyidle  Ivan Moore  for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\"", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/#contributors", 
            "text": "This project exists thanks to all the people who  contribute .", 
            "title": "Contributors"
        }, 
        {
            "location": "/#backers-sponsors", 
            "text": "If you use  http4k  in your project or enterprise and would like to support ongoing development, please consider becoming a backer or a sponsor. Sponsor logos will show up here with a link to your website.", 
            "title": "Backers &amp; Sponsors"
        }, 
        {
            "location": "/rationale/", 
            "text": "tldr;\n\n\nPresentation\n about the development of http4k given at the Kotlin London meetup.\n\n\nAbout\n\n\nhttp4k\n is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - \nthe routing module is inspired by \nUtterlyIdle\n, the \"Server as a function\" and filter model is stolen from \n\nFinagle\n, and the contract module OpenApi/Swagger generator is ported from \nFintrospect\n. With the growing \nadoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch.\n\n\nFor our purposes, we needed something that:\n\n\n\n\nStarts/stops ultra quickly.\n\n\nEasily testable outside of an HTTP container, and testing should require little to no custom infrastructure.\n\n\nProvides typesafe HTTP message deconstruction/construction (in this case via Lenses).\n\n\nAutomatically deals with contract breaches (missing/invalid params etc) to remove boilerplate.\n\n\nAbsolutely no magic involved: No reflection. No annotations.\n\n\nMinimal dependencies (apart from the Kotlin StdLib, \nhttp4k-core\n has zero).\n\n\nAutomatic generation of OpenApi/Swagger documentation (including JSON Schema models).\n\n\nHas a symmetric server/client API (\nHttpHandler\n should just be \nRequest -\n Response\n).\n\n\nHas immutable Request/Response objects.\n\n\n\n\nhttp4k\n ticks all of these boxes. \n\n\nIt allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers using a single line of code. The symmetric HTTP API also allows Filter chains (often called \"Middleware\" or \"Interceptors\" in other frameworks) to be constructed into reusable units/stacks for both \nserver and client sides (eg. logging/metrics/caching...) since they can be composed together for later use. \n\n\nAs a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests).\n\n\nScenarios such as \"what happens if this HTTP dependency continually takes \n 5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary.\n\n\nConcepts\n\n\n\n\nAll incoming and outgoing HTTP services are modelled as \nHttpHandler\n, which is modelled as \n(Request) -\n Response\n:\n\n\n\n\nval\n \nhandler\n:\n \nHttpHandler\n \n=\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n)\n \n}\n\n\n\n\n\n\n\n\nPre/post processing is done using a \nFilter\n, which is modelled as \n(HttpHandler) -\n HttpHandler\n. Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating \nHttpHandler\n - to yield \na decorated \nHttpHandler\n:\n\n\n\n\n    \nval\n \nfilter\n:\n \nFilter\n \n=\n \nFilter\n \n{\n \nnext\n:\n \nHttpHandler\n \n-\n\n        \n{\n \nrequest\n:\n \nRequest\n \n-\n \nnext\n(\nrequest\n).\nheader\n(\nmy response header\n,\n \nvalue\n)\n \n}\n\n    \n}\n\n    \nval\n \ndecorated\n:\n \nHttpHandler\n \n=\n \nfilter\n.\nthen\n(\nhandler\n)\n\n\n\n\n\n\n\n\nBinding an \nHttpHandler\n to a path and HTTP verb yields a \nRoutingHttpHandler\n, which is both an \nHttpHandler\n and a\nRouter\n:\n\n\n\n\nval\n \nroute\n:\n \nRoutingHttpHandler\n \n=\n \n/path\n \nbind\n \nGET\n \nto\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou GET bob\n)\n \n}\n\n\n\n\n\n\n\n\nRoutingHttpHandler\ns can be grouped together:\n\n\n\n\nval\n \napp\n:\n \nRoutingHttpHandler\n \n=\n \nroutes\n(\n\n    \nbob\n \nbind\n \nGET\n \nto\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou GET bob\n)\n \n},\n\n    \nrita\n \nbind\n \nPOST\n \nto\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou POST rita\n)\n \n},\n\n    \nsue\n \nbind\n \nDELETE\n \nto\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou DELETE sue\n)\n \n}\n\n\n)\n\n\n\n\n\n\n\n\nA \nRouter\n is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next \nRouter\n in the list.\n\n\nRouters\n can be combined together (under particular context roots) to form another \nRoutingHttpHandler\n:\n\n\n\n\nval\n \nbigApp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n    \n/this\n \nbind\n \napp\n,\n \n    \n/other\n \nbind\n \napp\n\n\n)\n\n\n\n\n\n\n\n\nHttpHandlers\n can be bound to a container (to create an \nHttp4kServer\n) with 1 LOC. The decouples the server implementation from the business logic:\n\n\n\n\nval\n \njettyServer\n \n=\n \napp\n.\nasServer\n(\nJetty\n(\n9000\n)).\nstart\n()\n\n\n\n\n\n\n\n\nAn Http client is also a \nHttpHandler\n:\n\n\n\n\nval\n \nclient\n:\n \nHttpHandler\n \n=\n \nApacheClient\n()\n\n\n\n\n\n\n\n\nBecause the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other:\n\n\n\n\n    \nval\n \napp1\n:\n \nHttpHandler\n \n=\n \nMyApp1\n()\n\n    \nval\n \napp2\n:\n \nHttpHandler\n \n=\n \nMyApp2\n(\napp1\n)", 
            "title": "Rationale & Concepts"
        }, 
        {
            "location": "/rationale/#tldr", 
            "text": "Presentation  about the development of http4k given at the Kotlin London meetup.", 
            "title": "tldr;"
        }, 
        {
            "location": "/rationale/#about", 
            "text": "http4k  is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - \nthe routing module is inspired by  UtterlyIdle , the \"Server as a function\" and filter model is stolen from  Finagle , and the contract module OpenApi/Swagger generator is ported from  Fintrospect . With the growing \nadoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch.  For our purposes, we needed something that:   Starts/stops ultra quickly.  Easily testable outside of an HTTP container, and testing should require little to no custom infrastructure.  Provides typesafe HTTP message deconstruction/construction (in this case via Lenses).  Automatically deals with contract breaches (missing/invalid params etc) to remove boilerplate.  Absolutely no magic involved: No reflection. No annotations.  Minimal dependencies (apart from the Kotlin StdLib,  http4k-core  has zero).  Automatic generation of OpenApi/Swagger documentation (including JSON Schema models).  Has a symmetric server/client API ( HttpHandler  should just be  Request -  Response ).  Has immutable Request/Response objects.   http4k  ticks all of these boxes.   It allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers using a single line of code. The symmetric HTTP API also allows Filter chains (often called \"Middleware\" or \"Interceptors\" in other frameworks) to be constructed into reusable units/stacks for both \nserver and client sides (eg. logging/metrics/caching...) since they can be composed together for later use.   As a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests).  Scenarios such as \"what happens if this HTTP dependency continually takes   5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary.", 
            "title": "About"
        }, 
        {
            "location": "/rationale/#concepts", 
            "text": "All incoming and outgoing HTTP services are modelled as  HttpHandler , which is modelled as  (Request) -  Response :   val   handler :   HttpHandler   =   {   request :   Request   -   Response ( OK )   }    Pre/post processing is done using a  Filter , which is modelled as  (HttpHandler) -  HttpHandler . Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating  HttpHandler  - to yield \na decorated  HttpHandler :        val   filter :   Filter   =   Filter   {   next :   HttpHandler   - \n         {   request :   Request   -   next ( request ). header ( my response header ,   value )   } \n     } \n     val   decorated :   HttpHandler   =   filter . then ( handler )    Binding an  HttpHandler  to a path and HTTP verb yields a  RoutingHttpHandler , which is both an  HttpHandler  and a Router :   val   route :   RoutingHttpHandler   =   /path   bind   GET   to   {   Response ( OK ). body ( you GET bob )   }    RoutingHttpHandler s can be grouped together:   val   app :   RoutingHttpHandler   =   routes ( \n     bob   bind   GET   to   {   Response ( OK ). body ( you GET bob )   }, \n     rita   bind   POST   to   {   Response ( OK ). body ( you POST rita )   }, \n     sue   bind   DELETE   to   {   Response ( OK ). body ( you DELETE sue )   }  )    A  Router  is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next  Router  in the list.  Routers  can be combined together (under particular context roots) to form another  RoutingHttpHandler :   val   bigApp :   HttpHandler   =   routes ( \n     /this   bind   app ,  \n     /other   bind   app  )    HttpHandlers  can be bound to a container (to create an  Http4kServer ) with 1 LOC. The decouples the server implementation from the business logic:   val   jettyServer   =   app . asServer ( Jetty ( 9000 )). start ()    An Http client is also a  HttpHandler :   val   client :   HttpHandler   =   ApacheClient ()    Because the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other:        val   app1 :   HttpHandler   =   MyApp1 () \n     val   app2 :   HttpHandler   =   MyApp2 ( app1 )", 
            "title": "Concepts"
        }, 
        {
            "location": "/installation/", 
            "text": "All \nhttp4k\n libraries are available on Maven Central and JCenter and are released under a single version. For the core module, add the following to your Gradle file:\n\n\ncompile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0", 
            "title": "Installation"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quickstart\n\n\nThis simple example demonstates how to serve and consume HTTP services using \nhttp4k\n. \n\n\nTo install, add these dependencies to your \nGradle\n file:\n\n\ndependencies\n \n{\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-core\n,\n \nversion:\n \n3.29.0\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-server-jetty\n,\n \nversion:\n \n3.29.0\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-client-apache\n,\n \nversion:\n \n3.29.0\n\n\n}\n\n\n\n\n\n\nThe following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it.\n\n\n\n\n\nSingle-line CD Bootstrap\n\n\nRun the single command in the readme of \nthis repo\n to create a HelloWorld \nhttp4k\n app with a full CD pipeline using Github -\n TravisCI -\n Heroku.\n\n\nWhy should I use this library?\n\n\nPresentation\n about the development of http4k given at the Kotlin London meetup.", 
            "title": "Getting started"
        }, 
        {
            "location": "/quickstart/#quickstart", 
            "text": "This simple example demonstates how to serve and consume HTTP services using  http4k .   To install, add these dependencies to your  Gradle  file:  dependencies   { \n     compile   group:   org.http4k ,   name:   http4k-core ,   version:   3.29.0 \n     compile   group:   org.http4k ,   name:   http4k-server-jetty ,   version:   3.29.0 \n     compile   group:   org.http4k ,   name:   http4k-client-apache ,   version:   3.29.0  }   The following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/quickstart/#single-line-cd-bootstrap", 
            "text": "Run the single command in the readme of  this repo  to create a HelloWorld  http4k  app with a full CD pipeline using Github -  TravisCI -  Heroku.", 
            "title": "Single-line CD Bootstrap"
        }, 
        {
            "location": "/quickstart/#why-should-i-use-this-library", 
            "text": "Presentation  about the development of http4k given at the Kotlin London meetup.", 
            "title": "Why should I use this library?"
        }, 
        {
            "location": "/guide/modules/aws/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-aws\", version: \"3.29.0\"\n\n\nAbout\n\n\nThis module provides super-simple AWS request signing functionality for talking to AWS services. Once configured with the correct keys, the various AWS services are actually really simple to integrate with they're just RESTy-type HTTPS services - the main difficulty is that all requests need to have their contents digitally signed with the AWS credentials to be authorised.\n\n\nhttp4k provides a \nFilter\n which does this request signing process. Just decorate a standard HTTP client and then make the relevant calls:\n\n\nCode", 
            "title": "AWS"
        }, 
        {
            "location": "/guide/modules/aws/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-aws\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/aws/#about", 
            "text": "This module provides super-simple AWS request signing functionality for talking to AWS services. Once configured with the correct keys, the various AWS services are actually really simple to integrate with they're just RESTy-type HTTPS services - the main difficulty is that all requests need to have their contents digitally signed with the AWS credentials to be authorised.  http4k provides a  Filter  which does this request signing process. Just decorate a standard HTTP client and then make the relevant calls:", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/aws/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/guide/modules/core/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-core\", version: \"3.29.0\"\n\n\nAbout\n\n\nApart from Kotlin StdLib, the core module has ZERO dependencies and provides the following:\n\n\n\n\nImmutable versions of the HTTP spec objects (Request, Response, Cookies etc).\n\n\nHTTP handler and filter abstractions which models services as simple, composable functions.\n\n\nSimple routing implementation, plus \nHttpHandlerServlet\n to enable plugging into any Servlet engine. \n\n\nLens\n mechanism for typesafe destructuring and construction of HTTP messages.\n\n\nTypesafe Request Context operations using Lenses.\n\n\nAbstractions for Servers, Clients, JSON Message formats, Templating, Websockets etc.\n\n\nSunHttp\n Ultra-fast single-LOC development server-backend\n\n\nStatic file-serving capability with \nCaching\n and \nHot-Reload\n\n\nAPIs to \nrecord and replay\n HTTP traffic to disk or memory\n\n\n\n\nHttpHandlers\n\n\nIn \nhttp4k\n, an HTTP service is just a typealias of a simple function:\n\n\ntypealias\n \nHttpHandler\n \n=\n \n(\nRequest\n)\n \n-\n \nResponse\n\n\n\n\n\n\nFirst described in this Twitter paper \n\"Your Server as a Function\"\n, this abstraction allows us lots of \nflexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an \nHttpHandler\n, neither do we \nneed to launch a real HTTP container to exercise it:\n\n\nval\n \nhandler\n \n=\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello, ${request.query(\nname\n)}!\n)\n \n}\n\n\nval\n \nget\n \n=\n \nRequest\n(\nMethod\n.\nGET\n,\n \n/\n).\nquery\n(\nname\n,\n \nJohn Doe\n)\n\n\nval\n \nresponse\n \n=\n \nhandler\n(\nget\n)\n\n\n\nprintln\n(\nresponse\n.\nstatus\n)\n\n\nprintln\n(\nresponse\n.\nbodyString\n())\n\n\n\n\n\n\nTo mount the \nHttpHandler\n in a container, the can simply be converted to a Servlet by calling \nhandler.asServlet()\n\n\nFilters\n\n\nFilters add extra processing to either the Request or Response. In \nhttp4k\n, they are modelled as:\n\n\ninterface\n \nFilter\n \n:\n \n(\nHttpHandler\n)\n \n-\n \nHttpHandler\n\n\n\n\n\n\nFilters are designed to simply compose together (using \nthen()\n) , creating reusable stacks of behaviour which can then be applied to any \nHttpHandler\n. \nFor example, to add Basic Auth and latency reporting to a service:\n\n\nval\n \nhandler\n \n=\n \n{\n \n_\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n)\n \n}\n\n\n\nval\n \nmyFilter\n \n=\n \nFilter\n \n{\n\n    \nnext\n:\n \nHttpHandler\n \n-\n \n{\n\n        \nrequest\n:\n \nRequest\n \n-\n \n            \nval\n \nstart\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n\n            \nval\n \nresponse\n \n=\n \nnext\n(\nrequest\n)\n\n            \nval\n \nlatency\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n \n-\n \nstart\n\n            \nprintln\n(\nI took $latency ms\n)\n\n            \nresponse\n\n    \n}\n\n\n}\n\n\nval\n \nlatencyAndBasicAuth\n:\n \nHttpHandler\n \n=\n \nServerFilters\n.\nBasicAuth\n(\nmy realm\n,\n \nuser\n,\n \npassword\n).\nthen\n(\nmyFilter\n)\n\n\nval\n \napp\n:\n \nHttpHandler\n \n=\n \nlatencyAndBasicAuth\n.\nthen\n(\nhandler\n)\n\n\n\n\n\n\nThe \nhttp4k-core\n module comes with a set of handy Filters for application to both Server and Client \nHttpHandlers\n, covering common things like:\n\n\n\n\nRequest tracing headers (x-b3-traceid etc)\n\n\nBasic Auth\n\n\nCache Control\n\n\nCORS\n\n\nCookie handling\n\n\nDebugging request and responses\n\n\n\n\nCheck out the \norg.http4k.filter\n package for the exact list.\n\n\nRouters - Nestable, path-based Routing\n\n\nCreate a Router using routes() to bind a static or dynamic path to either an HttpHandler, or to another sub-Router. These Routers can be nested infinitely deep and \nhttp4k\n will search for a matching route using a depth-first search algorithm, before falling back finally to a 404:\n\n\nroutes\n(\n\n    \n/hello\n \nbind\n \nroutes\n(\n\n        \n/{name:*}\n \nbind\n \nGET\n \nto\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello, ${request.path(\nname\n)}!\n)\n \n}\n\n    \n),\n\n    \n/fail\n \nbind\n \nPOST\n \nto\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nINTERNAL_SERVER_ERROR\n)\n \n}\n\n\n).\nasServer\n(\nJetty\n(\n8000\n)).\nstart\n()\n\n\n\n\n\n\nNote that the \nhttp4k-contract\n module contains a more typesafe implementation of routing functionality, with runtime-generated live documentation in OpenApi/Swagger format.\n\n\nTypesafe parameter destructuring/construction of HTTP messages with Lenses\n\n\nGetting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. \nFor this purpose, we can use a \nLens\n. \n\n\nA Lens is a bi-directional entity which can be used to either \nget\n or \nset\n a particular value from/onto an HTTP message. \nhttp4k\n provides a DSL \nto configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional). \n\n\nTo utilise a lens, first you have to declare it with the form \nLocation\n.\nconfiguration and mapping operations\n.\nterminator\n.\n\n\nThere is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location:\n\n\n\n\n\n\n\n\nLocation\n\n\nStarting type\n\n\nApplicable to\n\n\nMultiplicity\n\n\nRequirement terminator\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nQuery\n\n\nString\n\n\nRequest\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nQuery.optional(\"name\")\nQuery.required(\"name\")\nQuery.int().required(\"name\")\nQuery.localDate().multi.required(\"name\")\nQuery.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nHeader\n\n\nString\n\n\nRequest\n or \nResponse\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nHeader.optional(\"name\")\nHeader.required(\"name\")\nHeader.int().required(\"name\")\nHeader.localDate().multi.required(\"name\")\nHeader.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nPath\n\n\nString\n\n\nRequest\n\n\nSingular\n\n\nRequired\n\n\nPath.of(\"name\")\nPath.int().of(\"name\")\nPath.map(::CustomType, { it.value }).of(\"name\")\n\n\n\n\n\n\nFormField\n\n\nString\n\n\nWebForm\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nFormField.optional(\"name\")\nFormField.required(\"name\")\nFormField.int().required(\"name\")\nFormField.localDate().multi.required(\"name\")\nFormField.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nBody\n\n\nByteBuffer\n\n\nRequest\n or \nResponse\n\n\nSingular\n\n\nRequired\n\n\nBody.string(ContentType.TEXT_PLAIN).toLens()\nBody.json().toLens()\nBody.webForm(Validator.Strict, FormField.required(\"name\")).toLens()\n\n\n\n\n\n\n\n\nOnce the lens is declared, you can use it on a target object to either get or set the value:\n\n\n\n\nRetrieving a value: use \nlens\n.extract(\ntarget\n)\n, or the more concise invoke form: \nlens\n(\ntarget\n)\n\n\nSetting a value: use \nlens\n.inject(\nvalue\n, \ntarget\n)\n, or the more concise invoke form: \nlens\n(\nvalue\n, \ntarget\n)\n\n\n\n\nCode \n\n\n\n\n\nServing static assets\n\n\nFor serving static assets, just bind a path to a Static block as below, using either a Classpath or Directory (Hot reloading) based ResourceLoader instance (find these on the \nResourceLoader\n companion object). Typically, Directory is used during development and the Classpath strategy is used to serve assets in production from an UberJar. This is usually based on a \"devmode\" flag when constructing your app\":\n\n\nroutes\n(\n\n    \n/static\n \nbind\n \nstatic\n(\nClasspath\n(\n/org/http4k/some/package/name\n))\n\n    \n/hotreload\n \nbind\n \nstatic\n(\nDirectory\n(\npath/to/static/dir/goes/here\n))\n\n\n)\n\n\n\n\n\n\nTypesafe Websockets.\n\n\nWebsockets have been modeled using the same methodology as standard HTTP endpoints - ie. with both simplicity and testability as a first class concern, as well as benefiting from Lens-based typesafety. Websocket communication consists of 3 main concepts:\n\n\n\n\nWsHandler\n - represented as a typealias: \nWsHandler =  (Request) -\n WsConsumer?\n. This is responsible for matching an HTTP request to a websocket.\n\n\nWsConsumer\n - represented as a typealias: \nWsConsumer = (WebSocket) -\n Unit\n. This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket.\n\n\nWsMessage\n - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the \nhttp4k\n HTTP message model, WsMessages are immutable data classes.\n\n\n\n\nThe routing aspect of Websockets is done using a very similar API to the standard HTTP routing for HTTP messages and dynamic parts of the upgrade request are available when constructing a websocket instance:\n\n\ndata\n \nclass\n \nWrapper\n(\nval\n \nvalue\n:\n \nString\n)\n\n\n\nval\n \nbody\n \n=\n \nWsMessage\n.\nstring\n().\nmap\n(\n::\nWrapper\n,\n \nWrapper\n::\nvalue\n).\ntoLens\n()\n\n\n\nval\n \nnameLens\n \n=\n \nPath\n.\nof\n(\nname\n)\n\n\n\nval\n \nws\n:\n \nWsHandler\n \n=\n \nwebsockets\n(\n\n    \n/hello\n \nbind\n \nwebsockets\n(\n\n        \n/{name}\n \nbind\n \n{\n \nws\n:\n \nWebSocket\n \n-\n\n            \nval\n \nname\n \n=\n \nnameLens\n(\nws\n.\nupgradeRequest\n)\n\n            \nws\n.\nsend\n(\nWsMessage\n(\nhello $name\n))\n\n            \nws\n.\nonMessage\n \n{\n\n                \nval\n \nreceived\n \n=\n \nbody\n(\nit\n)\n\n                \nws\n.\nsend\n(\nbody\n(\nreceived\n))\n\n            \n}\n\n            \nws\n.\nonClose\n \n{\n\n                \nprintln\n(\nclosed\n)\n\n            \n}\n\n        \n}\n\n    \n)\n\n\n)\n\n\n\n\n\n\nA \nWsHandler\n can be combined with an \nHttpHandler\n into a \nPolyHandler\n and then mounted into a supported backend server using \nasServer()\n:\n\n\nval\n \napp\n \n=\n \nPolyHandler\n(\n\n    \nroutes\n(\n\n        \n/\n \nbind\n \n{\n \nr\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n)\n \n}\n\n    \n),\n\n    \nwebsockets\n(\n\n        \n/ws\n \nbind\n \n{\n \nws\n:\n \nWebSocket\n \n-\n \nws\n.\nsend\n(\nWsMessage\n(\nhello!\n))\n\n        \n}\n\n    \n)\n\n\n)\n\n\napp\n.\nasServer\n(\nJetty\n(\n9000\n)).\nstart\n()\n\n\n\n\n\n\nAlternatively, the \nWsHandler\n can be also converted to a synchronous \nWsClient\n - this allows testing to be done completely offline, which allows for super-fast tests:\n\n\nval\n \nclient\n \n=\n \napp\n.\ntestWsClient\n(\nRequest\n(\nMethod\n.\nGET\n,\n \nws://localhost:9000/hello/bob\n))\n!!\n\n\n\nclient\n.\nsend\n(\nWsMessage\n(\n1\n))\n\n\nclient\n.\nclose\n(\nStatus\n(\n200\n,\n \nbob\n))\n\n\n\nclient\n.\nreceived\n.\ntake\n(\n2\n).\nforEach\n(\n::\nprintln\n)\n\n\n\n\n\n\nRequest and Response toString()\n\n\nThe HttpMessages used by \nhttp4k\n toString in the HTTP wire format, which it simple to capture and replay HTTP message streams later in a similar way to tools like \nMountebank\n.\n\n\nCURL format\n\n\nCreates \ncurl\n command for a given request - this is useful to include in audit logs so exact requests can be replayed if required:\n\n\nval\n \ncurl\n \n=\n \nRequest\n(\nPOST\n,\n \nhttp://httpbin.org/post\n).\nbody\n(\nlistOf\n(\nfoo\n \nto\n \nbar\n).\ntoBody\n()).\ntoCurl\n()\n\n\n// curl -X POST --data \nfoo=bar\n \nhttp://httpbin.org/post", 
            "title": "Core"
        }, 
        {
            "location": "/guide/modules/core/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/core/#about", 
            "text": "Apart from Kotlin StdLib, the core module has ZERO dependencies and provides the following:   Immutable versions of the HTTP spec objects (Request, Response, Cookies etc).  HTTP handler and filter abstractions which models services as simple, composable functions.  Simple routing implementation, plus  HttpHandlerServlet  to enable plugging into any Servlet engine.   Lens  mechanism for typesafe destructuring and construction of HTTP messages.  Typesafe Request Context operations using Lenses.  Abstractions for Servers, Clients, JSON Message formats, Templating, Websockets etc.  SunHttp  Ultra-fast single-LOC development server-backend  Static file-serving capability with  Caching  and  Hot-Reload  APIs to  record and replay  HTTP traffic to disk or memory", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/core/#httphandlers", 
            "text": "In  http4k , an HTTP service is just a typealias of a simple function:  typealias   HttpHandler   =   ( Request )   -   Response   First described in this Twitter paper  \"Your Server as a Function\" , this abstraction allows us lots of \nflexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an  HttpHandler , neither do we \nneed to launch a real HTTP container to exercise it:  val   handler   =   {   request :   Request   -   Response ( OK ). body ( Hello, ${request.query( name )}! )   }  val   get   =   Request ( Method . GET ,   / ). query ( name ,   John Doe )  val   response   =   handler ( get )  println ( response . status )  println ( response . bodyString ())   To mount the  HttpHandler  in a container, the can simply be converted to a Servlet by calling  handler.asServlet()", 
            "title": "HttpHandlers"
        }, 
        {
            "location": "/guide/modules/core/#filters", 
            "text": "Filters add extra processing to either the Request or Response. In  http4k , they are modelled as:  interface   Filter   :   ( HttpHandler )   -   HttpHandler   Filters are designed to simply compose together (using  then() ) , creating reusable stacks of behaviour which can then be applied to any  HttpHandler . \nFor example, to add Basic Auth and latency reporting to a service:  val   handler   =   {   _ :   Request   -   Response ( OK )   }  val   myFilter   =   Filter   { \n     next :   HttpHandler   -   { \n         request :   Request   -  \n             val   start   =   System . currentTimeMillis () \n             val   response   =   next ( request ) \n             val   latency   =   System . currentTimeMillis ()   -   start \n             println ( I took $latency ms ) \n             response \n     }  }  val   latencyAndBasicAuth :   HttpHandler   =   ServerFilters . BasicAuth ( my realm ,   user ,   password ). then ( myFilter )  val   app :   HttpHandler   =   latencyAndBasicAuth . then ( handler )   The  http4k-core  module comes with a set of handy Filters for application to both Server and Client  HttpHandlers , covering common things like:   Request tracing headers (x-b3-traceid etc)  Basic Auth  Cache Control  CORS  Cookie handling  Debugging request and responses   Check out the  org.http4k.filter  package for the exact list.", 
            "title": "Filters"
        }, 
        {
            "location": "/guide/modules/core/#routers-nestable-path-based-routing", 
            "text": "Create a Router using routes() to bind a static or dynamic path to either an HttpHandler, or to another sub-Router. These Routers can be nested infinitely deep and  http4k  will search for a matching route using a depth-first search algorithm, before falling back finally to a 404:  routes ( \n     /hello   bind   routes ( \n         /{name:*}   bind   GET   to   {   request :   Request   -   Response ( OK ). body ( Hello, ${request.path( name )}! )   } \n     ), \n     /fail   bind   POST   to   {   request :   Request   -   Response ( INTERNAL_SERVER_ERROR )   }  ). asServer ( Jetty ( 8000 )). start ()   Note that the  http4k-contract  module contains a more typesafe implementation of routing functionality, with runtime-generated live documentation in OpenApi/Swagger format.", 
            "title": "Routers - Nestable, path-based Routing"
        }, 
        {
            "location": "/guide/modules/core/#typesafe-parameter-destructuringconstruction-of-http-messages-with-lenses", 
            "text": "Getting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. \nFor this purpose, we can use a  Lens .   A Lens is a bi-directional entity which can be used to either  get  or  set  a particular value from/onto an HTTP message.  http4k  provides a DSL \nto configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional).   To utilise a lens, first you have to declare it with the form  Location . configuration and mapping operations . terminator .  There is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location:     Location  Starting type  Applicable to  Multiplicity  Requirement terminator  Examples      Query  String  Request  Singular or multiple  Optional or Required  Query.optional(\"name\") Query.required(\"name\") Query.int().required(\"name\") Query.localDate().multi.required(\"name\") Query.map(::CustomType, { it.value }).required(\"name\")    Header  String  Request  or  Response  Singular or multiple  Optional or Required  Header.optional(\"name\") Header.required(\"name\") Header.int().required(\"name\") Header.localDate().multi.required(\"name\") Header.map(::CustomType, { it.value }).required(\"name\")    Path  String  Request  Singular  Required  Path.of(\"name\") Path.int().of(\"name\") Path.map(::CustomType, { it.value }).of(\"name\")    FormField  String  WebForm  Singular or multiple  Optional or Required  FormField.optional(\"name\") FormField.required(\"name\") FormField.int().required(\"name\") FormField.localDate().multi.required(\"name\") FormField.map(::CustomType, { it.value }).required(\"name\")    Body  ByteBuffer  Request  or  Response  Singular  Required  Body.string(ContentType.TEXT_PLAIN).toLens() Body.json().toLens() Body.webForm(Validator.Strict, FormField.required(\"name\")).toLens()     Once the lens is declared, you can use it on a target object to either get or set the value:   Retrieving a value: use  lens .extract( target ) , or the more concise invoke form:  lens ( target )  Setting a value: use  lens .inject( value ,  target ) , or the more concise invoke form:  lens ( value ,  target )", 
            "title": "Typesafe parameter destructuring/construction of HTTP messages with Lenses"
        }, 
        {
            "location": "/guide/modules/core/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/guide/modules/core/#serving-static-assets", 
            "text": "For serving static assets, just bind a path to a Static block as below, using either a Classpath or Directory (Hot reloading) based ResourceLoader instance (find these on the  ResourceLoader  companion object). Typically, Directory is used during development and the Classpath strategy is used to serve assets in production from an UberJar. This is usually based on a \"devmode\" flag when constructing your app\":  routes ( \n     /static   bind   static ( Classpath ( /org/http4k/some/package/name )) \n     /hotreload   bind   static ( Directory ( path/to/static/dir/goes/here ))  )", 
            "title": "Serving static assets"
        }, 
        {
            "location": "/guide/modules/core/#typesafe-websockets", 
            "text": "Websockets have been modeled using the same methodology as standard HTTP endpoints - ie. with both simplicity and testability as a first class concern, as well as benefiting from Lens-based typesafety. Websocket communication consists of 3 main concepts:   WsHandler  - represented as a typealias:  WsHandler =  (Request) -  WsConsumer? . This is responsible for matching an HTTP request to a websocket.  WsConsumer  - represented as a typealias:  WsConsumer = (WebSocket) -  Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket.  WsMessage  - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the  http4k  HTTP message model, WsMessages are immutable data classes.   The routing aspect of Websockets is done using a very similar API to the standard HTTP routing for HTTP messages and dynamic parts of the upgrade request are available when constructing a websocket instance:  data   class   Wrapper ( val   value :   String )  val   body   =   WsMessage . string (). map ( :: Wrapper ,   Wrapper :: value ). toLens ()  val   nameLens   =   Path . of ( name )  val   ws :   WsHandler   =   websockets ( \n     /hello   bind   websockets ( \n         /{name}   bind   {   ws :   WebSocket   - \n             val   name   =   nameLens ( ws . upgradeRequest ) \n             ws . send ( WsMessage ( hello $name )) \n             ws . onMessage   { \n                 val   received   =   body ( it ) \n                 ws . send ( body ( received )) \n             } \n             ws . onClose   { \n                 println ( closed ) \n             } \n         } \n     )  )   A  WsHandler  can be combined with an  HttpHandler  into a  PolyHandler  and then mounted into a supported backend server using  asServer() :  val   app   =   PolyHandler ( \n     routes ( \n         /   bind   {   r :   Request   -   Response ( OK )   } \n     ), \n     websockets ( \n         /ws   bind   {   ws :   WebSocket   -   ws . send ( WsMessage ( hello! )) \n         } \n     )  )  app . asServer ( Jetty ( 9000 )). start ()   Alternatively, the  WsHandler  can be also converted to a synchronous  WsClient  - this allows testing to be done completely offline, which allows for super-fast tests:  val   client   =   app . testWsClient ( Request ( Method . GET ,   ws://localhost:9000/hello/bob )) !!  client . send ( WsMessage ( 1 ))  client . close ( Status ( 200 ,   bob ))  client . received . take ( 2 ). forEach ( :: println )", 
            "title": "Typesafe Websockets."
        }, 
        {
            "location": "/guide/modules/core/#request-and-response-tostring", 
            "text": "The HttpMessages used by  http4k  toString in the HTTP wire format, which it simple to capture and replay HTTP message streams later in a similar way to tools like  Mountebank .", 
            "title": "Request and Response toString()"
        }, 
        {
            "location": "/guide/modules/core/#curl-format", 
            "text": "Creates  curl  command for a given request - this is useful to include in audit logs so exact requests can be replayed if required:  val   curl   =   Request ( POST ,   http://httpbin.org/post ). body ( listOf ( foo   to   bar ). toBody ()). toCurl ()  // curl -X POST --data  foo=bar   http://httpbin.org/post", 
            "title": "CURL format"
        }, 
        {
            "location": "/guide/modules/hamkrest/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-testing-hamkrest\", version: \"3.29.0\"\n\n\nAbout\n\n\nA set of Hamkrest matchers for use when testing \nhttp4k\n apps.\n\n\nCode", 
            "title": "Hamkrest"
        }, 
        {
            "location": "/guide/modules/hamkrest/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-testing-hamkrest\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/hamkrest/#about", 
            "text": "A set of Hamkrest matchers for use when testing  http4k  apps.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/hamkrest/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/guide/modules/clients/", 
            "text": "Installation (Gradle)\n\n\nJava (for development only):\n \ncompile group: \"org.http4k\", name: \"http4k-core\", version: \"3.29.0\"\n\n\nApache (Sync):\n \ncompile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"3.29.0\"\n\n\nApache (Async):\n \ncompile group: \"org.http4k\", name: \"http4k-client-apache-async\", version: \"3.29.0\"\n\n\nJetty (Sync + Async):\n \ncompile group: \"org.http4k\", name: \"http4k-client-jetty\", version: \"3.29.0\"\n\n\nOkHttp (Sync + Async):\n \ncompile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"3.29.0\"\n\n\nWebsocket:\n \ncompile group: \"org.http4k\", name: \"http4k-client-websocket\", version: \"3.29.0\"\n\n\nHTTP\n\n\nSupported HTTP client adapter APIs are wrapped to provide an \nHttpHandler\n interface in 1 LOC.\n\n\nActivate streaming mode by passing a \nBodyMode\n (default is non-streaming).\n\n\nThese examples are for the Apache HTTP client, but the API is similar for the others:\n\n\nCode \n\n\n\n\nAdditionally, all HTTP client adapter modules allow for custom configuration of the relevant underlying client. Async-supporting clients implement the \nAsyncHttpClient\n interface can be passed a callback.\n\n\nWebsocket\n\n\nhttp4k supplies both blocking and non-blocking Websocket clients. The former is perfect for integration testing purposes, and as it uses the same interface \nWsClient\n as the in-memory test client (\nWsHandler.testWsClient()\n) it is simple to write unit tests which can then be reused as system tests by virtue of swapping out the client.\n\n\nCode", 
            "title": "HTTP/Websocket client"
        }, 
        {
            "location": "/guide/modules/clients/#installation-gradle", 
            "text": "Java (for development only):   compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.29.0\"  Apache (Sync):   compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"3.29.0\"  Apache (Async):   compile group: \"org.http4k\", name: \"http4k-client-apache-async\", version: \"3.29.0\"  Jetty (Sync + Async):   compile group: \"org.http4k\", name: \"http4k-client-jetty\", version: \"3.29.0\"  OkHttp (Sync + Async):   compile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"3.29.0\"  Websocket:   compile group: \"org.http4k\", name: \"http4k-client-websocket\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/clients/#http", 
            "text": "Supported HTTP client adapter APIs are wrapped to provide an  HttpHandler  interface in 1 LOC.  Activate streaming mode by passing a  BodyMode  (default is non-streaming).  These examples are for the Apache HTTP client, but the API is similar for the others:", 
            "title": "HTTP"
        }, 
        {
            "location": "/guide/modules/clients/#code", 
            "text": "Additionally, all HTTP client adapter modules allow for custom configuration of the relevant underlying client. Async-supporting clients implement the  AsyncHttpClient  interface can be passed a callback.", 
            "title": "Code "
        }, 
        {
            "location": "/guide/modules/clients/#websocket", 
            "text": "http4k supplies both blocking and non-blocking Websocket clients. The former is perfect for integration testing purposes, and as it uses the same interface  WsClient  as the in-memory test client ( WsHandler.testWsClient() ) it is simple to write unit tests which can then be reused as system tests by virtue of swapping out the client.", 
            "title": "Websocket"
        }, 
        {
            "location": "/guide/modules/clients/#code_1", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/guide/modules/metrics/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-metrics-micrometer\", version: \"3.29.0\"\n\n\nAbout\n\n\nThis module provides configurable Filters to provide metrics for http4k apps, plugging into the awesome \nMicrometer\n library.\n\n\nMicrometer \n\n\nBoth Server and Client filters are available for recording request counts and latency, optionally overriding values for the metric names, descriptions and request identification.", 
            "title": "Metrics"
        }, 
        {
            "location": "/guide/modules/metrics/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-metrics-micrometer\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/metrics/#about", 
            "text": "This module provides configurable Filters to provide metrics for http4k apps, plugging into the awesome  Micrometer  library.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/metrics/#micrometer", 
            "text": "Both Server and Client filters are available for recording request counts and latency, optionally overriding values for the metric names, descriptions and request identification.", 
            "title": "Micrometer "
        }, 
        {
            "location": "/guide/modules/message_formats/", 
            "text": "Installation (Gradle)\n\n\nArgo:\n  \ncompile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"3.29.0\"\n\n\nGson:\n  \ncompile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"3.29.0\"\n\n\nJackson:\n \ncompile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.29.0\"\n\n\nMoshi:\n \ncompile group: \"org.http4k\", name: \"http4k-format-moshi\", version: \"3.29.0\"\n\n\nXml:\n \ncompile group: \"org.http4k\", name: \"http4k-format-xml\", version: \"3.29.0\"\n\n\nAbout\n\n\nThese modules add the ability to use JSON/XML as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of \nstandard methods and extension methods for converting common types into native JSON/XML objects, including custom Lens methods for each library so that \nJSON/XML node objects can be written and read directly from HTTP messages:\n\n\nCode \n\n\n\n\n\nAuto-marshalling capabilities\n\n\nSome of the message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection.\n\n\nWe can use this facility in \nhttp4k\n to automatically marshall objects to/from HTTP message bodies using \nLenses\n:\n\n\nJSON \n\n\n\n\n\nXML \n\n\n\n\n\nThere is a utility to generate Kotlin code for JSON and XML data class code \nhere\n . These data classes are compatible with using the \nBody.auto\nT\n()\n functionality. \n\n\nFAQ (aka gotchas) regarding Auto-marshalling capabilities\n\n\nUppercase JSON key names\n\n\nThe Jackson version of the automarshalling does NOT work for objects with uppercase key names - this is a known issue with the Jackson library and we are unable to fix it. Either use the GSON alternative, or annotate your Data class fields with \nJsonAlias\n annotations to work around this.\n\n\nJSON arrays\n\n\nWhen handling raw JSON array messages, such as: \n[123, 456, 567]\n, there is a slight gotcha when auto-marshalling messages from JSON.\n\n\nThis is demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list.\n\n\nAs shown, a workaround to this is to use \nBody.auto\nArray\nMyIntWrapper\n().toLens()\n instead, and then compare using \nArrays.equal()", 
            "title": "Message formats"
        }, 
        {
            "location": "/guide/modules/message_formats/#installation-gradle", 
            "text": "Argo:    compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"3.29.0\"  Gson:    compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"3.29.0\"  Jackson:   compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"3.29.0\"  Moshi:   compile group: \"org.http4k\", name: \"http4k-format-moshi\", version: \"3.29.0\"  Xml:   compile group: \"org.http4k\", name: \"http4k-format-xml\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/message_formats/#about", 
            "text": "These modules add the ability to use JSON/XML as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of \nstandard methods and extension methods for converting common types into native JSON/XML objects, including custom Lens methods for each library so that \nJSON/XML node objects can be written and read directly from HTTP messages:", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/message_formats/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/guide/modules/message_formats/#auto-marshalling-capabilities", 
            "text": "Some of the message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection.  We can use this facility in  http4k  to automatically marshall objects to/from HTTP message bodies using  Lenses :", 
            "title": "Auto-marshalling capabilities"
        }, 
        {
            "location": "/guide/modules/message_formats/#json", 
            "text": "", 
            "title": "JSON "
        }, 
        {
            "location": "/guide/modules/message_formats/#xml", 
            "text": "There is a utility to generate Kotlin code for JSON and XML data class code  here  . These data classes are compatible with using the  Body.auto T ()  functionality.", 
            "title": "XML "
        }, 
        {
            "location": "/guide/modules/message_formats/#faq-aka-gotchas-regarding-auto-marshalling-capabilities", 
            "text": "", 
            "title": "FAQ (aka gotchas) regarding Auto-marshalling capabilities"
        }, 
        {
            "location": "/guide/modules/message_formats/#uppercase-json-key-names", 
            "text": "The Jackson version of the automarshalling does NOT work for objects with uppercase key names - this is a known issue with the Jackson library and we are unable to fix it. Either use the GSON alternative, or annotate your Data class fields with  JsonAlias  annotations to work around this.", 
            "title": "Uppercase JSON key names"
        }, 
        {
            "location": "/guide/modules/message_formats/#json-arrays", 
            "text": "When handling raw JSON array messages, such as:  [123, 456, 567] , there is a slight gotcha when auto-marshalling messages from JSON.  This is demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list.  As shown, a workaround to this is to use  Body.auto Array MyIntWrapper ().toLens()  instead, and then compare using  Arrays.equal()", 
            "title": "JSON arrays"
        }, 
        {
            "location": "/guide/modules/multipart/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-multipart\", version: \"3.29.0\"\n\n\nAbout\n\n\nMultipart form support for fields and files, including a set of lens extensions for fields/files.\n\n\nSee the \ncookbook\n for example use.", 
            "title": "Multipart forms"
        }, 
        {
            "location": "/guide/modules/multipart/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-multipart\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/multipart/#about", 
            "text": "Multipart form support for fields and files, including a set of lens extensions for fields/files.  See the  cookbook  for example use.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/resilience/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-resilience4j\", version: \"3.29.0\"\n\n\nAbout\n\n\nThis module provides configurable Filters to provide CircuitBreaking, RateLimiting, Retrying and Bulkheading, by integrating with the awesome \nResilience4J\n library.\n\n\nCircuit Breaking \n\n\nA Circuit Filter detects failures and then Opens for a set period to allow the underlying system to recover.\n\n\n\n\n\nRate Limiting \n\n\nA RateLimit Filter monitors the number of requests over a set window.\n\n\n\n\n\nRetrying \n\n\nA Retrying Filter retries requests if a failure is generated.\n\n\n\n\n\nBulkheading \n\n\nA Bulkhead Filter limits the amount of parallel calls that can be executed.", 
            "title": "Resilience"
        }, 
        {
            "location": "/guide/modules/resilience/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-resilience4j\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/resilience/#about", 
            "text": "This module provides configurable Filters to provide CircuitBreaking, RateLimiting, Retrying and Bulkheading, by integrating with the awesome  Resilience4J  library.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/resilience/#circuit-breaking", 
            "text": "A Circuit Filter detects failures and then Opens for a set period to allow the underlying system to recover.", 
            "title": "Circuit Breaking "
        }, 
        {
            "location": "/guide/modules/resilience/#rate-limiting", 
            "text": "A RateLimit Filter monitors the number of requests over a set window.", 
            "title": "Rate Limiting "
        }, 
        {
            "location": "/guide/modules/resilience/#retrying", 
            "text": "A Retrying Filter retries requests if a failure is generated.", 
            "title": "Retrying "
        }, 
        {
            "location": "/guide/modules/resilience/#bulkheading", 
            "text": "A Bulkhead Filter limits the amount of parallel calls that can be executed.", 
            "title": "Bulkheading "
        }, 
        {
            "location": "/guide/modules/servers/", 
            "text": "Installation (Gradle)\n\n\nJetty:\n \ncompile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.29.0\"\n\n\nNetty:\n \ncompile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"3.29.0\"\n\n\nUndertow:\n \ncompile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"3.29.0\"\n\n\nSunHttp (for development only):\n \ncompile group: \"org.http4k\", name: \"http4k-core\", version: \"3.29.0\"\n\n\nApache:\n \ncompile group: \"org.http4k\", name: \"http4k-server-apache\", version: \"3.29.0\"\n\n\nAbout\n\n\nServer-backend modules provide a consistent API mount HttpHandlers into the specified container in 1 LOC, by simply passing a \nServerConfig\n implementation (in this case \nJetty\n):\n\n\n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello World\n)\n \n}.\nasServer\n(\nJetty\n(\n8000\n)).\nstart\n().\nblock\n()\n\n\n\n\n\n\nAlteratively, all server-backend modules allow for plugging \nhttp4k\n handlers into the relevant server API, which allows for custom Server configuration.", 
            "title": "Server backend"
        }, 
        {
            "location": "/guide/modules/servers/#installation-gradle", 
            "text": "Jetty:   compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"3.29.0\"  Netty:   compile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"3.29.0\"  Undertow:   compile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"3.29.0\"  SunHttp (for development only):   compile group: \"org.http4k\", name: \"http4k-core\", version: \"3.29.0\"  Apache:   compile group: \"org.http4k\", name: \"http4k-server-apache\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/servers/#about", 
            "text": "Server-backend modules provide a consistent API mount HttpHandlers into the specified container in 1 LOC, by simply passing a  ServerConfig  implementation (in this case  Jetty ):  {   request :   Request   -   Response ( OK ). body ( Hello World )   }. asServer ( Jetty ( 8000 )). start (). block ()   Alteratively, all server-backend modules allow for plugging  http4k  handlers into the relevant server API, which allows for custom Server configuration.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/serverless/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-serverless-lambda\", version: \"3.29.0\"\n\n\nAbout\n\n\nThese modules provide integration with Serverless deployment environments, such as AWS Lambda. \n\n\nAWS Lambda integration\n\n\nSince \nhttp4k\n is server independent, it turns out to be fairly trivial to deploy full applications to \nAWS Lambda\n, and then call them by setting up the \nAPI Gateway\n to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. This has the added bonus that you can test your applications in a local environment and then simply deploy them to AWS Lambda via S3 upload.\n\n\nIn order to achieve this, only a single interface \nAppLoader\n needs to be implemented.\n\n\nThis is far from a complete guide, but configuring AWS Lambda and the API Gateway involves several stages:\n\n\n\n\nUsers, Roles and Policies for the API Gateway and Lambda.\n\n\nAPI Gateway to proxy all requests to your Lambda.\n\n\nBuilding your http4k application into a standard UberJar.\n\n\nOptionally using Proguard to minify the JAR.\n\n\nPackage up the (minified) JAR into a standard Zip distribution.\n\n\n\n\nCreate and configure the Lambda function, and at the same time:\n\n\n\n\nUpload the standard Zip file to S3.\n\n\nSet the function execution to call the main http4k entry point: \norg.http4k.serverless.lambda.LambdaFunction::handle\n\n\nSet an environment variable for the Lambda \nHTTP4K_BOOTSTRAP_CLASS\n to the class of your \nAppLoader\n class.\n\n\n\n\n\n\n\n\nWe hope to soon provide some tools to automate at least some of the above process, or at least document it somewhat. However, AWS is a complicated beast and many people have a preferred way to set it up: CloudFormation templates, Serverless framework, Terraform, etc. In the meantime, here is an example of how the \nAppLoader\n is created and a sneak peak at launching the app locally:\n\n\nCode", 
            "title": "Serverless backend"
        }, 
        {
            "location": "/guide/modules/serverless/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-serverless-lambda\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/serverless/#about", 
            "text": "These modules provide integration with Serverless deployment environments, such as AWS Lambda.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/serverless/#aws-lambda-integration", 
            "text": "Since  http4k  is server independent, it turns out to be fairly trivial to deploy full applications to  AWS Lambda , and then call them by setting up the  API Gateway  to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library. This has the added bonus that you can test your applications in a local environment and then simply deploy them to AWS Lambda via S3 upload.  In order to achieve this, only a single interface  AppLoader  needs to be implemented.  This is far from a complete guide, but configuring AWS Lambda and the API Gateway involves several stages:   Users, Roles and Policies for the API Gateway and Lambda.  API Gateway to proxy all requests to your Lambda.  Building your http4k application into a standard UberJar.  Optionally using Proguard to minify the JAR.  Package up the (minified) JAR into a standard Zip distribution.   Create and configure the Lambda function, and at the same time:   Upload the standard Zip file to S3.  Set the function execution to call the main http4k entry point:  org.http4k.serverless.lambda.LambdaFunction::handle  Set an environment variable for the Lambda  HTTP4K_BOOTSTRAP_CLASS  to the class of your  AppLoader  class.     We hope to soon provide some tools to automate at least some of the above process, or at least document it somewhat. However, AWS is a complicated beast and many people have a preferred way to set it up: CloudFormation templates, Serverless framework, Terraform, etc. In the meantime, here is an example of how the  AppLoader  is created and a sneak peak at launching the app locally:", 
            "title": "AWS Lambda integration"
        }, 
        {
            "location": "/guide/modules/serverless/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/guide/modules/templating/", 
            "text": "Installation (Gradle)\n\n\nDust:\n \ncompile group: \"org.http4k\", name: \"http4k-template-dust\", version: \"3.29.0\"\n\n\nHandlebars:\n \ncompile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"3.29.0\"\n\n\nPebble:\n \ncompile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"3.29.0\"\n\n\nThymeleaf:\n \ncompile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"3.29.0\"\n\n\nAbout\n\n\nThe \nhttp4k\n templating API provides a standard mechanism for rendering using common templating libraries. Simply implement the \nViewModel\n interface on a model class and pass it to the renderer to get a string. All of the implementations support view rendering using the following strategies:\n\n\n\n\nCached on the classpath\n\n\nCached from the filesystem\n\n\nHot-Reloading from the filesystem\n\n\n\n\nThe examples below are for Handlebars, but the others have the same APIs:\n\n\nCode", 
            "title": "Templating"
        }, 
        {
            "location": "/guide/modules/templating/#installation-gradle", 
            "text": "Dust:   compile group: \"org.http4k\", name: \"http4k-template-dust\", version: \"3.29.0\"  Handlebars:   compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"3.29.0\"  Pebble:   compile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"3.29.0\"  Thymeleaf:   compile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/templating/#about", 
            "text": "The  http4k  templating API provides a standard mechanism for rendering using common templating libraries. Simply implement the  ViewModel  interface on a model class and pass it to the renderer to get a string. All of the implementations support view rendering using the following strategies:   Cached on the classpath  Cached from the filesystem  Hot-Reloading from the filesystem   The examples below are for Handlebars, but the others have the same APIs:", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/templating/#code", 
            "text": "", 
            "title": "Code  "
        }, 
        {
            "location": "/guide/modules/contracts/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \norg.http4k\n, name: \nhttp4k-contract\n, version: \n3.29.0\n\ncompile group: \norg.http4k\n, name: \nhttp4k-format-\ninsert json lib\n, version: \n3.29.0\n\n\n\n\n\n\nAbout\n\n\nThe \nhttp4k-contract\n module adds a much more sophisticated routing mechanism to that available in \nhttp4k-core\n. It adds the facility \nto declare server-side \nRoutes\n in a completely typesafe way, leveraging the Lens functionality from the core. These \nRoutes\n are \ncombined into \nRouteModules\n, which have the following features:\n\n\n\n\nAuto-validating\n - the \nRoute\n contract is automatically validated on each call for required-fields and type conversions, removing the requirement  for any validation code to be written by the API user. Invalid calls result in a \nHTTP 400\n (BAD_REQUEST)\n response.     \n\n\nSelf-describing:\n - a generated endpoint is provided which describes all of the \nRoutes\n in that module. Implementations include \nOpenApi/Swagger\n documentation, including generation of [JSON schema]\n(http://json-schema.org/) models for messages.\n\n\nSecurity:\n to secure the \nRoutes\n  against unauthorised access. Current implementations include \nApiKey\n.\n\n\n\n\nCode \n\n\n\n\n\nWhen launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module.\n\n\nFor a more extended example, see the following example apps: \n\n\n\n\nTodo backend (typesafe contract version)\n\n\nTDD'd example application", 
            "title": "Typesafe contracts"
        }, 
        {
            "location": "/guide/modules/contracts/#installation-gradle", 
            "text": "compile group:  org.http4k , name:  http4k-contract , version:  3.29.0 \ncompile group:  org.http4k , name:  http4k-format- insert json lib , version:  3.29.0", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/contracts/#about", 
            "text": "The  http4k-contract  module adds a much more sophisticated routing mechanism to that available in  http4k-core . It adds the facility \nto declare server-side  Routes  in a completely typesafe way, leveraging the Lens functionality from the core. These  Routes  are \ncombined into  RouteModules , which have the following features:   Auto-validating  - the  Route  contract is automatically validated on each call for required-fields and type conversions, removing the requirement  for any validation code to be written by the API user. Invalid calls result in a  HTTP 400\n (BAD_REQUEST)  response.       Self-describing:  - a generated endpoint is provided which describes all of the  Routes  in that module. Implementations include  OpenApi/Swagger  documentation, including generation of [JSON schema]\n(http://json-schema.org/) models for messages.  Security:  to secure the  Routes   against unauthorised access. Current implementations include  ApiKey .", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/contracts/#code", 
            "text": "When launched, OpenApi/Swagger format documentation (including JSON schema models) can be found at the route of the module.  For a more extended example, see the following example apps:    Todo backend (typesafe contract version)  TDD'd example application", 
            "title": "Code "
        }, 
        {
            "location": "/guide/modules/oauth/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.29.0\"\n\n\nAbout\n\n\nSupport for using integrating with external OAuth2 providers for authentication purposes and to provide access to external APIs of entities such as Auth0, Google etc. \n\n\nSpecifically, http4k supports the popular \nOAuth2 Authorization Code Grant\n. This flow provides a callback mechanism that plays out like this:\n\n\n\n\nApp developer (you!) creates an application on the OAuth provider and receives a \nClient Id\n and a \nClient Secret\n. You also provide a \"callback\" URL to the provider which will be used later.\n\n\nWhen accessing a protected resource, your app checks for an \nAccess Token\n from the user (via cookie or similar)\n\n\nIf the user has no token, the app redirects the user browser back to the OAuth provider site, along with the \"state\" of the user - containing a generated \nCrossSiteRequestForgeryToken\n (CSRF - which is also stored by the app) and the original URI the user was trying to access.\n\n\nThe user logs in on the OAuth provider site, which generates a code that is returned as a query parameter in a redirect back to the registered callback URL in your app, along with the CSRF token.\n\n\nYour app checks the content of the CSRF token to determine that the redirect is genuine, then sends the received code back to the OAuth provider in exchange for a valid \nAccessToken\n. This completes the flow\n\n\nThe \nAccessToken\n can then be used to access various services from the OAuth provider APIs.\n\n\n\n\nThere is a single user-defined interface, \nOAuthPersistence\n, required to implement to enable this flow. This interface is required to provide the custom way in which your application will store and retrieve the \nCSRF\n and \nAccessToken\n for a request. A common way to do this is through Cookies, but the values should definitely be encrypted. http4k only provides an insecure version of this class that you can use for testing. In order to remain provider-agnostic, the AccessToken object also contains the entirety of the (typically JSON) token response from the provider, which may include other fields depending on the types of scope for which your application is authorised by the user.\n\n\nTo enable OAuth integration, construct a configured instance of \nOAuthProvider\n. This provides 3 things:\n1. A filter to protect application resources\n1. A callback HttpHandler for the OAuth provider to redirect the authticated user to\n1. A fully configured API client (which populated the Host on the URI) - this allows different\nimplementations of the provider to be used across environments.\n\n\nExample provider \n\n\nOut of the box, http4k provides implementations for several OAuth providers.\n\n\n\n\n\nSee the \ncookbook\n for a custom implementation.", 
            "title": "OAuth"
        }, 
        {
            "location": "/guide/modules/oauth/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-security-oauth\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/oauth/#about", 
            "text": "Support for using integrating with external OAuth2 providers for authentication purposes and to provide access to external APIs of entities such as Auth0, Google etc.   Specifically, http4k supports the popular  OAuth2 Authorization Code Grant . This flow provides a callback mechanism that plays out like this:   App developer (you!) creates an application on the OAuth provider and receives a  Client Id  and a  Client Secret . You also provide a \"callback\" URL to the provider which will be used later.  When accessing a protected resource, your app checks for an  Access Token  from the user (via cookie or similar)  If the user has no token, the app redirects the user browser back to the OAuth provider site, along with the \"state\" of the user - containing a generated  CrossSiteRequestForgeryToken  (CSRF - which is also stored by the app) and the original URI the user was trying to access.  The user logs in on the OAuth provider site, which generates a code that is returned as a query parameter in a redirect back to the registered callback URL in your app, along with the CSRF token.  Your app checks the content of the CSRF token to determine that the redirect is genuine, then sends the received code back to the OAuth provider in exchange for a valid  AccessToken . This completes the flow  The  AccessToken  can then be used to access various services from the OAuth provider APIs.   There is a single user-defined interface,  OAuthPersistence , required to implement to enable this flow. This interface is required to provide the custom way in which your application will store and retrieve the  CSRF  and  AccessToken  for a request. A common way to do this is through Cookies, but the values should definitely be encrypted. http4k only provides an insecure version of this class that you can use for testing. In order to remain provider-agnostic, the AccessToken object also contains the entirety of the (typically JSON) token response from the provider, which may include other fields depending on the types of scope for which your application is authorised by the user.  To enable OAuth integration, construct a configured instance of  OAuthProvider . This provides 3 things:\n1. A filter to protect application resources\n1. A callback HttpHandler for the OAuth provider to redirect the authticated user to\n1. A fully configured API client (which populated the Host on the URI) - this allows different\nimplementations of the provider to be used across environments.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/oauth/#example-provider", 
            "text": "Out of the box, http4k provides implementations for several OAuth providers.   See the  cookbook  for a custom implementation.", 
            "title": "Example provider "
        }, 
        {
            "location": "/guide/modules/webdriver/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-testing-webdriver\", version: \"3.29.0\"\n\n\nAbout\n\n\nA basic Selenium WebDriver API implementation for \nhttp4k\n HttpHandlers, which runs completely out of container (no network) for ultra fast tests.\n\n\n\n\n\n\n\n\nFeature\n\n\nSupported\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nNavigation\n\n\nyes\n\n\nsimple back/forward/refresh history\n\n\n\n\n\n\nCSS selectors\n\n\nyes\n\n\n\n\n\n\n\n\nLink navigation\n\n\nyes\n\n\n\n\n\n\n\n\nForm field entry and submission\n\n\nyes\n\n\n\n\n\n\n\n\nCookie storage\n\n\nyes\n\n\nmanual expiry management\n\n\n\n\n\n\nJavaScript\n\n\nno\n\n\n\n\n\n\n\n\nAlerts\n\n\nno\n\n\n\n\n\n\n\n\nScreenshots\n\n\nno\n\n\n\n\n\n\n\n\nFrames\n\n\nno\n\n\n\n\n\n\n\n\nMultiple windows\n\n\nno\n\n\n\n\n\n\n\n\n\n\nUse the API like any other WebDriver implementation, by simply passing your app HttpHandler to construct it:\n\n\nCode", 
            "title": "WebDriver"
        }, 
        {
            "location": "/guide/modules/webdriver/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-testing-webdriver\", version: \"3.29.0\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/webdriver/#about", 
            "text": "A basic Selenium WebDriver API implementation for  http4k  HttpHandlers, which runs completely out of container (no network) for ultra fast tests.     Feature  Supported  Notes      Navigation  yes  simple back/forward/refresh history    CSS selectors  yes     Link navigation  yes     Form field entry and submission  yes     Cookie storage  yes  manual expiry management    JavaScript  no     Alerts  no     Screenshots  no     Frames  no     Multiple windows  no      Use the API like any other WebDriver implementation, by simply passing your app HttpHandler to construct it:", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/webdriver/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/guide/testing/", 
            "text": "The creators of \nhttp4k\n takes testing very seriously - so seriously that there really isn't that much to say here! \nThe API has been designed to make it as simple as possible to test both individual endpoints and entire applications in a consistent fashion, which is aided by remembering that:\n\n\n\n\nThe input and output \nRequest/Response\n objects are immutable.\n\n\nHttpHandlers\n are just functions.\n\n\nAn entire \nhttp4k\n application is \njust\n an \nHttpHandler\n.\n\n\n\n\nBecause of the above, there really isn't much required in the way of \"testing infrastructure\" - no magic containers or test fixtures that you might find in other frameworks. \nTesting is just matter of calling the correct function! Additionally, because the server and client HttpHandler interfaces are symmetrical - moving between in and out of container contexts \n(or indeed even to another HTTP framework entirely) is just a matter of switching out the HttpHandler implementation from the constructed app (out of container) to an HTTP client (in-container).\n\n\nThat said, possibly the most useful thing is to demonstrate the process that we have developed to test micro-services. A simple example of the development process can be found \n\nhere\n.\n\n\nTesting modules\n\n\nWe have developed the following modules to help with testing:\n\n\n\n\nhttp4k-testing-hamkrest\n: a set of composable Hamkrest matchers for matching \nhttp4k\n message objects against.\n\n\nhttp4k-testing-webdriver\n: an ultra-lightweight Selenium WebDriver implementation which can be used to test-drive \nhttp4k\n apps (ie. HttpHandlers).\n\n\n\n\nExample code for testing\n\n\nTesting HttpHandlers with static paths \n\n\n\n\nTesting HttpHandlers with dynamic paths \n\n\n\n\nTesting Filters \n\n\n\n\nTesting Websockets with offline and online clients", 
            "title": "Application Testing"
        }, 
        {
            "location": "/guide/testing/#testing-modules", 
            "text": "We have developed the following modules to help with testing:   http4k-testing-hamkrest : a set of composable Hamkrest matchers for matching  http4k  message objects against.  http4k-testing-webdriver : an ultra-lightweight Selenium WebDriver implementation which can be used to test-drive  http4k  apps (ie. HttpHandlers).", 
            "title": "Testing modules"
        }, 
        {
            "location": "/guide/testing/#example-code-for-testing", 
            "text": "", 
            "title": "Example code for testing"
        }, 
        {
            "location": "/guide/testing/#testing-httphandlers-with-static-paths", 
            "text": "", 
            "title": "Testing HttpHandlers with static paths "
        }, 
        {
            "location": "/guide/testing/#testing-httphandlers-with-dynamic-paths", 
            "text": "", 
            "title": "Testing HttpHandlers with dynamic paths "
        }, 
        {
            "location": "/guide/testing/#testing-filters", 
            "text": "", 
            "title": "Testing Filters "
        }, 
        {
            "location": "/guide/testing/#testing-websockets-with-offline-and-online-clients", 
            "text": "", 
            "title": "Testing Websockets with offline and online clients "
        }, 
        {
            "location": "/guide/example/", 
            "text": "Application Design\n\n\nWhat follows is a guide to \nhow\n we build \nhttp4k\n applications test first to provide excellent test coverage driven by decoupled tests. \n\n\nFor this example, we will use an example of a Maths app with the following requirements:\n\n\n\n\nThe app must add 2 numbers together via an HTTP call\n\n\nThe app must multiply 2 numbers together via an HTTP call\n\n\nAnswers generated by the service will be logged (via HTTP POST) to another server - the Recorder.\n\n\n\n\nApps can generally be split into 3 tiers:\n\n\n\n\nEndpoint: \nHttpHandlers\n are constructed individually, by providing a builder function which takes the business-level dependencies. \n\n\nApplication: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier.\n\n\nServer: Builder function which takes the configuration for environmental concerns such as ports and downstream urls.", 
            "title": "Introduction"
        }, 
        {
            "location": "/guide/example/#application-design", 
            "text": "What follows is a guide to  how  we build  http4k  applications test first to provide excellent test coverage driven by decoupled tests.   For this example, we will use an example of a Maths app with the following requirements:   The app must add 2 numbers together via an HTTP call  The app must multiply 2 numbers together via an HTTP call  Answers generated by the service will be logged (via HTTP POST) to another server - the Recorder.   Apps can generally be split into 3 tiers:   Endpoint:  HttpHandlers  are constructed individually, by providing a builder function which takes the business-level dependencies.   Application: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier.  Server: Builder function which takes the configuration for environmental concerns such as ports and downstream urls.", 
            "title": "Application Design"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/", 
            "text": "Until we have an application that can be deployed, we cannot create any business value. The Walking Skeleton\nmodel dictates that putting the most trivial endpoint into a production environment will prove our deployment\npipeline is sound, and helps to set the direction for the testing strategy that we will use going forward.\n\n\nWe start with in ICT (In-Container-Test), which have the job of testing server-level concerns such as monitoring,\ndocumentation, and checking in a high-level way that the business endpoints are wired correctly.\n\n\nRequirements:\n\n\n\n\nThe service can be pinged over HTTP to prove that is still alive.\n\n\n\n\nTests:\n\n\n\n\nProduction:", 
            "title": "1. Building a walking skeleton"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#requirements", 
            "text": "The service can be pinged over HTTP to prove that is still alive.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/", 
            "text": "Starting with another EndToEnd test, we can then drill-down into the functional behaviour of the system by introducing\nOCT (Out of Container) tests and converting the e2e test to just test endpoint wiring (so far). The common assertions have\nalso been converted to reusable extension methods on Response.\n\n\nRequirements:\n\n\n\n\nImplement an \"add\" service, which will sum a number of integer values.\n\n\n\n\nTests:\n\n\n\n\nProduction:", 
            "title": "2. Adding an endpoint"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#requirements", 
            "text": "Implement an \"add\" service, which will sum a number of integer values.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/", 
            "text": "Requirements:\n\n\n\n\nImplement a \"multiply\" service, which will find the product of a number of integer values.\n\n\n\n\nTests:\n\n\n\n\nProduction:", 
            "title": "3. Adding another endpoint"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#requirements", 
            "text": "Implement a \"multiply\" service, which will find the product of a number of integer values.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/", 
            "text": "At this point, the separation of the layers starts to become clear:\n- The server layer is responsible for taking external configuration and instantiating the app layer.\n- The application layer API is only in terms of HTTP transports - it constructs business level abstractions\nwhich are passed down into to the individual endpoints\n\n\nThe process here is to create fake versions of the dependency which can be tested against through the business interface.\nThis requires another style of testing, CDCs (Consumer Driven Contracts), to be created. These contract tests ensure that our\ninteractions with the external service are valid.\n\n\nRequirements:\n\n\n\n\nResults from calculations should be POSTed via HTTP to another \"answer recording\" service.\n\n\n\n\nImplementation Notes:\n\n\nThe following process is followed to us to the final state, whilst always allowing us to keep the build green:\n\n\n\n\nDetermine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer}\n\n\nCreate RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder\n\n\nCreate FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement\n\n\nInclude the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything)\n\n\nPass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler\n\n\nFactor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done\n\n\nIntroduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment\n\n\nAlter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp\n\n\nIn MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record()\n\n\n\n\nTests:\n\n\n\n\nProduction:", 
            "title": "4. An external dependency"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#requirements", 
            "text": "Results from calculations should be POSTed via HTTP to another \"answer recording\" service.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#implementation-notes", 
            "text": "The following process is followed to us to the final state, whilst always allowing us to keep the build green:   Determine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer}  Create RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder  Create FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement  Include the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything)  Pass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler  Factor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done  Introduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment  Alter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp  In MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record()", 
            "title": "Implementation Notes:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/api/", 
            "text": "", 
            "title": "API docs"
        }, 
        {
            "location": "/cookbook/server_as_a_function/", 
            "text": "This example is the simplest possible \"server\" implementation. Note that we are not spinning up a server-backend here - but the entire application(!) is testable but firing HTTP requests at it as if it were. \n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n\n\n\n\n\nCode", 
            "title": "Server as a function"
        }, 
        {
            "location": "/cookbook/server_as_a_function/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/server_as_a_function/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/client_as_a_function/", 
            "text": "This example demonstrates using http4k as a client, to consume HTTP services. A client is just another HttpHandler.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n\n\n\n\n\nCode", 
            "title": "Client as a function"
        }, 
        {
            "location": "/cookbook/client_as_a_function/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/client_as_a_function/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/container_integration/", 
            "text": "This example shows how to both how to serve an application HttpHandler using an embedded an HTTP server and to query it using an HTTP client. All server-backend implementations are launched in an identical manner (in 1LOC) using implementations of the \nServerConfig\n interface - and a base implementation of this interface is provided for each server backend.\n\n\nAlternatively, any http4k application can be mounted into any Servlet container using the \nasServlet()\n extension method. This is the mechanism used in the Jetty implementation.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-client-apache\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-server-jetty\n, version: \n3.29.0\n\n\n\n\n\n\nCode", 
            "title": "Container integration"
        }, 
        {
            "location": "/cookbook/container_integration/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-client-apache , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-server-jetty , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/container_integration/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/simple_routing/", 
            "text": "This example shows how to use the simple routing functionality to bind several routes\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n\n\n\n\n\nCode", 
            "title": "Simple routing"
        }, 
        {
            "location": "/cookbook/simple_routing/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/simple_routing/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/nestable_routes/", 
            "text": "This is a fairly comprehensive example of the core-routing logic available:\n\n\n\n\nIndividual HTTP endpoints are represented as \nHttpHandlers\n.\n\n\nBinding an \nHttpHandler\n to a path and HTTP verb yields a \nRoute\n.\n\n\nRoutes\n can be combined together into a \nRoutingHttpHandler\n, which is both an \nHttpHandler\n and a\nRouter\n.\n\n\nA \nRouter\n is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next \nRouter\n in the list.\n\n\nRouters can be combined together to form another \nHttpHandler\n\n\nUsage of supplied core library \nFilters\n\n\nServing of static content using a \nClasspath\n resource loader\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n\n\n\n\n\nCode", 
            "title": "Nestable routes"
        }, 
        {
            "location": "/cookbook/nestable_routes/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/nestable_routes/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/using_json/", 
            "text": "Example of how to use the JSON library API wrappers, in this case the module used is Jackson. \nhttp4k\n provides an identical interface for all JSON implementations.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-format-jackson\n, version: \n3.29.0\n\n\n\n\n\n\nCode", 
            "title": "JSON messaging"
        }, 
        {
            "location": "/cookbook/using_json/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-format-jackson , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/using_json/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/using_templates/", 
            "text": "Example showing how to use the Templating modules - in this case Handlebars, both by standard response manipulation and via a typesafe view lens.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-template-handlebars\n, version: \n3.29.0\n\n\n\n\n\n\nCode", 
            "title": "Templating engines"
        }, 
        {
            "location": "/cookbook/using_templates/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-template-handlebars , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/using_templates/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/request_context/", 
            "text": "A \nRequestContext\n makes it possible to attach objects to a request whilst it is being passed down through the layers of an application.\n\n\nThe basic concept is that there is a global shared object which holds a bag of state (indexed by Request). This state can be modified in Filters and then \nthat state accessed inside other Filters or the terminating HttpHandler. There are 2 available choices for manipulating this data:\n\n\n\n\nUsing simple Strings to represent the keys.\n\n\nUsing \nRequestContextKey\ns and the Lens mechanism from the \nhttp4k-core\n module.\n\n\n\n\nWhilst the first method looks technically simpler, the use of simple Strings does not provide the type-safety of the second, which uses unique shared Key objects to guarantee non-clashing of keys and type-safety of the state.\nRegardless of which of the above mechanisms are used, an instance of the \nServerFilters.InitialiseRequestContext\n Filter must wrap the HttpHandler(s) to activate\nthe shared bag of state for each request, and to remove the state after the request is complete.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n\n\n\n\n\nString-based keys \n\n\n\n\nLens-based keys", 
            "title": "Typesafe RequestContexts"
        }, 
        {
            "location": "/cookbook/request_context/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/request_context/#string-based-keys", 
            "text": "", 
            "title": "String-based keys "
        }, 
        {
            "location": "/cookbook/request_context/#lens-based-keys", 
            "text": "", 
            "title": "Lens-based keys "
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/", 
            "text": "Example showing how to create and apply lenses to requests and responses to both extract and inject typesafe values out of and into HTTP messages. Note that since the \nhttp4k\n \nRequest/Response\n objects are immutable, all injection occurs via copy.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n\n\n\n\n\nStandard (exception based) approach \n\n\nErrors in extracting Lenses are propagated as exceptions which are caught and handled by the \nCatchLensFailure\n Filter.\n\n\n\n\n\nUsing custom \"Result\" ADTs\n\n\nAn alternative approach to using Exceptions to automatically produce \nBadRequests\n is to use an Either-type structure, and this would be easy to implement - but the lack of an in-built Result/Either type in the standard Kotlin library means that we \ndon't have a single representation to use without shackling ourselves to another Either-containing library such as Funktionale or Result4k.\n\n\nAdditionally, the lack of Higher Kinded Types in Kotlin means that we are unable to provide a generic method for converting standard lenses. However, it is easy to implement an extension method to use in specific use cases.\n\n\nBelow is an example which uses a custom Result ADT - this will work for all extraction Lenses that you define:\n\n\nCode", 
            "title": "Typesafe HTTP requests with lenses"
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/#standard-exception-based-approach", 
            "text": "Errors in extracting Lenses are propagated as exceptions which are caught and handled by the  CatchLensFailure  Filter.", 
            "title": "Standard (exception based) approach "
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/#using-custom-result-adts", 
            "text": "An alternative approach to using Exceptions to automatically produce  BadRequests  is to use an Either-type structure, and this would be easy to implement - but the lack of an in-built Result/Either type in the standard Kotlin library means that we \ndon't have a single representation to use without shackling ourselves to another Either-containing library such as Funktionale or Result4k.  Additionally, the lack of Higher Kinded Types in Kotlin means that we are unable to provide a generic method for converting standard lenses. However, it is easy to implement an extension method to use in specific use cases.  Below is an example which uses a custom Result ADT - this will work for all extraction Lenses that you define:", 
            "title": "Using custom \"Result\" ADTs"
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/html_forms/", 
            "text": "HTML form support is provided on 2 levels:\n\n\n\n\nThrough the use of \nform()\n extension methods on \nRequest\n to get/set String values.\n\n\nUsing the Lens system, which adds the facility to define form fields in a typesafe way, and to validate form contents (in either a strict (400) or \"feedback\" mode).\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n\n\n\n\n\nStandard (non-typesafe) API \n\n\n\n\nLens (typesafe, validating) API", 
            "title": "HTML forms"
        }, 
        {
            "location": "/cookbook/html_forms/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/html_forms/#standard-non-typesafe-api", 
            "text": "", 
            "title": "Standard (non-typesafe) API "
        }, 
        {
            "location": "/cookbook/html_forms/#lens-typesafe-validating-api", 
            "text": "", 
            "title": "Lens (typesafe, validating) API "
        }, 
        {
            "location": "/cookbook/multipart_forms/", 
            "text": "Multipart form support is provided on 2 levels:\n\n\n\n\nThrough the creation of a \nMultipartFormBody\n which can be set on a \nRequest\n.\n\n\nUsing the Lens system, which adds the facility to define form fields in a typesafe way, and to validate form contents (in either a strict (400) or \"feedback\" mode).\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-multipart\n, version: \n3.29.0\n\n\n\n\n\n\nStandard (non-typesafe) API \n\n\n\n\nLens (typesafe, validating) API - reads ALL contents onto disk/memory \n\n\n\n\nStreaming - iterate over Multiparts \n\n\n\n\nProcessing Files with a Filter and convert to standard form", 
            "title": "Multipart forms"
        }, 
        {
            "location": "/cookbook/multipart_forms/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-multipart , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/multipart_forms/#standard-non-typesafe-api", 
            "text": "", 
            "title": "Standard (non-typesafe) API "
        }, 
        {
            "location": "/cookbook/multipart_forms/#lens-typesafe-validating-api-reads-all-contents-onto-diskmemory", 
            "text": "", 
            "title": "Lens (typesafe, validating) API - reads ALL contents onto disk/memory "
        }, 
        {
            "location": "/cookbook/multipart_forms/#streaming-iterate-over-multiparts", 
            "text": "", 
            "title": "Streaming - iterate over Multiparts "
        }, 
        {
            "location": "/cookbook/multipart_forms/#processing-files-with-a-filter-and-convert-to-standard-form", 
            "text": "", 
            "title": "Processing Files with a Filter and convert to standard form "
        }, 
        {
            "location": "/cookbook/generating_data_classes/", 
            "text": "On the web...\n\n\nThis \nHeroku\n app demonstrates how to use JSON and XML automarshalling to communicate using typesafe Body lenses.\n\n\nOr manually using a filter...\n\n\nThis example show the usage of the \nGenerateDataClasses\n to generate Kotlin data class code for JSON messages from a remote endpoint. When used in conjunction with the \"auto body-marshalling\" functionality available with JSON libraries such as Jackson and GSON, this provides a super-fast way to integrate with upstream remote APIs in a typesafe way.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-format-gson\n, version: \n3.29.0\n\n\n\n\n\n\nCode", 
            "title": "Generating data classes for messages"
        }, 
        {
            "location": "/cookbook/generating_data_classes/#on-the-web", 
            "text": "This  Heroku  app demonstrates how to use JSON and XML automarshalling to communicate using typesafe Body lenses.", 
            "title": "On the web..."
        }, 
        {
            "location": "/cookbook/generating_data_classes/#or-manually-using-a-filter", 
            "text": "This example show the usage of the  GenerateDataClasses  to generate Kotlin data class code for JSON messages from a remote endpoint. When used in conjunction with the \"auto body-marshalling\" functionality available with JSON libraries such as Jackson and GSON, this provides a super-fast way to integrate with upstream remote APIs in a typesafe way.", 
            "title": "Or manually using a filter..."
        }, 
        {
            "location": "/cookbook/generating_data_classes/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-format-gson , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/generating_data_classes/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/websockets/", 
            "text": "Gradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-server-jetty\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-client-websocket\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-format-jackson\n, version: \n3.29.0\n\n\n\n\n\n\nhttp4k\n provides Websocket support using a simple, consistent, typesafe, and testable API on supported server backends (see above). Websocket communication consists of 3 main concepts:\n\n\n\n\nWsHandler\n - represented as a typealias: \nWsHandler =  (Request) -\n WsConsumer?\n. This is responsible for matching an HTTP request to a websocket.\n\n\nWsConsumer\n - represented as a typealias: \nWsConsumer = (WebSocket) -\n Unit\n. This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket.\n\n\nWsMessage\n - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the \nhttp4k\n HTTP message model, WsMessages are immutable data classes.\n\n\n\n\nMixing HTTP and Websocket services \n\n\nBoth Websockets and Http handlers in \nhttp4k\n are routed using a similar path-based API. We combine them into a single \nPolyHandler\n which can handle both \nhttp://\n and \nws://\n, and then convert to a Server as usual:\n\n\n\nAutomarshalling Websockets messages \n\n\nUsing the standard Lens API, we can auto-convert Websocket messages on and off the wire. This example uses the Jackson for the marshalling:\n\n\n\nTesting Websockets \n\n\nhttp4k\n provides Websockets that are both typesafe (via the Lens API), and testable. Both \nWsHandlers\n and \nPolyHandlers\n are convertible to a \nWsClient\n which provides a synchronous API for testing reactions to Websocket events in an offline environment.\n\n\nIn the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. \nhttp4k\n provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic:", 
            "title": "Websockets"
        }, 
        {
            "location": "/cookbook/websockets/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-server-jetty , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-client-websocket , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-format-jackson , version:  3.29.0   http4k  provides Websocket support using a simple, consistent, typesafe, and testable API on supported server backends (see above). Websocket communication consists of 3 main concepts:   WsHandler  - represented as a typealias:  WsHandler =  (Request) -  WsConsumer? . This is responsible for matching an HTTP request to a websocket.  WsConsumer  - represented as a typealias:  WsConsumer = (WebSocket) -  Unit . This function is called on connection of a websocket and allow the API user to react to events coming from the connected websocket.  WsMessage  - a message which is sent or received on a websocket. This message can take advantage of the typesafety accorded to other entities in http4k by using the Lens API. Just like the  http4k  HTTP message model, WsMessages are immutable data classes.", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/websockets/#mixing-http-and-websocket-services", 
            "text": "Both Websockets and Http handlers in  http4k  are routed using a similar path-based API. We combine them into a single  PolyHandler  which can handle both  http://  and  ws:// , and then convert to a Server as usual:", 
            "title": "Mixing HTTP and Websocket services "
        }, 
        {
            "location": "/cookbook/websockets/#automarshalling-websockets-messages", 
            "text": "Using the standard Lens API, we can auto-convert Websocket messages on and off the wire. This example uses the Jackson for the marshalling:", 
            "title": "Automarshalling Websockets messages "
        }, 
        {
            "location": "/cookbook/websockets/#testing-websockets", 
            "text": "http4k  provides Websockets that are both typesafe (via the Lens API), and testable. Both  WsHandlers  and  PolyHandlers  are convertible to a  WsClient  which provides a synchronous API for testing reactions to Websocket events in an offline environment.  In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server.  http4k  provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic:", 
            "title": "Testing Websockets "
        }, 
        {
            "location": "/cookbook/typesafe_http_contracts/", 
            "text": "This contract example shows:\n\n\n\n\n2 endpoints with typesafe contracts (marshalling of path parameters and bodies)\n\n\nCustom filters (reporting latency)\n\n\nAPI key security via a typesafe Query parameter (this can be a header or a body parameter as well)\n\n\nOpenApi/Swagger API documentation - Run this example and point a browser \nhere\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-contract\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-format-argo\n, version: \n3.29.0\n\n\n\n\n\n\nNote: although we use Argo here as our JSON API, you could also switch in any of the \nhttp4k-format-xxx\n JSON modules. \n\n\nCode", 
            "title": "Typesafe HTTP contracts"
        }, 
        {
            "location": "/cookbook/typesafe_http_contracts/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-contract , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-format-argo , version:  3.29.0   Note: although we use Argo here as our JSON API, you could also switch in any of the  http4k-format-xxx  JSON modules.", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/typesafe_http_contracts/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/custom_oauth/", 
            "text": "It is very easy to configure http4k to integrate with any OAuth2 provider who supports the Authorisation Code Grant.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-security-oauth\n, version: \n3.29.0\n\n\n\n\n\n\nFor this example, simply reconfigure the \nOAuthProvider\n instance with the correct details, and provide custom logic for persisting and retrieving the CSRF and AccessToken.\n\n\nCode", 
            "title": "Custom OAuth configuration"
        }, 
        {
            "location": "/cookbook/custom_oauth/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-security-oauth , version:  3.29.0   For this example, simply reconfigure the  OAuthProvider  instance with the correct details, and provide custom logic for persisting and retrieving the CSRF and AccessToken.", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/custom_oauth/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/monitoring/", 
            "text": "Measuring performance of application estate is crucial in today's microservice world - it is crucial that dev-ops enabled teams can monitor, react and scale dynamically to changes in the runtime environment. However, because of the plethora of monitoring tools on the market, and because \nhttp4k\n is a toolkit and not a complete \"batteries included\" framework, it provides a number of integration points to enable monitoring systems to be plugged in as required. Additionally, it is envisaged that users will probably want to provide their own implementations of the \nhttp4k\n \nServerConfig\n classes (\nJetty\n, \nUndertow\n etc..) so that tweaking and tuning to their exact requirements is accessible, instead of \nhttp4k\n attempting to provide some generic configuration API to achieve it.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n    compile group: \norg.http4k\n, name: \nhttp4k-metrics-micrometer\n, version: \n3.29.0\n\n\n\n\n\n\nMetrics (Micrometer) \n\n\nhttp4k\n provides module support for monitoring application endpoints using the \nmicrometer\n metrics abstraction library, which currently enables support for libraries such as Graphite, StatsD, Prometheus and Netflix Atlas. This also provides drop-in classes to record stats such as JVM performance, GC and thread usage.\n\n\n\n\n\nMetrics (other APIs) \n\n\nAlternatively, it's very easy to use a standard \nFilter\n to report on stats:\n\n\n\n\n\nLogging \n\n\nThis is trivial to achieve by using a Filter:\n\n\n\n\n\nDistributed tracing \n\n\nThis allows a chain of application calls to be tied together and is generally done through the setting of HTTP headers on each call. \nhttp4k\n supports the \nOpenZipkin\n standard for achieving this and provides both Server-side and Client-side \nFilters\n for this purpose. This example shows a chain of two proxies and an endpoint - run it to observe the changes to the tracing headers as the request flows through the system:\n\n\n\n\n\nDebugging \n\n\nEasily wrap an \nHttpHandler\n in a debugging filter to check out what is going on under the covers:", 
            "title": "Monitoring http4k"
        }, 
        {
            "location": "/cookbook/monitoring/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0 \n    compile group:  org.http4k , name:  http4k-metrics-micrometer , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/monitoring/#metrics-micrometer", 
            "text": "http4k  provides module support for monitoring application endpoints using the  micrometer  metrics abstraction library, which currently enables support for libraries such as Graphite, StatsD, Prometheus and Netflix Atlas. This also provides drop-in classes to record stats such as JVM performance, GC and thread usage.", 
            "title": "Metrics (Micrometer) "
        }, 
        {
            "location": "/cookbook/monitoring/#metrics-other-apis", 
            "text": "Alternatively, it's very easy to use a standard  Filter  to report on stats:", 
            "title": "Metrics (other APIs) "
        }, 
        {
            "location": "/cookbook/monitoring/#logging", 
            "text": "This is trivial to achieve by using a Filter:", 
            "title": "Logging "
        }, 
        {
            "location": "/cookbook/monitoring/#distributed-tracing", 
            "text": "This allows a chain of application calls to be tied together and is generally done through the setting of HTTP headers on each call.  http4k  supports the  OpenZipkin  standard for achieving this and provides both Server-side and Client-side  Filters  for this purpose. This example shows a chain of two proxies and an endpoint - run it to observe the changes to the tracing headers as the request flows through the system:", 
            "title": "Distributed tracing "
        }, 
        {
            "location": "/cookbook/monitoring/#debugging", 
            "text": "Easily wrap an  HttpHandler  in a debugging filter to check out what is going on under the covers:", 
            "title": "Debugging "
        }, 
        {
            "location": "/cookbook/record_and_replay/", 
            "text": "A set of classes to provide simple recording/replaying of HTTP traffic. This is perfect for testing purposes, or in short lived, low traffic environments where no proper caches are available.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n3.29.0\n\n\n\n\n\n\nCaching HTTP Traffic\n\n\nUsing \nFilters\n it's possible to record traffic and then return recorded content instead of making repeated calls. Note that the provided storage \nimplementations DO NOT have any facility for Cache Control or eviction, or respect any response headers around caching. Requests are indexed in a way optimised for retrieval.\n\n\nCode \n\n\n\n\n\nRecording Streams of HTTP Traffic\n\n\nUsing \nFilters\n it's possible to record a stream traffic and then replay recorded content instead. Requests are indexed in a way optimised for iteration.\n\n\nCode \n\n\n\n\n\nConcepts\n\n\nThe \norg.http4k.traffic\n package contains the interfaces which make up the core concepts for traffic capture and replay. These interfaces are:\n\n\n\n\nA \nSink\n consumes request/response pairs for storage. \n\n\nA \nSource\n provides lookup of pre-stored Response based on an HTTP Request.\n\n\nReplay\n instances provide streams of HTTP messages as they were received.\n\n\nA \nReadWriteCache\n combines \nSink\n and \nSource\n to provide cache-like storage.\n\n\nA \nReadWriteStream\n combines \nSink\n and \nReplay\n to provide a stream of traffic which can be replayed.\n\n\n\n\nThe API has been designed to be modular so API users can provide their own implementations (store in S3 etc..).", 
            "title": "Recording/replaying HTTP traffic"
        }, 
        {
            "location": "/cookbook/record_and_replay/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  3.29.0", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/record_and_replay/#caching-http-traffic", 
            "text": "Using  Filters  it's possible to record traffic and then return recorded content instead of making repeated calls. Note that the provided storage \nimplementations DO NOT have any facility for Cache Control or eviction, or respect any response headers around caching. Requests are indexed in a way optimised for retrieval.", 
            "title": "Caching HTTP Traffic"
        }, 
        {
            "location": "/cookbook/record_and_replay/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/record_and_replay/#recording-streams-of-http-traffic", 
            "text": "Using  Filters  it's possible to record a stream traffic and then replay recorded content instead. Requests are indexed in a way optimised for iteration.", 
            "title": "Recording Streams of HTTP Traffic"
        }, 
        {
            "location": "/cookbook/record_and_replay/#code_1", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/cookbook/record_and_replay/#concepts", 
            "text": "The  org.http4k.traffic  package contains the interfaces which make up the core concepts for traffic capture and replay. These interfaces are:   A  Sink  consumes request/response pairs for storage.   A  Source  provides lookup of pre-stored Response based on an HTTP Request.  Replay  instances provide streams of HTTP messages as they were received.  A  ReadWriteCache  combines  Sink  and  Source  to provide cache-like storage.  A  ReadWriteStream  combines  Sink  and  Replay  to provide a stream of traffic which can be replayed.   The API has been designed to be modular so API users can provide their own implementations (store in S3 etc..).", 
            "title": "Concepts"
        }, 
        {
            "location": "/cookbook/test_driven_apps/", 
            "text": "This example shows the various styles of testing endpoints, and requires both the \nhttp4k-core\n and \nhttp4k-testing-hamkrest\n modules:\n\n\nCode", 
            "title": "Test driven apps"
        }, 
        {
            "location": "/cookbook/test_driven_apps/#code", 
            "text": "", 
            "title": "Code "
        }, 
        {
            "location": "/performance/", 
            "text": "The \nhttp4k\n server-backend modules provide a very thin adapter layer over the raw APIs of the underlying servers, so \ngenerally performs at a very low overhead compared to the raw server.\n\n\nTech Empower Benchmarks\n\n\nWe have entered \nhttp4k\n into the prominent \nTech Empower Framework Benchmarks\n \nproject, which assesses frameworks over a series of realistic tests. \n\n\nFor this benchmark, no customisation or performance tuning of the underlying servers was done - the default application \nHttpHandler was used which is then plugged into each custom backend, as below:\n\n\nfun\n \nmain\n(\nargs\n:\n \nArray\nString\n)\n \n{\n\n    \nHttp4kBenchmarkServer\n.\nstart\n(\nUndertow\n(\n9000\n))\n\n\n}\n\n\n\n\n\n\nCommand-line JVM options, however, were tuned for the test to take advantage of various JVM features.\n\n\nThe full implementation of the benchmark can be found \nhere\n.\n\n\nResults - Round 16\n\n\nOverall, http4k did very well in this round of benchmarking, especially considering that the ethos of the library is one of excellent Developer experience over and above high-end performance (which tends to result in less friendly APIs).\n\n\nThe big surprise was the high performance of the Apache server backend, which consistently outranked Undertow (which is the the most fully featured of all the supported backends and our default option). The SunHttp backend, which we entered for a baseline comparison, unfortunately didn't produce any results in this round.\n\n\nFor each of the sections below, the rankings are based only on JVM-based entries.\n\n\nDB query + HTML rendering: \nresults\n:\n\n\nTop rank: 11/82 - Apache backend\n\n\nDatabase driver used is PostgreSql backed by a Hikari pool.\nHandlebars templating engine is used for rendering.\n\n\nMultiple DB queries: \nresults\n:\n\n\nTop rank: 3/76 - Jetty backend\n\n\nDatabase driver used is PostgreSql backed by a Hikari pool.\n\n\nSingle DB query: \nresults\n:\n\n\nTop rank: 7/78 - Apache backend\n\n\nDatabase driver used is PostgreSql backed by a Hikari pool.\n\n\nRandom DB updates: \nresults\n:\n\n\nTop rank: 11/69 - Jetty backend\n\n\nDatabase driver used is PostgreSql backed by a Hikari pool.\n\n\nJSON Serialization: \nresults\n:\n\n\nTop rank: 23/77 - Apache backend\n\n\nThe standard Jackson module is used for JSON creation and marshalling.\n\n\nPlaintext pipelining: \nresults\n:\n\n\nTop rank: 23/73 - Apache backend", 
            "title": "Performance"
        }, 
        {
            "location": "/performance/#tech-empower-benchmarks", 
            "text": "We have entered  http4k  into the prominent  Tech Empower Framework Benchmarks  \nproject, which assesses frameworks over a series of realistic tests.   For this benchmark, no customisation or performance tuning of the underlying servers was done - the default application \nHttpHandler was used which is then plugged into each custom backend, as below:  fun   main ( args :   Array String )   { \n     Http4kBenchmarkServer . start ( Undertow ( 9000 ))  }   Command-line JVM options, however, were tuned for the test to take advantage of various JVM features.  The full implementation of the benchmark can be found  here .", 
            "title": "Tech Empower Benchmarks"
        }, 
        {
            "location": "/performance/#results-round-16", 
            "text": "Overall, http4k did very well in this round of benchmarking, especially considering that the ethos of the library is one of excellent Developer experience over and above high-end performance (which tends to result in less friendly APIs).  The big surprise was the high performance of the Apache server backend, which consistently outranked Undertow (which is the the most fully featured of all the supported backends and our default option). The SunHttp backend, which we entered for a baseline comparison, unfortunately didn't produce any results in this round.  For each of the sections below, the rankings are based only on JVM-based entries.", 
            "title": "Results - Round 16"
        }, 
        {
            "location": "/performance/#db-query-html-rendering-results", 
            "text": "Top rank: 11/82 - Apache backend  Database driver used is PostgreSql backed by a Hikari pool.\nHandlebars templating engine is used for rendering.", 
            "title": "DB query + HTML rendering: results:"
        }, 
        {
            "location": "/performance/#multiple-db-queries-results", 
            "text": "Top rank: 3/76 - Jetty backend  Database driver used is PostgreSql backed by a Hikari pool.", 
            "title": "Multiple DB queries: results:"
        }, 
        {
            "location": "/performance/#single-db-query-results", 
            "text": "Top rank: 7/78 - Apache backend  Database driver used is PostgreSql backed by a Hikari pool.", 
            "title": "Single DB query: results:"
        }, 
        {
            "location": "/performance/#random-db-updates-results", 
            "text": "Top rank: 11/69 - Jetty backend  Database driver used is PostgreSql backed by a Hikari pool.", 
            "title": "Random DB updates: results:"
        }, 
        {
            "location": "/performance/#json-serialization-results", 
            "text": "Top rank: 23/77 - Apache backend  The standard Jackson module is used for JSON creation and marshalling.", 
            "title": "JSON Serialization: results:"
        }, 
        {
            "location": "/performance/#plaintext-pipelining-results", 
            "text": "Top rank: 23/73 - Apache backend", 
            "title": "Plaintext pipelining: results:"
        }, 
        {
            "location": "/in_action/", 
            "text": "Rationale \n design\n\n\nPresentation about the development of http4k given at the Kotlin London meetup\n\n\nSee http4k in action in these example projects:\n\n\n\n\nSuper quick start \"Hello World\" Github/Travis/Heroku CD pipeline)\n\n\nTodo backend (standard routing version)\n\n\nTodo backend (contract routing version)\n\n\nS3-backed Dropbox clone in \n100 lines of code\n\n\nSimple websocket driven chat-server in 30 lines of code\n\n\nTDD'd example application\n\n\nStage-by-stage example of development process (London TDD style)", 
            "title": "In action"
        }, 
        {
            "location": "/in_action/#rationale-design", 
            "text": "Presentation about the development of http4k given at the Kotlin London meetup", 
            "title": "Rationale &amp; design"
        }, 
        {
            "location": "/in_action/#see-http4k-in-action-in-these-example-projects", 
            "text": "Super quick start \"Hello World\" Github/Travis/Heroku CD pipeline)  Todo backend (standard routing version)  Todo backend (contract routing version)  S3-backed Dropbox clone in  100 lines of code  Simple websocket driven chat-server in 30 lines of code  TDD'd example application  Stage-by-stage example of development process (London TDD style)", 
            "title": "See http4k in action in these example projects:"
        }, 
        {
            "location": "/blog/meet_http4k/", 
            "text": "Server as a Function. In Kotlin. Typesafe. Without the Server.\n\n\n@daviddenton\n / november 2017\n\n\nMeet \nhttp4k\n\n\nhttp4k\n is an HTTP toolkit written in Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way.\n\n\nWhenever (yet another) new JVM HTTP framework is released, the inevitable question that rightly get asked is \n\"How it this different to X?\"\n. In this post, I'm going to briefly cover what \nhttp4k\n is, how we think it's different, and address some of those \nbold claims\n from the title of this post.\n\n\nHere's a quick rundown of what we think those differences are:\n\n\n\n\nhttp4k\n is small. Written in pure, functional Kotlin, with zero dependencies.\n\n\nhttp4k\n is simple. Like, really simple. No static API magic, no annotations, no reflection.\n\n\nhttp4k\n is immutable. It relies on an immutable HTTP model, which makes it a snap to test and debug.\n\n\nhttp4k\n is symmetric. It supports remote calls as a first-class concern, and the remote HTTP model is identical to the incoming HTTP model.\n\n\nhttp4k\n is typesafe. Say goodbye to all your validation and marshalling boilerplate and hello to automatic request validation and data class-based contracts for HTTP bodies using the Lens API.\n\n\nhttp4k\n is serverless. Or rather - server independent. Test an app out of container and then deploy it into any supported local container with 1 LOC - or as a function into AWS Lambda.\n\n\n\n\nOh god, not another framework! Why does this even exist?!?\n\n\nFirstly - we don't consider \nhttp4k\n to be a framework - it's a set of libraries providing a functional toolkit to serve and consume HTTP services, focusing on simple, consistent, and testable APIs. Hence, whilst it does provide support for various APIs \nrelevant to serving and consuming HTTP\n, it does not provide every integration under the sun - merely simple points to allow those integrations to be hooked in.\n\n\nAnother thing to say is that (not very much) of \nhttp4k\n is new - it's rather the distillation of 15 years worth of experience of using various server-side libraries and hence most of the good ideas are stolen. For instance - the routing module is inspired by \nUtterlyIdle\n, the basic \"Server as a function\" model is stolen from \nFinagle\n, and the contract module OpenApi/Swagger generator is ported from \nFintrospect\n. \n\n\nWith the growing adoption of Kotlin, we wanted something that would fully leverage the functional features of the language and it felt like a good time to start something from scratch, whilst avoiding the \nmagic\n that plagues other frameworks. Hence, \nhttp4k\n is primarily designed to be a Kotlin-first library.\n\n\nClaim A: Small, simple, immutable.\n\n\nBased on the awesome \n\"Your Server as a Function\"\n paper from Twitter, \nhttp4k\n apps are modelled by composing 2 types of simple, independent function. \n\n\nFunction 1: HttpHandler\n\n\nAn \nHttpHandler\n represents an HTTP endpoint. It's not even an Interface, modelled merely as a \nTypealias\n:\n\n\ntypealias\n \nHttpHandler\n \n=\n \n(\nRequest\n)\n \n-\n \nResponse\n\n\n\n\n\n\nBelow is a entire \nhttp4k\n application that echoes the request body back in the response. It only relies on the \nhttp4k-core\n module, which itself has zero dependencies:\n\n\nval\n \napp\n \n=\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nrequest\n.\nbody\n)\n \n}\n\n\nval\n \nserver\n \n=\n \napp\n.\nasServer\n(\nSunHttp\n(\n8000\n)).\nstart\n()\n\n\n\n\n\n\nThe \nRequest\n and \nResponse\n objects in there are immutable data classes/POKOs, so testing the app requires absolutely no extra infrastructure - just call the function, it's as easy as:\n\n\nclass\n \nAppTest\n \n{\n\n    \n@Test\n\n    \nfun\n \n`\nechoes\n \nrequest\n \nbody\n`\n()\n \n{\n\n        \nassertThat\n(\napp\n(\nRequest\n(\nPOST\n,\n \n/\n).\nbody\n(\nhello\n)),\n \nequalTo\n(\nResponse\n(\nOK\n).\nbody\n(\nhello\n)))\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTo plug it into a different Server-backend, just depend on the relevant module (Jetty, Undertow, Netty, Apache (httpcore), and SunHttp are available) and change the call to \nasServer()\n.\n\n\nFunction 2: Filter\n\n\nFilters\n provides pre and post Request processing and are simply:\n\n\ninterface\n \nFilter\n \n:\n \n(\nHttpHandler\n)\n \n-\n \nHttpHandler\n\n\n\n\n\n\nFor API conciseness and discoverability reasons this is modelled as an Interface and not a \nTypealias\n - it also has a couple of Kotlin \nextension methods\n to allow you to compose \nFilters\n with \nHttpHandlers\n and other \nFilters\n:\n\n\nval\n \nsetContentType\n \n=\n \nFilter\n \n{\n \nnext\n \n-\n\n        \n{\n \nrequest\n \n-\n \nnext\n(\nrequest\n).\nheader\n(\nContent-Type\n,\n \ntext/plain\n)\n \n}\n\n    \n}\n\n\nval\n \nrepeatBody\n \n=\n \nFilter\n \n{\n \nnext\n \n-\n\n        \n{\n \nrequest\n \n-\n \nnext\n(\nrequest\n.\nbody\n(\nrequest\n.\nbodyString\n()\n \n+\n \nrequest\n.\nbodyString\n()\n \n}\n\n    \n}\n\n\nval\n \ncomposedFilter\n:\n \nFilter\n \n=\n \nrepeatBody\n.\nthen\n(\nsetContentType\n)\n\n\nval\n \ndecoratedApp\n:\n \nHttpHandler\n \n=\n \ncomposedFilter\n.\nthen\n(\napp\n)\n\n\n\n\n\n\nFilters are also trivial to test independently, because they are generally just stateless functions.\n\n\nRouting\n\n\nhttp4k\n's nestable routing looks a lot like every other Sinatra-style framework these days, and allows for infinitely nesting \nHttpHandlers\n - this just exposes another \nHttpHandler\n so you can easily extract, test and reuse sets of routes as easily as you could with one:\n\n\nval\n \napp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n    \n/app\n \nbind\n \nGET\n \nto\n \ndecoratedApp\n,\n\n    \n/other\n \nbind\n \nroutes\n(\n\n        \n/delete\n \nbind\n \nDELETE\n \nto\n \n{\n \n_\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n)\n \n},\n\n        \n/post/{name}\n \nbind\n \nPOST\n \nto\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nyou POSTed to ${request.path(\nname\n)}\n)\n \n}\n\n    \n)\n\n\n)\n\n\n\n\n\n\nAnd that it - those functions are everything you need to know to write a simple \nhttp4k\n application. The \nhttp4k-core\n module rocks in at about 700kb, and has zero dependencies (other than the Kotlin language itself). Additionally, everything in the core is \nfunctional and predictable\n - there is no static API magic going on under the covers (making it difficult to have multiple apps in the same JVM), no annotations, no compiler-plugins, and no reflection.\n\n\nClaim B. Symmetric HTTP\n\n\nOut of the multitude of JVM http frameworks out there, not many actually consider how you app talks to other services, yet in this Microservice\u2122 world that's an absolutely massive part of what many apps do!\n\n\nAs per a core principle behind \"Server as a Function\", \nhttp4k\n provides a symmetric API for HTTP clients - ie. it's \nexactly\n the same API as is exposed in \nhttp4k\n server applications - the \nHttpHandler\n. Here's that entire API again, just in case you've forgotten:\n\n\ntypealias\n \nHttpHandler\n \n=\n \n(\nRequest\n)\n \n-\n \nResponse\n\n\n\n\n\n\nWhat does that mean in practice? Well - for one thing, it's less for your brain to learn  because you already know the API:\n\n\nval\n \nclient\n:\n \nHttpHandler\n \n=\n \nApacheClient\n()\n\n\nval\n \nresponse\n:\n \nResponse\n \n=\n \nclient\n(\nRequest\n(\nGET\n,\n \nhttp://server/path\n))\n\n\n\n\n\n\nFor another, it means that since clients are \njust function\ns you can easily stub them for testing, and since applications and clients are interchangeable, they can be plugged together in memory without putting them on the network - which makes testing insanely fast:\n\n\nfun\n \nMyApp1\n():\n \nHttpHandler\n \n=\n \n{\n \nResponse\n(\nOK\n)\n \n}\n\n\nfun\n \nMyApp2\n(\napp1\n:\n \nHttpHandler\n):\n \nHttpHandler\n \n=\n \n{\n \napp1\n(\nit\n)\n \n}\n\n\n\nval\n \napp1\n:\n \nHttpHandler\n \n=\n \nMyApp1\n()\n\n\nval\n \napp2\n:\n \nHttpHandler\n \n=\n \nMyApp2\n(\napp1\n)\n\n\n\n\n\n\nhttp4k\n provides a HTTP client adapters for both \nApache\n and \nOkHttp\n, all with streaming support.\n\n\nClaim C. Typesafe HTTP with Lenses\n\n\nThe immutable \nhttp4k\n model for HTTP objects contains all the usual suspect methods for getting values from the messages. For instance, if we are expecting a search parameter with a query containing a page number:\n\n\nval\n \nrequest\n \n=\n \nRequest\n(\nGET\n,\n \nhttp://server/search?page=123\n)\n\n\nval\n \npage\n:\n \nInt\n \n=\n \nrequest\n.\nquery\n(\npage\n)\n!!\n.\ntoInt\n\n\n\n\n\n\n...but we also want to ensure that the expected values are both present and valid, since the above example will fail if either of those things is not true. For this purpose, we can use a \nLens\n to enforce the expected HTTP contract.\n\n\nThe use of Lenses in \nhttp4k\n applications can remove the need for writing any parsing or validation code for all incoming data (including Forms), as validations are taken care of by the library. \n\n\nLens basics\n\n\nA Lens is a bi-directional entity which can be used to either \nget\n or \nset\n a particular value from/onto an HTTP message. \nhttp4k\n provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional) and the type. For the above example, we could use the \nQuery\n Lens builder and then \ninvoke()\n the Lens on the message to extract the target value:\n\n\nval\n \npageLens\n \n=\n \nQuery\n.\nint\n().\nrequired\n(\npage\n)\n\n\nval\n \npage\n:\n \nInt\n \n=\n \npageLens\n(\nRequest\n(\nGET\n,\n \nhttp://server/search?page=123\n))\n\n\n\n\n\n\nIf the query parameter is missing or not an Int, the lens extraction operation will fail. There are similar Lens builder functions for all parts of the HTTP message (\nHeader\n, \nPath\n, \nBody\n, \nFormField\n etc..), and functions for all common JVM primitive types. They are all completely typesafe - there is no reflection or magic going on - just marshalling of the various entities (in this case String to Int conversion).\n\n\nIn the case of failure, we need to apply a Filter to detect the errors and convert them to a BAD_REQUEST response:\n\n\nval\n \nqueryName\n \n=\n \nQuery\n.\nstring\n().\nrequired\n(\nname\n)\n\n\nval\n \napp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n      \n/post\n \nbind\n \nPOST\n \nto\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nqueryName\n(\nrequest\n))\n \n}\n\n    \n)\n\n\n\nval\n \napp\n \n=\n \nServerFilters\n.\nCatchLensFailure\n.\nthen\n(\nhandler\n)(\nRequest\n(\nGET\n,\n \n/hello/2000-01-01?myCustomType=someValue\n))\n\n\n\n\n\n\nLenses can also be applied with a correctly typed value (via \ninvoke()\n) to set it \nonto\n a target object - and as HTTP messages in \nhttp4k\n are immutable, this results in a copy of the modified message:\n\n\nval\n \npageSizeLens\n \n=\n \nHeader\n.\nint\n().\nrequired\n(\npage\n)\n\n\nval\n \npage\n:\n \nResponse\n \n=\n \npageLens\n(\nResponse\n(\nOK\n),\n \n123\n)\n\n\n// or apply multiple lenses using with()\n\n\nval\n \nupdated\n:\n \nRequest\n \n=\n \nRequest\n(\nGET\n,\n \n/foo\n).\nwith\n(\npageLens\n \nof\n \n123\n,\n \npageSizeLens\n \nof\n \n10\n)\n\n\n\n\n\n\nSecurely extracting JDK primitives from HTTP messages is great, but we really want to avoid primitives entirely and go straight to domain types. During construction of Lens, the builders allow mapping to occur so we can leverage Kotlin data classes. This works for both get and set operations:\n\n\ndata\n \nclass\n \nMyDate\n(\nval\n \nvalue\n:\n \nLocalDate\n)\n\n\nval\n \ndateQuery\n \n=\n \nQuery\n.\nlocalDate\n().\nmap\n(\n::\nMyDate\n,\n \nMyDate\n::\nvalue\n).\nrequired\n(\ndate\n)\n\n\nval\n \nmyDate\n:\n \nMyDate\n \n=\n \ndateQuery\n(\nRequest\n(\nGET\n,\n \nhttp://server/search?date=2000-01-01\n))\n\n\n\n\n\n\nLensing HTTP bodies with Data classes\n\n\nSome of the supported message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection (oops - looks like we broke our reflection promise - but technically we're not doing it ;) !). This behaviour is supported in \nhttp4k\n Lenses through the use of the \nauto()\n method, which will marshall objects to/from HTTP messages:\n\n\ndata\n \nclass\n \nEmail\n(\nval\n \nvalue\n:\n \nString\n)\n\n\ndata\n \nclass\n \nMessage\n(\nval\n \nsubject\n:\n \nString\n,\n \nval\n \nfrom\n:\n \nEmail\n,\n \nval\n \nto\n:\n \nEmail\n)\n\n\n\nval\n \nmessageLens\n \n=\n \nBody\n.\nauto\nMessage\n().\ntoLens\n()\n\n\nval\n \nbody\n \n=\n \n{\nsubject\n:\nhello\n,\nfrom\n:{\nvalue\n:\nbob@git\n.\ncom\n},\nto\n:{\nvalue\n:\nsue@git\n.\ncom\n}}\n\n\nval\n \nmessage\n:\n \nMessage\n \n=\n \nmessageLens\n(\nRequest\n(\nGET\n,\n \n/\n).\nbody\n(\nbody\n))\n\n\n\n\n\n\nThis mechanism works for all incoming and outgoing JSON and XML Requests and Responses. To assist with developing whilst using this type of auto-marshalling, we have created a \ntool\n to automatically generate a set of data classes for a given messages.\n\n\nClaim D. Serverless\n\n\nAh yes - Serverless - the latest in the Cool Kids Club and killer fodder for the resume. Well, since \nhttp4k\n is server independent, it turns out to be fairly trivial to deploy full applications to \nAWS Lambda\n, and then call them by setting up the \nAPI Gateway\n to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library.\n\n\nIn order to achieve this, only a single interface \nAppLoader\n needs to be implemented - this is responsible for creating the \nHttpHandler\n which is adapted to the API of the \nApiGatewayProxyRequest/ApiGatewayProxyResponse\n used by AWS. As this is AWS, there is a fair amount of configuration required to make this possible, but the only \nhttp4k\n specific config is to:\n\n\n\n\nSet the function execution to call \norg.http4k.serverless.lambda.LambdaFunction::handle\n\n\nSet an environment variable for the Lambda \nHTTP4K_BOOTSTRAP_CLASS\n to the class of your \nAppLoader\n class.\n\n\n\n\nHere's a simple example:\n\n\nobject\n \nTweetEcho\n \n:\n \nAppLoader\n \n{\n\n    \noverride\n \nfun\n \ninvoke\n(\nenv\n:\n \nMap\nString\n,\n \nString\n):\n \nHttpHandler\n \n=\n \n{\n\n        \nResponse\n(\nOK\n).\nbody\n(\nit\n.\nbodyString\n().\ntake\n(\n140\n))\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSince \nhttp4k\n is very dependency-light, full binary uploads of these AWS Lambdas tend to be very small - and by utilising \nProguard\n we've seen the size of a Lambda UberJar go as small as 150kb.\n\n\nIntroduced in v3.0.0, this support is available in the \nhttp4k-serverless-lambda\n module.\n\n\nThe final word(s)!\n\n\nAs pointed out above, \nhttp4k-core\n module has zero dependencies. It is also small, even though it also provides:\n\n\n\n\nSupport for static file-serving with HotReload.\n\n\nA bunch of useful Filters for stuff like \nZipkin\n Request Tracing.\n\n\nSupport for Request Contexts.\n\n\nFacilities to record and replay HTTP traffic.\n\n\n\n\nThere are also a bunch of other modules available, all presented with the same concentration on Testability, API simplicity and consistency:\n\n\n\n\nViewModel driven templating engine support (Handlerbars etc) with HotReload.\n\n\nPopular JSON/XML (Gson, Jackson, Moshi, etc) library support for HTTP bodies.\n\n\nTypesafe HTML Form and Multipart Forms processing, with support for Streaming uploads to a storage service. Forms can also be configured to collect errors instead of just rejecting outright.\n\n\nTypesafe contract module, providing live \nOpenApi/Swagger\n documentation.\n\n\nAWS\n request signing.\n\n\nResilience4j\n integration, including Circuit Breakers \n Rate Limiting.\n\n\nTesting support via \nHamkrest\n matchers and an in-memory \nWebDriver\n implementation.\n\n\n\n\nFinally, \nhttp4k\n is \nproven in production\n, it has been adopted in at least 2 global investment banks and is serving the vast majority of traffic for a major publishing website (in the top 1000 sites globally according to \nalexa.com\n - ie. easily serving 10s of million hits per day on a few nodes) since March 2017. \n\n\nYou can see a few example applications \nhere\n, including a bootstrap project for creating a \nGithub -\n Travis -\n Heroku\n CD pipeline\n in a single command.\n\n\nWell, that's it for this whirlwind tour - we hope you found it worth reading this far! We'd love you to try out \nhttp4k\n and feedback why you love/hate/are indifferent to it :) . And if you want to get involved or chat to the authors, we hang out in the friendly #http4k channel @ \nslack.kotlinlang,org\n.\n\n\nFootnotes\n\n\n\n\n\"But... but... but... asynchronous! And Webscale!\"\n, \nI heard them froth\n. Yes, you are correct - \"Server as a Function\" is based on asynchronous functions and \nhttp4k\n exposes a synchronous API. However, our experience suggests that for the vast majority of apps, this actually makes API integration harder unless you've got async all the way down - and that is assuming that async clients are actually available for all your various remote dependencies. We found that this plainly didn't matter for our use-cases so went for \nSimple API\u2122\n instead... it's possible however that Kotlin co-routines will allow us to revisit this decision.\n\n\n(UPDATE) Websockets?\n Yep - simple, testable, and now available in v3.2.1! See the introductory \nblog post\n for details.!", 
            "title": "Meet http4k"
        }, 
        {
            "location": "/blog/meet_http4k/#server-as-a-function-in-kotlin-typesafe-without-the-server", 
            "text": "", 
            "title": "Server as a Function. In Kotlin. Typesafe. Without the Server."
        }, 
        {
            "location": "/blog/meet_http4k/#daviddenton-november-2017", 
            "text": "", 
            "title": "@daviddenton / november 2017"
        }, 
        {
            "location": "/blog/meet_http4k/#meet-http4k", 
            "text": "http4k  is an HTTP toolkit written in Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way.  Whenever (yet another) new JVM HTTP framework is released, the inevitable question that rightly get asked is  \"How it this different to X?\" . In this post, I'm going to briefly cover what  http4k  is, how we think it's different, and address some of those  bold claims  from the title of this post.  Here's a quick rundown of what we think those differences are:   http4k  is small. Written in pure, functional Kotlin, with zero dependencies.  http4k  is simple. Like, really simple. No static API magic, no annotations, no reflection.  http4k  is immutable. It relies on an immutable HTTP model, which makes it a snap to test and debug.  http4k  is symmetric. It supports remote calls as a first-class concern, and the remote HTTP model is identical to the incoming HTTP model.  http4k  is typesafe. Say goodbye to all your validation and marshalling boilerplate and hello to automatic request validation and data class-based contracts for HTTP bodies using the Lens API.  http4k  is serverless. Or rather - server independent. Test an app out of container and then deploy it into any supported local container with 1 LOC - or as a function into AWS Lambda.", 
            "title": "Meet http4k"
        }, 
        {
            "location": "/blog/meet_http4k/#oh-god-not-another-framework-why-does-this-even-exist", 
            "text": "Firstly - we don't consider  http4k  to be a framework - it's a set of libraries providing a functional toolkit to serve and consume HTTP services, focusing on simple, consistent, and testable APIs. Hence, whilst it does provide support for various APIs  relevant to serving and consuming HTTP , it does not provide every integration under the sun - merely simple points to allow those integrations to be hooked in.  Another thing to say is that (not very much) of  http4k  is new - it's rather the distillation of 15 years worth of experience of using various server-side libraries and hence most of the good ideas are stolen. For instance - the routing module is inspired by  UtterlyIdle , the basic \"Server as a function\" model is stolen from  Finagle , and the contract module OpenApi/Swagger generator is ported from  Fintrospect .   With the growing adoption of Kotlin, we wanted something that would fully leverage the functional features of the language and it felt like a good time to start something from scratch, whilst avoiding the  magic  that plagues other frameworks. Hence,  http4k  is primarily designed to be a Kotlin-first library.", 
            "title": "Oh god, not another framework! Why does this even exist?!?"
        }, 
        {
            "location": "/blog/meet_http4k/#claim-a-small-simple-immutable", 
            "text": "Based on the awesome  \"Your Server as a Function\"  paper from Twitter,  http4k  apps are modelled by composing 2 types of simple, independent function.", 
            "title": "Claim A: Small, simple, immutable."
        }, 
        {
            "location": "/blog/meet_http4k/#function-1-httphandler", 
            "text": "An  HttpHandler  represents an HTTP endpoint. It's not even an Interface, modelled merely as a  Typealias :  typealias   HttpHandler   =   ( Request )   -   Response   Below is a entire  http4k  application that echoes the request body back in the response. It only relies on the  http4k-core  module, which itself has zero dependencies:  val   app   =   {   request :   Request   -   Response ( OK ). body ( request . body )   }  val   server   =   app . asServer ( SunHttp ( 8000 )). start ()   The  Request  and  Response  objects in there are immutable data classes/POKOs, so testing the app requires absolutely no extra infrastructure - just call the function, it's as easy as:  class   AppTest   { \n     @Test \n     fun   ` echoes   request   body ` ()   { \n         assertThat ( app ( Request ( POST ,   / ). body ( hello )),   equalTo ( Response ( OK ). body ( hello ))) \n     }  }   To plug it into a different Server-backend, just depend on the relevant module (Jetty, Undertow, Netty, Apache (httpcore), and SunHttp are available) and change the call to  asServer() .", 
            "title": "Function 1: HttpHandler"
        }, 
        {
            "location": "/blog/meet_http4k/#function-2-filter", 
            "text": "Filters  provides pre and post Request processing and are simply:  interface   Filter   :   ( HttpHandler )   -   HttpHandler   For API conciseness and discoverability reasons this is modelled as an Interface and not a  Typealias  - it also has a couple of Kotlin  extension methods  to allow you to compose  Filters  with  HttpHandlers  and other  Filters :  val   setContentType   =   Filter   {   next   - \n         {   request   -   next ( request ). header ( Content-Type ,   text/plain )   } \n     }  val   repeatBody   =   Filter   {   next   - \n         {   request   -   next ( request . body ( request . bodyString ()   +   request . bodyString ()   } \n     }  val   composedFilter :   Filter   =   repeatBody . then ( setContentType )  val   decoratedApp :   HttpHandler   =   composedFilter . then ( app )   Filters are also trivial to test independently, because they are generally just stateless functions.", 
            "title": "Function 2: Filter"
        }, 
        {
            "location": "/blog/meet_http4k/#routing", 
            "text": "http4k 's nestable routing looks a lot like every other Sinatra-style framework these days, and allows for infinitely nesting  HttpHandlers  - this just exposes another  HttpHandler  so you can easily extract, test and reuse sets of routes as easily as you could with one:  val   app :   HttpHandler   =   routes ( \n     /app   bind   GET   to   decoratedApp , \n     /other   bind   routes ( \n         /delete   bind   DELETE   to   {   _ :   Request   -   Response ( OK )   }, \n         /post/{name}   bind   POST   to   {   request :   Request   -   Response ( OK ). body ( you POSTed to ${request.path( name )} )   } \n     )  )   And that it - those functions are everything you need to know to write a simple  http4k  application. The  http4k-core  module rocks in at about 700kb, and has zero dependencies (other than the Kotlin language itself). Additionally, everything in the core is  functional and predictable  - there is no static API magic going on under the covers (making it difficult to have multiple apps in the same JVM), no annotations, no compiler-plugins, and no reflection.", 
            "title": "Routing"
        }, 
        {
            "location": "/blog/meet_http4k/#claim-b-symmetric-http", 
            "text": "Out of the multitude of JVM http frameworks out there, not many actually consider how you app talks to other services, yet in this Microservice\u2122 world that's an absolutely massive part of what many apps do!  As per a core principle behind \"Server as a Function\",  http4k  provides a symmetric API for HTTP clients - ie. it's  exactly  the same API as is exposed in  http4k  server applications - the  HttpHandler . Here's that entire API again, just in case you've forgotten:  typealias   HttpHandler   =   ( Request )   -   Response   What does that mean in practice? Well - for one thing, it's less for your brain to learn  because you already know the API:  val   client :   HttpHandler   =   ApacheClient ()  val   response :   Response   =   client ( Request ( GET ,   http://server/path ))   For another, it means that since clients are  just function s you can easily stub them for testing, and since applications and clients are interchangeable, they can be plugged together in memory without putting them on the network - which makes testing insanely fast:  fun   MyApp1 ():   HttpHandler   =   {   Response ( OK )   }  fun   MyApp2 ( app1 :   HttpHandler ):   HttpHandler   =   {   app1 ( it )   }  val   app1 :   HttpHandler   =   MyApp1 ()  val   app2 :   HttpHandler   =   MyApp2 ( app1 )   http4k  provides a HTTP client adapters for both  Apache  and  OkHttp , all with streaming support.", 
            "title": "Claim B. Symmetric HTTP"
        }, 
        {
            "location": "/blog/meet_http4k/#claim-c-typesafe-http-with-lenses", 
            "text": "The immutable  http4k  model for HTTP objects contains all the usual suspect methods for getting values from the messages. For instance, if we are expecting a search parameter with a query containing a page number:  val   request   =   Request ( GET ,   http://server/search?page=123 )  val   page :   Int   =   request . query ( page ) !! . toInt   ...but we also want to ensure that the expected values are both present and valid, since the above example will fail if either of those things is not true. For this purpose, we can use a  Lens  to enforce the expected HTTP contract.  The use of Lenses in  http4k  applications can remove the need for writing any parsing or validation code for all incoming data (including Forms), as validations are taken care of by the library.", 
            "title": "Claim C. Typesafe HTTP with Lenses"
        }, 
        {
            "location": "/blog/meet_http4k/#lens-basics", 
            "text": "A Lens is a bi-directional entity which can be used to either  get  or  set  a particular value from/onto an HTTP message.  http4k  provides a DSL to configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional) and the type. For the above example, we could use the  Query  Lens builder and then  invoke()  the Lens on the message to extract the target value:  val   pageLens   =   Query . int (). required ( page )  val   page :   Int   =   pageLens ( Request ( GET ,   http://server/search?page=123 ))   If the query parameter is missing or not an Int, the lens extraction operation will fail. There are similar Lens builder functions for all parts of the HTTP message ( Header ,  Path ,  Body ,  FormField  etc..), and functions for all common JVM primitive types. They are all completely typesafe - there is no reflection or magic going on - just marshalling of the various entities (in this case String to Int conversion).  In the case of failure, we need to apply a Filter to detect the errors and convert them to a BAD_REQUEST response:  val   queryName   =   Query . string (). required ( name )  val   app :   HttpHandler   =   routes ( \n       /post   bind   POST   to   {   request :   Request   -   Response ( OK ). body ( queryName ( request ))   } \n     )  val   app   =   ServerFilters . CatchLensFailure . then ( handler )( Request ( GET ,   /hello/2000-01-01?myCustomType=someValue ))   Lenses can also be applied with a correctly typed value (via  invoke() ) to set it  onto  a target object - and as HTTP messages in  http4k  are immutable, this results in a copy of the modified message:  val   pageSizeLens   =   Header . int (). required ( page )  val   page :   Response   =   pageLens ( Response ( OK ),   123 )  // or apply multiple lenses using with()  val   updated :   Request   =   Request ( GET ,   /foo ). with ( pageLens   of   123 ,   pageSizeLens   of   10 )   Securely extracting JDK primitives from HTTP messages is great, but we really want to avoid primitives entirely and go straight to domain types. During construction of Lens, the builders allow mapping to occur so we can leverage Kotlin data classes. This works for both get and set operations:  data   class   MyDate ( val   value :   LocalDate )  val   dateQuery   =   Query . localDate (). map ( :: MyDate ,   MyDate :: value ). required ( date )  val   myDate :   MyDate   =   dateQuery ( Request ( GET ,   http://server/search?date=2000-01-01 ))", 
            "title": "Lens basics"
        }, 
        {
            "location": "/blog/meet_http4k/#lensing-http-bodies-with-data-classes", 
            "text": "Some of the supported message libraries (eg. GSON, Jackson, Moshi, XML) provide the mechanism to automatically marshall data objects to/from JSON and XML using reflection (oops - looks like we broke our reflection promise - but technically we're not doing it ;) !). This behaviour is supported in  http4k  Lenses through the use of the  auto()  method, which will marshall objects to/from HTTP messages:  data   class   Email ( val   value :   String )  data   class   Message ( val   subject :   String ,   val   from :   Email ,   val   to :   Email )  val   messageLens   =   Body . auto Message (). toLens ()  val   body   =   { subject : hello , from :{ value : bob@git . com }, to :{ value : sue@git . com }}  val   message :   Message   =   messageLens ( Request ( GET ,   / ). body ( body ))   This mechanism works for all incoming and outgoing JSON and XML Requests and Responses. To assist with developing whilst using this type of auto-marshalling, we have created a  tool  to automatically generate a set of data classes for a given messages.", 
            "title": "Lensing HTTP bodies with Data classes"
        }, 
        {
            "location": "/blog/meet_http4k/#claim-d-serverless", 
            "text": "Ah yes - Serverless - the latest in the Cool Kids Club and killer fodder for the resume. Well, since  http4k  is server independent, it turns out to be fairly trivial to deploy full applications to  AWS Lambda , and then call them by setting up the  API Gateway  to proxy requests to the function. Effectively, the combination of these two services become just another Server back-end supported by the library.  In order to achieve this, only a single interface  AppLoader  needs to be implemented - this is responsible for creating the  HttpHandler  which is adapted to the API of the  ApiGatewayProxyRequest/ApiGatewayProxyResponse  used by AWS. As this is AWS, there is a fair amount of configuration required to make this possible, but the only  http4k  specific config is to:   Set the function execution to call  org.http4k.serverless.lambda.LambdaFunction::handle  Set an environment variable for the Lambda  HTTP4K_BOOTSTRAP_CLASS  to the class of your  AppLoader  class.   Here's a simple example:  object   TweetEcho   :   AppLoader   { \n     override   fun   invoke ( env :   Map String ,   String ):   HttpHandler   =   { \n         Response ( OK ). body ( it . bodyString (). take ( 140 )) \n     }  }   Since  http4k  is very dependency-light, full binary uploads of these AWS Lambdas tend to be very small - and by utilising  Proguard  we've seen the size of a Lambda UberJar go as small as 150kb.  Introduced in v3.0.0, this support is available in the  http4k-serverless-lambda  module.", 
            "title": "Claim D. Serverless"
        }, 
        {
            "location": "/blog/meet_http4k/#the-final-words", 
            "text": "As pointed out above,  http4k-core  module has zero dependencies. It is also small, even though it also provides:   Support for static file-serving with HotReload.  A bunch of useful Filters for stuff like  Zipkin  Request Tracing.  Support for Request Contexts.  Facilities to record and replay HTTP traffic.   There are also a bunch of other modules available, all presented with the same concentration on Testability, API simplicity and consistency:   ViewModel driven templating engine support (Handlerbars etc) with HotReload.  Popular JSON/XML (Gson, Jackson, Moshi, etc) library support for HTTP bodies.  Typesafe HTML Form and Multipart Forms processing, with support for Streaming uploads to a storage service. Forms can also be configured to collect errors instead of just rejecting outright.  Typesafe contract module, providing live  OpenApi/Swagger  documentation.  AWS  request signing.  Resilience4j  integration, including Circuit Breakers   Rate Limiting.  Testing support via  Hamkrest  matchers and an in-memory  WebDriver  implementation.   Finally,  http4k  is  proven in production , it has been adopted in at least 2 global investment banks and is serving the vast majority of traffic for a major publishing website (in the top 1000 sites globally according to  alexa.com  - ie. easily serving 10s of million hits per day on a few nodes) since March 2017.   You can see a few example applications  here , including a bootstrap project for creating a  Github -  Travis -  Heroku  CD pipeline  in a single command.  Well, that's it for this whirlwind tour - we hope you found it worth reading this far! We'd love you to try out  http4k  and feedback why you love/hate/are indifferent to it :) . And if you want to get involved or chat to the authors, we hang out in the friendly #http4k channel @  slack.kotlinlang,org .", 
            "title": "The final word(s)!"
        }, 
        {
            "location": "/blog/meet_http4k/#footnotes", 
            "text": "\"But... but... but... asynchronous! And Webscale!\" ,  I heard them froth . Yes, you are correct - \"Server as a Function\" is based on asynchronous functions and  http4k  exposes a synchronous API. However, our experience suggests that for the vast majority of apps, this actually makes API integration harder unless you've got async all the way down - and that is assuming that async clients are actually available for all your various remote dependencies. We found that this plainly didn't matter for our use-cases so went for  Simple API\u2122  instead... it's possible however that Kotlin co-routines will allow us to revisit this decision.  (UPDATE) Websockets?  Yep - simple, testable, and now available in v3.2.1! See the introductory  blog post  for details.!", 
            "title": "Footnotes"
        }, 
        {
            "location": "/blog/typesafe_websockets/", 
            "text": "Websockets. But typesafe. And testable. Without the Server.\n\n\n@daviddenton\n / december 2017\n\n\nReaction to the last post introducing \nhttp4k\n was pretty good, and one of the most popular questions was: \n\"But what about Websockets\"\n?\n\n\nThe answer to that question at the time was an emphatic \n\"Not yet\"\n - because they didn't fit the \"Server as a Function\" model, and the team hadn't worked out a way to deliver them in a simple, offline testable\n way.\n\n\nWell, a month is a long time, and we've been beavering away, so now we're thrilled to release \nWebsockets for \nhttp4k\n, which are:\n\n\n\n\nSimple\n: using the same style of API as the rest of \nhttp4k\n, allowing the same dynamic path-based routing as is available for standard \nHttpHandlers\n.\n\n\nTypesafe\n: Marshall and unmarshall typed objects from Websocket Messages using the established Lens API.\n\n\nTestable\n: This is something that is massively important to us - and just like standard HttpHandlers, \nhttp4k\n Websockets are completely testable in a synchronous online or offline environment. No. Server. Required.\n\n\n\n\nDetails schmeetails...\n\n\nJust as with HttpHandlers, the here are 2 basic function types which make up the core of the Websocket routing API:\n\n\n\n\nA \nWsHandler\n - represented as a typealias: \n(Request) -\n WsConsumer?\n. This is responsible for matching an incoming HTTP upgrade request to a websocket.\n\n\nWsConsumer\n - represented as a typealias: \n(WebSocket) -\n Unit\n. This function is called on connection and allow the API user to react to events coming from the connected Websocket by attaching listeners.\n\n\n\n\nAdditionally, \nWsMessage\n objects are used for actual communication - ie. a message which is sent or received on a Websocket. This message can take advantage of the typesafety accorded to other entities in \nhttp4k\n by using the Lens API. And just like the \nhttp4k\n HTTP message model, WsMessages are \nimmutable data classes\n.\n\n\nAn example server \n\n\nThe example below shows how:\n\n\n\n\nWebsockets can be dynamically routed\n\n\nLens-based marshalling of Websocket message objects using Jackson. \n\n\nWsHandler\n can be combined with an \nHttpHandler\n to make a \nPolyHandler\n - an application which can serve many protocols. Conversion of the \nPolyHandler\n to a supporting Server can be done via the standard \nasServer()\n mechanism, or it can be kept offline for ultra-fast in-memory testing:\n\n\n\n\n\n\n\nAlternatively, you can check out the Websocket enabled \nhttp4k\n demo: \nIRC clone in 30 lines of Kotlin\n.\n\n\nTestability \n\n\nAs well as API simplicity, the \nhttp4k\n team are very passionate about testing, and it was very important that this could be done in an out-of-container fashion - ie. in memory and with no server being started. As such, it is possible to call \ntestWsClient()\n on an \nWsHandler\n to provide a synchronous API for testing. Messages and other events can be \"sent\" to a connected websocket and responses will be received back in a completely predictable way from the application under test.\n\n\nIn the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server. \nhttp4k\n provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic:\n\n\n\n\n\nFin\n\n\nWebsocket support is now available for the Jetty server backend in \nhttp4k\n \nv3.2.0\n. We plan to roll out support for other server-backends in due course. Have a play a let us know what you think... \n\n\nFootnotes\n\n\n\n\n We had a bit of a search for \"unit testing websockets\", half through curiosity and half because we wanted to swipe other people's ideas for implementing it. But we came up with nothing - it seems like all the existing JVM HTTP libraries rely on running servers for testing websockets. We hope we're wrong - because the alternative makes us a little \ninsert sadface emoji/\n. If we are, then please let us know! \ud83d\ude1d", 
            "title": "Typesafe Websockets"
        }, 
        {
            "location": "/blog/typesafe_websockets/#websockets-but-typesafe-and-testable-without-the-server", 
            "text": "", 
            "title": "Websockets. But typesafe. And testable. Without the Server."
        }, 
        {
            "location": "/blog/typesafe_websockets/#daviddenton-december-2017", 
            "text": "Reaction to the last post introducing  http4k  was pretty good, and one of the most popular questions was:  \"But what about Websockets\" ?  The answer to that question at the time was an emphatic  \"Not yet\"  - because they didn't fit the \"Server as a Function\" model, and the team hadn't worked out a way to deliver them in a simple, offline testable  way.  Well, a month is a long time, and we've been beavering away, so now we're thrilled to release  Websockets for  http4k , which are:   Simple : using the same style of API as the rest of  http4k , allowing the same dynamic path-based routing as is available for standard  HttpHandlers .  Typesafe : Marshall and unmarshall typed objects from Websocket Messages using the established Lens API.  Testable : This is something that is massively important to us - and just like standard HttpHandlers,  http4k  Websockets are completely testable in a synchronous online or offline environment. No. Server. Required.", 
            "title": "@daviddenton / december 2017"
        }, 
        {
            "location": "/blog/typesafe_websockets/#details-schmeetails", 
            "text": "Just as with HttpHandlers, the here are 2 basic function types which make up the core of the Websocket routing API:   A  WsHandler  - represented as a typealias:  (Request) -  WsConsumer? . This is responsible for matching an incoming HTTP upgrade request to a websocket.  WsConsumer  - represented as a typealias:  (WebSocket) -  Unit . This function is called on connection and allow the API user to react to events coming from the connected Websocket by attaching listeners.   Additionally,  WsMessage  objects are used for actual communication - ie. a message which is sent or received on a Websocket. This message can take advantage of the typesafety accorded to other entities in  http4k  by using the Lens API. And just like the  http4k  HTTP message model, WsMessages are  immutable data classes .", 
            "title": "Details schmeetails..."
        }, 
        {
            "location": "/blog/typesafe_websockets/#an-example-server", 
            "text": "The example below shows how:   Websockets can be dynamically routed  Lens-based marshalling of Websocket message objects using Jackson.   WsHandler  can be combined with an  HttpHandler  to make a  PolyHandler  - an application which can serve many protocols. Conversion of the  PolyHandler  to a supporting Server can be done via the standard  asServer()  mechanism, or it can be kept offline for ultra-fast in-memory testing:    Alternatively, you can check out the Websocket enabled  http4k  demo:  IRC clone in 30 lines of Kotlin .", 
            "title": "An example server "
        }, 
        {
            "location": "/blog/typesafe_websockets/#testability", 
            "text": "As well as API simplicity, the  http4k  team are very passionate about testing, and it was very important that this could be done in an out-of-container fashion - ie. in memory and with no server being started. As such, it is possible to call  testWsClient()  on an  WsHandler  to provide a synchronous API for testing. Messages and other events can be \"sent\" to a connected websocket and responses will be received back in a completely predictable way from the application under test.  In the below example, we have gone one step further - defining a contract test case and then providing 2 implementations of it - one for unit-testing (in memory), one using a server.  http4k  provides clients with an identical interface for both cases, meaning it's possible reuse the same test logic:", 
            "title": "Testability "
        }, 
        {
            "location": "/blog/typesafe_websockets/#fin", 
            "text": "Websocket support is now available for the Jetty server backend in  http4k   v3.2.0 . We plan to roll out support for other server-backends in due course. Have a play a let us know what you think...", 
            "title": "Fin"
        }, 
        {
            "location": "/blog/typesafe_websockets/#footnotes", 
            "text": "We had a bit of a search for \"unit testing websockets\", half through curiosity and half because we wanted to swipe other people's ideas for implementing it. But we came up with nothing - it seems like all the existing JVM HTTP libraries rely on running servers for testing websockets. We hope we're wrong - because the alternative makes us a little  insert sadface emoji/ . If we are, then please let us know! \ud83d\ude1d", 
            "title": "Footnotes"
        }, 
        {
            "location": "/changelog/", 
            "text": "Changelog\n\n\n\nThis list is not currently intended to be all-encompassing - it will document major and breaking API changes with their rationale when appropriate:\n\n\nv3.30.0\n\n\n\n\nAllow all server implementations to start on port 0 (ie. find a free port) and then report it back as a part of the \nHttp4kServer\n interface\n\n\n\n\nv3.29.0\n\n\n\n\nMake HTTP clients resilient to unknown host and connectionrefused exceptions\n\n\nImplememted #134 - Added default (de)serialization for common JDK primitives to all Auto-marshalling JSON modules - eg. datetimes and UUIDs\n\n\n\n\nv3.28.0\n\n\n\n\nFix #131 - Uri's created with paths that don't contain leading slashes.\n\n\nAdded etag parser filter. H/T @dgliosca for the PR\n\n\nFix #132 - Ensured that \ndisableDefaultTyping\n is called in default Jackson implementation. This should be the default anyway, but has been added to ensure that we don't fall foul of \nCVE-2017-7525\n and to surface awareness of this issue.\n\n\n\n\nv3.27.0\n\n\n\n\nOpenAPI now provides example values in the generated schema. H/T @skewwhiffy for the PR.\n\n\n\n\nv3.26.6\n\n\n\n\nFix #126 - ResourceLoadingHandler can expose mapped resources into the root. \n-- We think this is an important update, so please upgrade!\n\n\n\n\nv3.26.5\n\n\n\n\nFix #125 - ApacheServer implementation now sets content length if present.\n\n\n\n\nv3.26.4\n\n\n\n\nFix #123 - Multipart Body objects blow up when parsed after being debugged. As with all streams, care should be taken to not blow heap when internalising them for debugging purposes.\n\n\n\n\nv3.26.3\n\n\n\n\nDebugging filter now supports ignoring Multipart streams.\n\n\n\n\nv3.26.2\n\n\n\n\nTweak: OpenAPI now doesn't return null values in the schema.\n\n\n\n\nv3.26.1\n\n\n\n\nFix #124 - headers in WebSocket upgrade request are incorrectly joined.\n\n\n\n\nv3.26.0\n\n\n\n\nRemoved \nsupportedContentTypes\n field from OpenApi contract JSON, since this is a legacy field.\n\n\n\n\nv3.25.0\n\n\n\n\nAdded option to Undertow to enable HTTP2 from main ServerConfig\n\n\n\n\nv3.24.0\n\n\n\n\nUpgrade various dependencies for Java 10 compatibility. H/T @tom\n\n\nFix bug with repeated params in Websocket upgrade request. H/T @tom\n\n\n\n\nv3.23.1\n\n\n\n\nComposite LensFailures now capture (at least) the first failing cause (probably the body parameter in the case of an \nhttp4k-contract\n module.\n\n\n\n\nv3.23.0\n\n\n\n\nFix #116 - Can provide a custom Response creation method for \nCatchLensFailure\n. H/T @elifarley for the inspiration!\n\n\n\n\nv3.22.4\n\n\n\n\nAdded singleton method for Json.array, since if you pass in a single JsonNode (Jackson), it accidentally iterates over the fields in the node instead of using the object as an entry in the array.\n\n\nFix #115 - Only add content-length for methods that allow content in AwsAuth filter\n\n\n\n\nv3.22.3\n\n\n\n\nPreserve routing information on request/response manipulation  \n\n\n\n\nv3.22.2\n\n\n\n\nhttp4k-security-oauth\n module added - with support for OAuth2 Authorization Grant flow\n\n\nReplaced classes reliant on \njavax.activation\n package, which allows Java 9+ to not require any external dependencies. \\o/\n\n\nFix #112 - \nApacheClient\n incorrectly sets headers on GET requests (this breaks F5 load balancers). H/T @simojenki\n\n\nPR #110 - Websocket client timeouts are incorrectly translated as seconds instead of millis. HT @anorth\n\n\nCore \nJavaHttpClient\n does not support streaming due to limitations with \nHttpURLConnection\n \n\n\n\n\nv3.21.1\n\n\n\n\nFix #109 - Jackson treats integer values inconsistently, leading to matching errors when using hamkrest.\n\n\n\n\nv3.21.0\n\n\n\n\nFix #107 - Killed the x-uri-template header and fixed the ReportHttpTransaction to have access to the \nroutingGroup\n.\n\n\nAltered ordering of filters in \nhttp4k-contract\n so that the route is identified before pre-filters and security are applied. This allows knowledge of the path to be accessible at the time of application of those filters.\n\n\n\n\nv3.20.0\n\n\n\n\nIntroduce JavaHttpClient to \nhttp4k-core\n. It provides a very basic http client without  any other 3rd party dependencies.\n\n\n\n\nv3.19.0\n\n\n\n\nPR #104 - Add optional time/date formatters to LensSpecs so you can choose you serialisation format. H/T @elifarley\n\n\nFix #105 - Swagger API json file: duplicate key in \"definitions\".\n\n\n\n\nv3.18.1\n\n\n\n\nFixed PR #100 - URI template regex required extra escaping. This only affects Android deployments as IDE shows the regex escaping is redundant. H/T @privatwolke\n\n\n\n\nv3.18.0\n\n\n\n\nBreaking: converted contract pre-security filter to be a post-security filter. This means that all standard filters are applied before the security later, which allows for logging and monitoring and context setup. The previous filter mechanic applied security first, which didn't allow for this. In the unlikely event that post-security filters still need to be applied, use the \nwithPostSecurityFilter()\n function when building the contract.\n\n\nDocs for contract RouteMeta function parameters, and deprecated some unused functions (missed when we introduced the DSL).\n\n\nPR #99 - Contract routes now support up to 10 path segments. Thanks to @scap1784 for the PR! :)\n\n\n\n\nv3.17.1\n\n\n\n\nFix #97. Moshi does not fail when deserialise non-nullable fields correctly. Note that GSON still suffers from this problem\n\n\n\n\nv3.17.0\n\n\n\n\nAdded a pre-security filter option to contract creation, so that you can explicitly specify behaviour to occur before security kicks in.\n\n\n\n\nv3.16.0\n\n\n\n\nConvert \nSecurity\n (from sealed class) and \nApiKey\n to be interfaces. This allows users to implement their own security models.\n\n\n\n\nv3.15.0\n\n\n\n\nIntroduce \nHttpTransaction\n and new \nReportHttpTransaction\n filter provide better generic API for reporting, along with the ability to label transactions for this purpose.\n\n\nBreaking: Rework the metrics request counter and timer Filter API. There is now a \nHttpTransactionLabeller\n for you to add as many labels as required to the transaction. Each of these labels will be used to tag the metric.\n\n\n\n\nv3.14.1\n\n\n\n\nFix #95 - Filters are now applied to \"route not found\" responses\n\n\n\n\nv3.14.0\n\n\n\n\nFix #93 - Apache server doesn't like content-length or transfer-encoding headers present in http4k response.\n\n\nAdd ability to \"name\" input and output contract body definitions in an OpenAPI JSON doc. This applies to only the top level entity. If no override is passed, the objects are named according to their hashcode.\n\n\n\n\n3.13.4\n\n\n\n\nFix #92 - cookie date should always use US locale\n\n\n\n\nv3.13.3\n\n\n\n\nFurther tweak to Netty. H/T @FredDeschenes\n\n\n\n\nv3.13.2\n\n\n\n\nFix #91 - large message handli\nng in Netty\n\n\n\n\nv3.13.1\n\n\n\n\nUpgrade to Kotlin 1.2.20\n\n\n\n\nv3.13.0\n\n\n\n\nSupport for \noperationId\n in OpenApi route metadata. H/T @danschultz for the PR.\n\n\nRemoved previously deprecated methods.\n\n\n\n\nv3.12.0\n\n\n\n\nNew client module \nhttp4k-client-jetty\n, which supports both sync and async models.\n\n\n\n\nv3.11.1\n\n\n\n\nFix #84. OPTIONS requests are not detected by contract routes.\n\n\nAdded option to NOT authorise OPTIONS requests in ApiKey security filter.\n\n\nAdded support for Async HTTP clients and added new \nAsyncHttpClient\n interface, which is obviously used for HTTP clients only**, and not server-side calls. :)\n\n\nNew client module \nhttp4k-client-apache-async\n.\n\n\nNew metrics gathering module \nhttp4k-metrics-micrometer\n. Big H/T to @kirderf for the PR.\n\n\nAdded support for async to \nOkHttp\n client module.\n\n\n\n\nv3.10.0\n\n\n\n\nP/R 81 - adding headers and timeout to websocket client.\n\n\n\n\nv3.9.0\n\n\n\n\nAdded compactify and prettify to Json implementations\n\n\nAdded \nJson.hasBody\n Hamkrest matchers for comparing bodies. Note these are extension methods and need to be referenced/imported as such.\n\n\n\n\nv3.8.0\n\n\n\n\nAdded facility for non-blocking websocket client to react to onConnect event. This API is\nthe same as the inbound, server-side API - ie. there are no explicit connection event handlers. H/T @tom for the idea.\n\n\n\n\nv3.7.0\n\n\n\n\nP/R #13 Create extension methods for Response to add caching headers. H/T @k0zakinio.\n\n\n\n\nv3.6.1\n\n\n\n\nFix #78. Serialisation of raw lists using Moshi fails in the same way as the Jackson auto-conversions do. Added convenience methods to get around this.\n\n\n\n\nv3.6.0\n\n\n\n\nAdded \nhttp4k-format-moshi\n to support the Square auto-marshalling library.\n\n\n\n\nv3.5.1\n\n\n\n\nFix #76 - encoding of path segments to use URI encoding instead of URL form encoding.\n\n\n\n\nv3.5.0\n\n\n\n\nAdded support for multiple HotReload template directories in \nHandlebarsTemplates\n. H/T @TomShacham\n\n\nFix #74 - Request tracing span/parentSpan set too early so was shared between outgoing requests.\n\n\n\n\nv3.4.0\n\n\n\n\nNew server backend \nhttp4k-server-apache\n. H/T @kirderf for the PR :)\n\n\nWe now set the length of the incoming request body when it is available in the incoming request.\n\n\n\n\nv3.3.1\n\n\n\n\nHandlebars now uses combination of Class and Template name to cache templates.\n\n\n\n\nv3.3.0\n\n\n\n\nFacility to compose \nTemplateRenderers\n with \nthen()\n to provide fallback behaviour.\n\n\n\n\nv3.2.3\n\n\n\n\nPR #70: Header order equality for Request/Response - H/T @gypsydave5.\n\n\n\n\nv3.2.2\n\n\n\n\nSwitched out \nStatus\n for \nWsStatus\n (with proper RFC code set) in Websockets.\n\n\n\n\nv3.2.1\n\n\n\n\nTypesafe Websockets! Jetty now supports websockets, using the same style of API in the main http4k routing.\n\n\n(Possible) Breaking change: Because \nWsHandler\n (typealias) implements the same inbound interface as \nHttpHandler\n, you now cannot declare \nHttpHandlers\n without specifying the input type, so any \"anonymous\" handlers will not compile as a result. The required fix is very simple, but manual:\n `{ Response(OK) } should become { _:Request -\n Response(OK) }\n\n\n\n\nv3.1.3\n\n\n\n\nFix Request.form() for streaming requests\n\n\n\n\nv3.1.2\n\n\n\n\nRemove possibility of empty message for Path Lens failure.\n\n\n\n\nv3.1.1\n\n\n\n\nNew (better!) API for \nhttp4k-contract\n module. Old meta DSL has been deprecated.\n\n\n\n\nv3.0.1\n\n\n\n\nFix #63 - Apache Client Connect. timeout exception handling.\n\n\n\n\nv3.0.0\n\n\n\n\nAdded \nhttp4k-serverless-lambda\n module, allowing http4k applications to be deployed into AWS Lambda and then called from API Gateway. Effectively, the combination of these two services become just another Server back-end supported by the library. \\o/\n\n\n\n\nv2.38.1\n\n\n\n\nRequestContextKey\n now follow the standardised Lens structure of required, optional, defaulted, and can now be removed (set to null). Replace calls\nto \nRequestContextKey.of()\n with \nRequestContextKey.required()\n \n\n\nRemoved previously deprecated values. See below for details on replacements.\n\n\n\n\nv2.37.0\n\n\n\n\nAdded \nhttp4k-resilience4j\n module, which adds Circuits, RateLimiters, Retrying and Bulkheading.\n\n\nFix #60 (H/T @michaelhixson for the spot).\n\n\n\n\nv2.36.0\n\n\n\n\nAdded a couple of useful \nServerFilters\n.\n\n\nUpgrade various dependency versions.\n\n\nTidying of Multipart code.\n\n\n\n\nv2.35.1\n\n\n\n\nFix #57. Static handlers behave oddly when combined with an HTTP verb in the routing tree.\n\n\n\n\nv2.35.0\n\n\n\n\nFix #56. Altered behaviour of \nCatchLensFailure\n to NOT catch errors from unmarshalling Response objects. This was causing BAD_REQUEST to be incorrectly generated.\n\n\nSimplification of generics around LensSpecs. This should not be a breaking change, (there were 3 generics, now the MID has been removed so there are just 2) but could break if signatures are used explicitly.\n\n\n\n\nv2.34.0\n\n\n\n\nReordered generics in LensInjector to make sense. This should have no effect on most code-bases, but could break if signatures are used explicitly. Just flip the generic types to switch.\n\n\n\n\nv2.33.1\n\n\n\n\nAdded support for unsigned AWS requests, which enables streaming content to S3. \n\n\n\n\nv2.33.0\n\n\n\n\nAdded \nBodyMode.Request\n to configure streaming for clients.\n\n\nResponseBodyMode\n is now \nBodyMode.Response\n (Breaking change. Fixable with simple find/replace).\n\n\n\n\nv2.32.0\n\n\n\n\nAdded \nServerFilter.ProcessFiles\n filter to stream Multipart Files, convert them into references and replace inline in the Form.\n\n\n\n\nv2.31.4\n\n\n\n\nAvoid realising StreamBody unless necessary, which could break common usages of streaming. \n\n\n\n\nv2.31.3\n\n\n\n\nTweaks to Server backends to improve efficiency.\n\n\n\n\nv2.31.2\n\n\n\n\nWebdriver will keep only the final URI after redirects.\n\n\n\n\nv2.31.1\n\n\n\n\nIncreased granularity of \nReplay.DiskStream\n and ensure that traffic is returned in exact order on all OSes.\n\n\nAdd support for redirects to Webdriver.\n\n\n\n\nv2.31.0\n\n\n\n\nMultipart module tweaked to provide a more consistent API.\n\n\nFix FollowRedirects for POST/PUT request.\n\n\n\n\nv2.30.0\n\n\n\n\nMultipart form support through new module \nhttp4k-multipart\n.\n\n\nDeprecation: Replaced \nSwagger\n with \nOpenApi\n and deprecated the former (via typealias).\n\n\nDeprecation: Replaced \nFormValidator\n with \nValidator\n and deprecated the former (via typealias).\n\n\n\n\nv2.29.4\n\n\n\n\nRefactor release.\n\n\n\n\nv2.29.3\n\n\n\n\nFix #50 - Webdriver does not normalise relative links correctly.\n\n\n\n\nv2.29.2\n\n\n\n\nHttp client modules now catch and convert Socket Timeout exceptions to HTTP 504s (with a custom message)\n\n\n\n\nv2.29.1\n\n\n\n\nTweaks to how recorded traffic is stored on disk. Thanks to @dkandalov for the PR around this.\n\n\n\n\nv2.29.0\n\n\n\n\nAdded \nTrafficFilters\n for recording and replaying HTTP traffic. See \norg.http4k.traffic\n package for details.\n\n\n\n\nv2.28.0\n\n\n\n\nAdded \nhttp4k-template-dust\n for Dust template engine support. Thanks to @npryce for the PR to add this.\n\n\n\n\nv2.27.2\n\n\n\n\nFix #44 - Use quotes around cookie values\n\n\n\n\nv2.27.1\n\n\n\n\nRaise proper Exception (instead of LensFailure) when RequestContexts are not set up correctly, so we don't accidentally classify developer errors as BadRequests\n\n\n\n\nv2.27.0\n\n\n\n\nAdded facility to assign values into a \nRequestContext\n which is passed down the Filter chain. \n\n\n\n\nv2.26.3\n\n\n\n\nFix #44 - Request cookies should not be wrapped in quotes.\n\n\n\n\nv2.26.2\n\n\n\n\nFix #43 - AWS does not sign binary requests correctly.\n\n\n\n\nv2.26.1\n\n\n\n\nFix #41 - Sending binary body alters the size of the payload.\n\n\n\n\nv2.26.0\n\n\n\n\nAdded \"catch all\" routing option, which matches all methods to a handler.\n\n\n\n\nv2.25.4\n\n\n\n\nFix #40 - GZip filters now use content-encoding headers instead of transfer-encoding.\n\n\n\n\nv2.25.3\n\n\n\n\nFix #39 - ResponseBodyMode.Memory properly closes streams (breaks jetty + gzip).\n\n\n\n\nv2.25.2\n\n\n\n\nEnsure that streams are closed properly when consuming from an upstream client.\n\n\n\n\nv2.25.1\n\n\n\n\nRemove Apache client request streaming because it may not release connections properly. \n\n\n\n\nv2.25.0\n\n\n\n\nAdd streaming support to HTTP Server and Client modules.\n\n\nRemove CatchLensFailure ClientFilter as it will never be used.\n\n\n\n\nv2.24.0\n\n\n\n\nAdded CatchLensFailure for ClientFilters - which catches un-deserializable invalid responses from clients and generates a BAD_GATEWAY error.\n\n\n\n\nv2.23.4\n\n\n\n\nSwitch XML generation to Gson over Jackson because Jackson doesn't handle uppercase field names well.\n\n\nSwitch native XML parsed type to Document over Node.\n\n\n\n\nv2.23.3\n\n\n\n\nNew algorithm for XML data class deserialisation, so un-deprecated XML methods.\n\n\n\n\nv2.23.2\n\n\n\n\nDeprecated methods in XML support due to limitation with underlying Jackson implementation.\n\n\n\n\nv2.23.1\n\n\n\n\nFixed bug with GenerateXmlDataClasses filter\n\n\n\n\nv2.23.0\n\n\n\n\nRenamed \nhttp4k-format-jackson-xml\n module to \nhttp4k-format-xml\n.\n\n\nImproved XML unmarshalling support.\n\n\n\n\nv2.22.1\n\n\n\n\nFixed 36: Form entry is too strict with content encoding.\n\n\n\n\nv2.22.0\n\n\n\n\nAdded \nhttp4k-format-jackson-xml\n module, with XML parsing support.\n\n\nUpgrade several dependencies\n\n\n\n\nv2.21.2\n\n\n\n\nFixed Hamkrest matchers to be on HttpMessage and not Http Request.\n\n\n\n\nv2.21.1\n\n\n\n\nDefault body Content Negotiation strategy changed to None\n\n\n\n\nv2.21.0\n\n\n\n\nConverted Content-Negotiation strategy from an Enum to an interface, so that users can define their own strategies. We also now check encoding so there are 4-built in strategies to choose from: Strict, StrictNoDirective, NonStrict and None.\n\n\n\n\nv2.20.1\n\n\n\n\nFixed #31 - Matching of segments in URIs is done after URLs are decoded, which results in not capturing encoded slashes in the path segments.\n\n\n\n\nv2.20.0\n\n\n\n\nFixed #30 - CachingClasspath template ResourceLoader not working with non-root packages.\n\n\n\n\nv2.19.0\n\n\n\n\nFixed #29 - webdriver submission of text area.\n\n\nHttp clients now use a new instance of the default for each instantiation. Previously there was a shared instance.\n\n\nAdd regex body type for parsing values out of bodies, and \"None\" option for content negotiation.\n\n\n\n\nv2.18.3\n\n\n\n\nFix AWS request signing for requests containing empty path \n\n\n\n\nv2.18.2\n\n\n\n\nFix AWS request signing for requests containing path with special characters \n\n\n\n\nv2.18.1\n\n\n\n\nAdded support for newRequest() in new \nRouteBinder\n mechanic.\n\n\n\n\nv2.18.0\n\n\n\n\nAdd support for unlimited nesting for \nroutes()\n blocks. Removed the raw \nRoute\n object, which can be replaced with \nRouter\n or \nRoutingHttpHandler\n where appropriate.\n\n\nAs part of above, rejigged route setup logic. Deprecated old routing structure, so now  \n\"/path\" to GET bind\n is \n\"/path\" bind GET to\n. To fix deprecation, simply switch the calls to \"to\" and \"bind\" in routing setup. \n\n\nRename of \nbind()\n in \nhttp4k-contract\n to be \nbindContract()\n\n\n\n\nv2.17.2\n\n\n\n\nAdded missing eclectic HTTP method. :)\n\n\n\n\nv2.17.1\n\n\n\n\nAdded GZip filters to \nhttp4k-core\n to zip request and response bodies.\n\n\n\n\nv2.16.1\n\n\n\n\nImproved messages for \nhttp4k-testing-hamkrest\n matchers.\n\n\n\n\nv2.16.0\n\n\n\n\nAdded \nhttp4k-testing-hamkrest\n which contains a set of Hamkrest matchers for Http4k objects.\n\n\n\n\nv2.15.0\n\n\n\n\nMore features for \nhttp4k-testing-webdriver\n. Cookie support added.\n\n\n\n\nv2.14.0\n\n\n\n\nMore features for \nhttp4k-testing-webdriver\n. We now support Form entry and submission.\n\n\n\n\nv2.13.0\n\n\n\n\nMore features for \nhttp4k-testing-webdriver\n.\n\n\n\n\nv2.12.0\n\n\n\n\nAdded \nhttp4k-testing-webdriver\n module, an ultralight Selenium WebDriver for \nhttp4k\n apps\n\n\n\n\nv2.11.3\n\n\n\n\nFix #26 - GenerateDataClasses does not recurse into nested object trees\n\n\n\n\nv2.11.2\n\n\n\n\nFix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with \nthen(RoutingHttpHandler()\n\n\n\n\nv2.11.1\n\n\n\n\nFix static routes not defaulting to index.html when in root context\n\n\n\n\nv2.11.0\n\n\n\n\nAdded \nSunHttp\n server implementation (for development use only)\n\n\n\n\nv2.10.1\n\n\n\n\nFix cookie parsing when value contains '='\n\n\n\n\nv2.10.0\n\n\n\n\nAdd method to set form values in the request\n\n\n\n\nv2.9.0\n\n\n\n\nAdded PURGE HTTP method as it's used commonly by various caches.\n\n\n\n\nv2.8.1\n\n\n\n\nRepackage AWS classes for consistency with rest of project\n\n\n\n\nv2.7.1\n\n\n\n\nAlter AWS Auth filter creation. Now use \nClientFilters.AwsAuth\n\n\n\n\nv2.7.0\n\n\n\n\nAdd AWS module\n\n\n\n\nv2.6.0\n\n\n\n\nNewly created Zipkin traces are now populated onto incoming request in ServerFilters.\n\n\n\n\nv2.5.1\n\n\n\n\nSlight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling\n\n\n\n\nv2.5.0\n\n\n\n\nAdd \nThymeleaf\n templating support\n\n\n\n\nv2.4.0\n\n\n\n\nAdd \nPebble\n templating support\n\n\n\n\nv2.3.0\n\n\n\n\nMake Route a Router so we can nest them together.\n\n\n\n\nv2.2.1\n\n\n\n\nRemove excess \"charset\" from headers in Undertow.\n\n\n\n\nv2.2.0\n\n\n\n\nRename  \nby()\n to \nbind()\n in routing for clarity. \n\n\n\n\nv2.1.2\n\n\n\n\nFix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex.\n\n\n\n\nv2.1.0\n\n\n\n\nAdded GSON full-auto functions to convert arbitary objects to/from JSON.\n\n\n\n\nv2.0.5\n\n\n\n\nFix #23. Contract now supports multi-part URL params (for hardcoded parts)\n\n\n\n\nv2.0.4\n\n\n\n\nFix #22. Uri template does not parse out correct path params when URL starts with a path part.\n\n\n\n\nv2.0.3\n\n\n\n\ntoString() implementations to aid debugging\n\n\n\n\nv2.0.1\n\n\n\n\nReadded missing default parameter for \nnewRequest()\n on RouteSpec\n\n\n\n\nv2.0.0\n\n\n\n\nBreaking: Inversion of routing API. \nGET to \"/someUri\"\n is now \n\"/someUri\" to GET\n for consistency across the entire API.\n\n\n\n\nv1.33.1\n\n\n\n\nReimplementation of \nhttp4k-contract\n API to match main routing API. Contracts are now nestable.\n\n\n\n\nv1.32.2\n\n\n\n\nFix Filters being applied twice in \nContractRoutingHttpHandler\n\n\n\n\nv1.32.1\n\n\n\n\nMore work on \nhttp4k-contract\n contract API\n\n\n\n\nv1.31.0\n\n\n\n\nRework \nhttp4k-contract\n routing to be mounted in the same way as other \nRoutingHttpHandlers\n\n\n\n\nv1.30.0\n\n\n\n\nFilters are now applied consistently to all Routers\n\n\n\n\nv1.29.0\n\n\n\n\nTweak to DSL for defining StaticRouters\n\n\n\n\nv1.28.1\n\n\n\n\nFix for #18: FollowRedirect will now work if location header includes charset information.  \n\n\n\n\nv1.28.0\n\n\n\n\nNew DSL for defining StaticRouters\n\n\n\n\nv1.27.0\n\n\n\n\nMerged StaticContent and StaticRouter and repackage of contract API into other packages\n\n\n\n\nv1.26.2\n\n\n\n\nExtend fix for #17 to request \nCookie\n header.\n\n\n\n\nv1.26.1\n\n\n\n\nFix for #17. Cookie can now parse a cookie without attributes and ending in semicolon.\n\n\n\n\nv1.26.0\n\n\n\n\nAdded nestable Routers.\n\n\nMerging of Modules and Routers. \nRouter\n is the new \nModule\n! \nRouteModule\n is now \nContractRouter\n, so rename in code will be required.\n\n\n\n\nv1.25.1\n\n\n\n\nFix for #15. OkHttp client handling of POSTs with no body.\n\n\n\n\nv1.25.0\n\n\n\n\nCan add custom mime types to Static Content\n\n\nGenerateDataClasses is capable of more complex object graphs\n\n\n\n\nv1.24.0\n\n\n\n\nRemove \nHttpHandler.asServer\n in favour of \nHttpHandler.startServer\n to avoid confusion.\n\n\nIntroduce \nStatus.description()\n.\n\n\n\n\nv1.23.0\n\n\n\n\nNetty sets content-length header.\n\n\n\n\nv1.22.2\n\n\n\n\nFix for #12. Undertow not constructing response correctly.\n\n\n\n\nv1.22.0\n\n\n\n\nNew module with Undertow.io support \nhttp4k-server-undertow\n\n\nJackson implementation now ignores unknown properties in incoming messages\n\n\nNetty implementation tidied up\n\n\n\n\nv1.21.1\n\n\n\n\nFix for #11. Netty implementation returns incorrect status codes.\n\n\n\n\nv1.21.0\n\n\n\n\nAdd synonym methods for Lenses to aid readability. We now have \ninvoke(IN)/extract(IN)\n and `invoke(IN, TARGET)/inject(IN, TARGET)\n\n\n\n\nv1.20.0\n\n\n\n\nhttp4k-contracts\n: Add option to change the route of the module description route\n\n\n\n\nv1.19.1\n\n\n\n\nhttp4k-contracts\n: Fix for contract module description routes not being authenticated via security filter\n\n\n\n\nv1.19.0\n\n\n\n\nhttp4k-contracts\n: Add \nSwagger\n module rendering with JSON schema models for messages.\n\n\n\n\nv1.18.0\n\n\n\n\nAdd \nnonEmptyString()\n lens type to all request parts.\n\n\n\n\nv1.17.0\n\n\n\n\nGeneral rework\n\n\n\n\nv1.16.0\n\n\n\n\nFurther work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios.\n\n\n\n\nv1.15.0\n\n\n\n\nPath lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc.\n\n\nRoutes can now create shell Requests for themselves, using \nroute.newRequest()\n\n\n\n\nv1.14.0\n\n\n\n\nBody is now non-nullable (use \nBody.EMPTY\n instead)\n\n\nRename methods \nBodyLens\n API for consistency and clarity. \nrequired()\n is now \ntoLens()\n. \nto()' binding method is now\nof().\n\n\n\n\nv1.13.0\n\n\n\n\nNew client module: \nhttp4k-client-okhttp\n\n\n\n\nv1.12.0\n\n\n\n\nTidying\n\n\n\n\nv1.11.0\n\n\n\n\nAdded option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :)\n\n\n\n\nv1.10.0\n\n\n\n\nMoved \nCredentials\n to \norg.http4k.core\n package.\n\n\nAdd various filters, including \nSetHostFrom\n and \nCatchAll\n.\n\n\n\n\nv1.9.0\n\n\n\n\nAdded \nGenerateDataClasses\n so you can generate Kotlin data classes from JSON messages.\n\n\n\n\nv1.8.0\n\n\n\n\nAdded CORs support\n\n\n\n\nv1.7.0\n\n\n\n\nAdded auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses\n\n\n\n\nv1.6.0\n\n\n\n\nAdded CachingFilters\n\n\n\n\nv1.5.0\n\n\n\n\nRemoved static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions.\n\n\nMerge \norg.http4k.core.Body\n and \norg.http4k.lens.Body\n.\n\n\nAdd Request/Response message parsers.\n\n\n\n\nv1.4.0\n\n\n\n\nTurn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected.\n\n\n\n\nv1.3.0\n\n\n\n\nRemoved non-mandatory parameters from Request and Response constructors. This is aid API clarity.\nand force users to use the API methods for properly constructing the objects.\n\n\nRegex Lens added.\n\n\n\n\nv1.0.0\n\n\n\n\nInitial major release.", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#v3300", 
            "text": "Allow all server implementations to start on port 0 (ie. find a free port) and then report it back as a part of the  Http4kServer  interface", 
            "title": "v3.30.0"
        }, 
        {
            "location": "/changelog/#v3290", 
            "text": "Make HTTP clients resilient to unknown host and connectionrefused exceptions  Implememted #134 - Added default (de)serialization for common JDK primitives to all Auto-marshalling JSON modules - eg. datetimes and UUIDs", 
            "title": "v3.29.0"
        }, 
        {
            "location": "/changelog/#v3280", 
            "text": "Fix #131 - Uri's created with paths that don't contain leading slashes.  Added etag parser filter. H/T @dgliosca for the PR  Fix #132 - Ensured that  disableDefaultTyping  is called in default Jackson implementation. This should be the default anyway, but has been added to ensure that we don't fall foul of  CVE-2017-7525  and to surface awareness of this issue.", 
            "title": "v3.28.0"
        }, 
        {
            "location": "/changelog/#v3270", 
            "text": "OpenAPI now provides example values in the generated schema. H/T @skewwhiffy for the PR.", 
            "title": "v3.27.0"
        }, 
        {
            "location": "/changelog/#v3266", 
            "text": "Fix #126 - ResourceLoadingHandler can expose mapped resources into the root.  -- We think this is an important update, so please upgrade!", 
            "title": "v3.26.6"
        }, 
        {
            "location": "/changelog/#v3265", 
            "text": "Fix #125 - ApacheServer implementation now sets content length if present.", 
            "title": "v3.26.5"
        }, 
        {
            "location": "/changelog/#v3264", 
            "text": "Fix #123 - Multipart Body objects blow up when parsed after being debugged. As with all streams, care should be taken to not blow heap when internalising them for debugging purposes.", 
            "title": "v3.26.4"
        }, 
        {
            "location": "/changelog/#v3263", 
            "text": "Debugging filter now supports ignoring Multipart streams.", 
            "title": "v3.26.3"
        }, 
        {
            "location": "/changelog/#v3262", 
            "text": "Tweak: OpenAPI now doesn't return null values in the schema.", 
            "title": "v3.26.2"
        }, 
        {
            "location": "/changelog/#v3261", 
            "text": "Fix #124 - headers in WebSocket upgrade request are incorrectly joined.", 
            "title": "v3.26.1"
        }, 
        {
            "location": "/changelog/#v3260", 
            "text": "Removed  supportedContentTypes  field from OpenApi contract JSON, since this is a legacy field.", 
            "title": "v3.26.0"
        }, 
        {
            "location": "/changelog/#v3250", 
            "text": "Added option to Undertow to enable HTTP2 from main ServerConfig", 
            "title": "v3.25.0"
        }, 
        {
            "location": "/changelog/#v3240", 
            "text": "Upgrade various dependencies for Java 10 compatibility. H/T @tom  Fix bug with repeated params in Websocket upgrade request. H/T @tom", 
            "title": "v3.24.0"
        }, 
        {
            "location": "/changelog/#v3231", 
            "text": "Composite LensFailures now capture (at least) the first failing cause (probably the body parameter in the case of an  http4k-contract  module.", 
            "title": "v3.23.1"
        }, 
        {
            "location": "/changelog/#v3230", 
            "text": "Fix #116 - Can provide a custom Response creation method for  CatchLensFailure . H/T @elifarley for the inspiration!", 
            "title": "v3.23.0"
        }, 
        {
            "location": "/changelog/#v3224", 
            "text": "Added singleton method for Json.array, since if you pass in a single JsonNode (Jackson), it accidentally iterates over the fields in the node instead of using the object as an entry in the array.  Fix #115 - Only add content-length for methods that allow content in AwsAuth filter", 
            "title": "v3.22.4"
        }, 
        {
            "location": "/changelog/#v3223", 
            "text": "Preserve routing information on request/response manipulation", 
            "title": "v3.22.3"
        }, 
        {
            "location": "/changelog/#v3222", 
            "text": "http4k-security-oauth  module added - with support for OAuth2 Authorization Grant flow  Replaced classes reliant on  javax.activation  package, which allows Java 9+ to not require any external dependencies. \\o/  Fix #112 -  ApacheClient  incorrectly sets headers on GET requests (this breaks F5 load balancers). H/T @simojenki  PR #110 - Websocket client timeouts are incorrectly translated as seconds instead of millis. HT @anorth  Core  JavaHttpClient  does not support streaming due to limitations with  HttpURLConnection", 
            "title": "v3.22.2"
        }, 
        {
            "location": "/changelog/#v3211", 
            "text": "Fix #109 - Jackson treats integer values inconsistently, leading to matching errors when using hamkrest.", 
            "title": "v3.21.1"
        }, 
        {
            "location": "/changelog/#v3210", 
            "text": "Fix #107 - Killed the x-uri-template header and fixed the ReportHttpTransaction to have access to the  routingGroup .  Altered ordering of filters in  http4k-contract  so that the route is identified before pre-filters and security are applied. This allows knowledge of the path to be accessible at the time of application of those filters.", 
            "title": "v3.21.0"
        }, 
        {
            "location": "/changelog/#v3200", 
            "text": "Introduce JavaHttpClient to  http4k-core . It provides a very basic http client without  any other 3rd party dependencies.", 
            "title": "v3.20.0"
        }, 
        {
            "location": "/changelog/#v3190", 
            "text": "PR #104 - Add optional time/date formatters to LensSpecs so you can choose you serialisation format. H/T @elifarley  Fix #105 - Swagger API json file: duplicate key in \"definitions\".", 
            "title": "v3.19.0"
        }, 
        {
            "location": "/changelog/#v3181", 
            "text": "Fixed PR #100 - URI template regex required extra escaping. This only affects Android deployments as IDE shows the regex escaping is redundant. H/T @privatwolke", 
            "title": "v3.18.1"
        }, 
        {
            "location": "/changelog/#v3180", 
            "text": "Breaking: converted contract pre-security filter to be a post-security filter. This means that all standard filters are applied before the security later, which allows for logging and monitoring and context setup. The previous filter mechanic applied security first, which didn't allow for this. In the unlikely event that post-security filters still need to be applied, use the  withPostSecurityFilter()  function when building the contract.  Docs for contract RouteMeta function parameters, and deprecated some unused functions (missed when we introduced the DSL).  PR #99 - Contract routes now support up to 10 path segments. Thanks to @scap1784 for the PR! :)", 
            "title": "v3.18.0"
        }, 
        {
            "location": "/changelog/#v3171", 
            "text": "Fix #97. Moshi does not fail when deserialise non-nullable fields correctly. Note that GSON still suffers from this problem", 
            "title": "v3.17.1"
        }, 
        {
            "location": "/changelog/#v3170", 
            "text": "Added a pre-security filter option to contract creation, so that you can explicitly specify behaviour to occur before security kicks in.", 
            "title": "v3.17.0"
        }, 
        {
            "location": "/changelog/#v3160", 
            "text": "Convert  Security  (from sealed class) and  ApiKey  to be interfaces. This allows users to implement their own security models.", 
            "title": "v3.16.0"
        }, 
        {
            "location": "/changelog/#v3150", 
            "text": "Introduce  HttpTransaction  and new  ReportHttpTransaction  filter provide better generic API for reporting, along with the ability to label transactions for this purpose.  Breaking: Rework the metrics request counter and timer Filter API. There is now a  HttpTransactionLabeller  for you to add as many labels as required to the transaction. Each of these labels will be used to tag the metric.", 
            "title": "v3.15.0"
        }, 
        {
            "location": "/changelog/#v3141", 
            "text": "Fix #95 - Filters are now applied to \"route not found\" responses", 
            "title": "v3.14.1"
        }, 
        {
            "location": "/changelog/#v3140", 
            "text": "Fix #93 - Apache server doesn't like content-length or transfer-encoding headers present in http4k response.  Add ability to \"name\" input and output contract body definitions in an OpenAPI JSON doc. This applies to only the top level entity. If no override is passed, the objects are named according to their hashcode.", 
            "title": "v3.14.0"
        }, 
        {
            "location": "/changelog/#3134", 
            "text": "Fix #92 - cookie date should always use US locale", 
            "title": "3.13.4"
        }, 
        {
            "location": "/changelog/#v3133", 
            "text": "Further tweak to Netty. H/T @FredDeschenes", 
            "title": "v3.13.3"
        }, 
        {
            "location": "/changelog/#v3132", 
            "text": "Fix #91 - large message handli\nng in Netty", 
            "title": "v3.13.2"
        }, 
        {
            "location": "/changelog/#v3131", 
            "text": "Upgrade to Kotlin 1.2.20", 
            "title": "v3.13.1"
        }, 
        {
            "location": "/changelog/#v3130", 
            "text": "Support for  operationId  in OpenApi route metadata. H/T @danschultz for the PR.  Removed previously deprecated methods.", 
            "title": "v3.13.0"
        }, 
        {
            "location": "/changelog/#v3120", 
            "text": "New client module  http4k-client-jetty , which supports both sync and async models.", 
            "title": "v3.12.0"
        }, 
        {
            "location": "/changelog/#v3111", 
            "text": "Fix #84. OPTIONS requests are not detected by contract routes.  Added option to NOT authorise OPTIONS requests in ApiKey security filter.  Added support for Async HTTP clients and added new  AsyncHttpClient  interface, which is obviously used for HTTP clients only**, and not server-side calls. :)  New client module  http4k-client-apache-async .  New metrics gathering module  http4k-metrics-micrometer . Big H/T to @kirderf for the PR.  Added support for async to  OkHttp  client module.", 
            "title": "v3.11.1"
        }, 
        {
            "location": "/changelog/#v3100", 
            "text": "P/R 81 - adding headers and timeout to websocket client.", 
            "title": "v3.10.0"
        }, 
        {
            "location": "/changelog/#v390", 
            "text": "Added compactify and prettify to Json implementations  Added  Json.hasBody  Hamkrest matchers for comparing bodies. Note these are extension methods and need to be referenced/imported as such.", 
            "title": "v3.9.0"
        }, 
        {
            "location": "/changelog/#v380", 
            "text": "Added facility for non-blocking websocket client to react to onConnect event. This API is\nthe same as the inbound, server-side API - ie. there are no explicit connection event handlers. H/T @tom for the idea.", 
            "title": "v3.8.0"
        }, 
        {
            "location": "/changelog/#v370", 
            "text": "P/R #13 Create extension methods for Response to add caching headers. H/T @k0zakinio.", 
            "title": "v3.7.0"
        }, 
        {
            "location": "/changelog/#v361", 
            "text": "Fix #78. Serialisation of raw lists using Moshi fails in the same way as the Jackson auto-conversions do. Added convenience methods to get around this.", 
            "title": "v3.6.1"
        }, 
        {
            "location": "/changelog/#v360", 
            "text": "Added  http4k-format-moshi  to support the Square auto-marshalling library.", 
            "title": "v3.6.0"
        }, 
        {
            "location": "/changelog/#v351", 
            "text": "Fix #76 - encoding of path segments to use URI encoding instead of URL form encoding.", 
            "title": "v3.5.1"
        }, 
        {
            "location": "/changelog/#v350", 
            "text": "Added support for multiple HotReload template directories in  HandlebarsTemplates . H/T @TomShacham  Fix #74 - Request tracing span/parentSpan set too early so was shared between outgoing requests.", 
            "title": "v3.5.0"
        }, 
        {
            "location": "/changelog/#v340", 
            "text": "New server backend  http4k-server-apache . H/T @kirderf for the PR :)  We now set the length of the incoming request body when it is available in the incoming request.", 
            "title": "v3.4.0"
        }, 
        {
            "location": "/changelog/#v331", 
            "text": "Handlebars now uses combination of Class and Template name to cache templates.", 
            "title": "v3.3.1"
        }, 
        {
            "location": "/changelog/#v330", 
            "text": "Facility to compose  TemplateRenderers  with  then()  to provide fallback behaviour.", 
            "title": "v3.3.0"
        }, 
        {
            "location": "/changelog/#v323", 
            "text": "PR #70: Header order equality for Request/Response - H/T @gypsydave5.", 
            "title": "v3.2.3"
        }, 
        {
            "location": "/changelog/#v322", 
            "text": "Switched out  Status  for  WsStatus  (with proper RFC code set) in Websockets.", 
            "title": "v3.2.2"
        }, 
        {
            "location": "/changelog/#v321", 
            "text": "Typesafe Websockets! Jetty now supports websockets, using the same style of API in the main http4k routing.  (Possible) Breaking change: Because  WsHandler  (typealias) implements the same inbound interface as  HttpHandler , you now cannot declare  HttpHandlers  without specifying the input type, so any \"anonymous\" handlers will not compile as a result. The required fix is very simple, but manual:\n `{ Response(OK) } should become { _:Request -  Response(OK) }", 
            "title": "v3.2.1"
        }, 
        {
            "location": "/changelog/#v313", 
            "text": "Fix Request.form() for streaming requests", 
            "title": "v3.1.3"
        }, 
        {
            "location": "/changelog/#v312", 
            "text": "Remove possibility of empty message for Path Lens failure.", 
            "title": "v3.1.2"
        }, 
        {
            "location": "/changelog/#v311", 
            "text": "New (better!) API for  http4k-contract  module. Old meta DSL has been deprecated.", 
            "title": "v3.1.1"
        }, 
        {
            "location": "/changelog/#v301", 
            "text": "Fix #63 - Apache Client Connect. timeout exception handling.", 
            "title": "v3.0.1"
        }, 
        {
            "location": "/changelog/#v300", 
            "text": "Added  http4k-serverless-lambda  module, allowing http4k applications to be deployed into AWS Lambda and then called from API Gateway. Effectively, the combination of these two services become just another Server back-end supported by the library. \\o/", 
            "title": "v3.0.0"
        }, 
        {
            "location": "/changelog/#v2381", 
            "text": "RequestContextKey  now follow the standardised Lens structure of required, optional, defaulted, and can now be removed (set to null). Replace calls\nto  RequestContextKey.of()  with  RequestContextKey.required()    Removed previously deprecated values. See below for details on replacements.", 
            "title": "v2.38.1"
        }, 
        {
            "location": "/changelog/#v2370", 
            "text": "Added  http4k-resilience4j  module, which adds Circuits, RateLimiters, Retrying and Bulkheading.  Fix #60 (H/T @michaelhixson for the spot).", 
            "title": "v2.37.0"
        }, 
        {
            "location": "/changelog/#v2360", 
            "text": "Added a couple of useful  ServerFilters .  Upgrade various dependency versions.  Tidying of Multipart code.", 
            "title": "v2.36.0"
        }, 
        {
            "location": "/changelog/#v2351", 
            "text": "Fix #57. Static handlers behave oddly when combined with an HTTP verb in the routing tree.", 
            "title": "v2.35.1"
        }, 
        {
            "location": "/changelog/#v2350", 
            "text": "Fix #56. Altered behaviour of  CatchLensFailure  to NOT catch errors from unmarshalling Response objects. This was causing BAD_REQUEST to be incorrectly generated.  Simplification of generics around LensSpecs. This should not be a breaking change, (there were 3 generics, now the MID has been removed so there are just 2) but could break if signatures are used explicitly.", 
            "title": "v2.35.0"
        }, 
        {
            "location": "/changelog/#v2340", 
            "text": "Reordered generics in LensInjector to make sense. This should have no effect on most code-bases, but could break if signatures are used explicitly. Just flip the generic types to switch.", 
            "title": "v2.34.0"
        }, 
        {
            "location": "/changelog/#v2331", 
            "text": "Added support for unsigned AWS requests, which enables streaming content to S3.", 
            "title": "v2.33.1"
        }, 
        {
            "location": "/changelog/#v2330", 
            "text": "Added  BodyMode.Request  to configure streaming for clients.  ResponseBodyMode  is now  BodyMode.Response  (Breaking change. Fixable with simple find/replace).", 
            "title": "v2.33.0"
        }, 
        {
            "location": "/changelog/#v2320", 
            "text": "Added  ServerFilter.ProcessFiles  filter to stream Multipart Files, convert them into references and replace inline in the Form.", 
            "title": "v2.32.0"
        }, 
        {
            "location": "/changelog/#v2314", 
            "text": "Avoid realising StreamBody unless necessary, which could break common usages of streaming.", 
            "title": "v2.31.4"
        }, 
        {
            "location": "/changelog/#v2313", 
            "text": "Tweaks to Server backends to improve efficiency.", 
            "title": "v2.31.3"
        }, 
        {
            "location": "/changelog/#v2312", 
            "text": "Webdriver will keep only the final URI after redirects.", 
            "title": "v2.31.2"
        }, 
        {
            "location": "/changelog/#v2311", 
            "text": "Increased granularity of  Replay.DiskStream  and ensure that traffic is returned in exact order on all OSes.  Add support for redirects to Webdriver.", 
            "title": "v2.31.1"
        }, 
        {
            "location": "/changelog/#v2310", 
            "text": "Multipart module tweaked to provide a more consistent API.  Fix FollowRedirects for POST/PUT request.", 
            "title": "v2.31.0"
        }, 
        {
            "location": "/changelog/#v2300", 
            "text": "Multipart form support through new module  http4k-multipart .  Deprecation: Replaced  Swagger  with  OpenApi  and deprecated the former (via typealias).  Deprecation: Replaced  FormValidator  with  Validator  and deprecated the former (via typealias).", 
            "title": "v2.30.0"
        }, 
        {
            "location": "/changelog/#v2294", 
            "text": "Refactor release.", 
            "title": "v2.29.4"
        }, 
        {
            "location": "/changelog/#v2293", 
            "text": "Fix #50 - Webdriver does not normalise relative links correctly.", 
            "title": "v2.29.3"
        }, 
        {
            "location": "/changelog/#v2292", 
            "text": "Http client modules now catch and convert Socket Timeout exceptions to HTTP 504s (with a custom message)", 
            "title": "v2.29.2"
        }, 
        {
            "location": "/changelog/#v2291", 
            "text": "Tweaks to how recorded traffic is stored on disk. Thanks to @dkandalov for the PR around this.", 
            "title": "v2.29.1"
        }, 
        {
            "location": "/changelog/#v2290", 
            "text": "Added  TrafficFilters  for recording and replaying HTTP traffic. See  org.http4k.traffic  package for details.", 
            "title": "v2.29.0"
        }, 
        {
            "location": "/changelog/#v2280", 
            "text": "Added  http4k-template-dust  for Dust template engine support. Thanks to @npryce for the PR to add this.", 
            "title": "v2.28.0"
        }, 
        {
            "location": "/changelog/#v2272", 
            "text": "Fix #44 - Use quotes around cookie values", 
            "title": "v2.27.2"
        }, 
        {
            "location": "/changelog/#v2271", 
            "text": "Raise proper Exception (instead of LensFailure) when RequestContexts are not set up correctly, so we don't accidentally classify developer errors as BadRequests", 
            "title": "v2.27.1"
        }, 
        {
            "location": "/changelog/#v2270", 
            "text": "Added facility to assign values into a  RequestContext  which is passed down the Filter chain.", 
            "title": "v2.27.0"
        }, 
        {
            "location": "/changelog/#v2263", 
            "text": "Fix #44 - Request cookies should not be wrapped in quotes.", 
            "title": "v2.26.3"
        }, 
        {
            "location": "/changelog/#v2262", 
            "text": "Fix #43 - AWS does not sign binary requests correctly.", 
            "title": "v2.26.2"
        }, 
        {
            "location": "/changelog/#v2261", 
            "text": "Fix #41 - Sending binary body alters the size of the payload.", 
            "title": "v2.26.1"
        }, 
        {
            "location": "/changelog/#v2260", 
            "text": "Added \"catch all\" routing option, which matches all methods to a handler.", 
            "title": "v2.26.0"
        }, 
        {
            "location": "/changelog/#v2254", 
            "text": "Fix #40 - GZip filters now use content-encoding headers instead of transfer-encoding.", 
            "title": "v2.25.4"
        }, 
        {
            "location": "/changelog/#v2253", 
            "text": "Fix #39 - ResponseBodyMode.Memory properly closes streams (breaks jetty + gzip).", 
            "title": "v2.25.3"
        }, 
        {
            "location": "/changelog/#v2252", 
            "text": "Ensure that streams are closed properly when consuming from an upstream client.", 
            "title": "v2.25.2"
        }, 
        {
            "location": "/changelog/#v2251", 
            "text": "Remove Apache client request streaming because it may not release connections properly.", 
            "title": "v2.25.1"
        }, 
        {
            "location": "/changelog/#v2250", 
            "text": "Add streaming support to HTTP Server and Client modules.  Remove CatchLensFailure ClientFilter as it will never be used.", 
            "title": "v2.25.0"
        }, 
        {
            "location": "/changelog/#v2240", 
            "text": "Added CatchLensFailure for ClientFilters - which catches un-deserializable invalid responses from clients and generates a BAD_GATEWAY error.", 
            "title": "v2.24.0"
        }, 
        {
            "location": "/changelog/#v2234", 
            "text": "Switch XML generation to Gson over Jackson because Jackson doesn't handle uppercase field names well.  Switch native XML parsed type to Document over Node.", 
            "title": "v2.23.4"
        }, 
        {
            "location": "/changelog/#v2233", 
            "text": "New algorithm for XML data class deserialisation, so un-deprecated XML methods.", 
            "title": "v2.23.3"
        }, 
        {
            "location": "/changelog/#v2232", 
            "text": "Deprecated methods in XML support due to limitation with underlying Jackson implementation.", 
            "title": "v2.23.2"
        }, 
        {
            "location": "/changelog/#v2231", 
            "text": "Fixed bug with GenerateXmlDataClasses filter", 
            "title": "v2.23.1"
        }, 
        {
            "location": "/changelog/#v2230", 
            "text": "Renamed  http4k-format-jackson-xml  module to  http4k-format-xml .  Improved XML unmarshalling support.", 
            "title": "v2.23.0"
        }, 
        {
            "location": "/changelog/#v2221", 
            "text": "Fixed 36: Form entry is too strict with content encoding.", 
            "title": "v2.22.1"
        }, 
        {
            "location": "/changelog/#v2220", 
            "text": "Added  http4k-format-jackson-xml  module, with XML parsing support.  Upgrade several dependencies", 
            "title": "v2.22.0"
        }, 
        {
            "location": "/changelog/#v2212", 
            "text": "Fixed Hamkrest matchers to be on HttpMessage and not Http Request.", 
            "title": "v2.21.2"
        }, 
        {
            "location": "/changelog/#v2211", 
            "text": "Default body Content Negotiation strategy changed to None", 
            "title": "v2.21.1"
        }, 
        {
            "location": "/changelog/#v2210", 
            "text": "Converted Content-Negotiation strategy from an Enum to an interface, so that users can define their own strategies. We also now check encoding so there are 4-built in strategies to choose from: Strict, StrictNoDirective, NonStrict and None.", 
            "title": "v2.21.0"
        }, 
        {
            "location": "/changelog/#v2201", 
            "text": "Fixed #31 - Matching of segments in URIs is done after URLs are decoded, which results in not capturing encoded slashes in the path segments.", 
            "title": "v2.20.1"
        }, 
        {
            "location": "/changelog/#v2200", 
            "text": "Fixed #30 - CachingClasspath template ResourceLoader not working with non-root packages.", 
            "title": "v2.20.0"
        }, 
        {
            "location": "/changelog/#v2190", 
            "text": "Fixed #29 - webdriver submission of text area.  Http clients now use a new instance of the default for each instantiation. Previously there was a shared instance.  Add regex body type for parsing values out of bodies, and \"None\" option for content negotiation.", 
            "title": "v2.19.0"
        }, 
        {
            "location": "/changelog/#v2183", 
            "text": "Fix AWS request signing for requests containing empty path", 
            "title": "v2.18.3"
        }, 
        {
            "location": "/changelog/#v2182", 
            "text": "Fix AWS request signing for requests containing path with special characters", 
            "title": "v2.18.2"
        }, 
        {
            "location": "/changelog/#v2181", 
            "text": "Added support for newRequest() in new  RouteBinder  mechanic.", 
            "title": "v2.18.1"
        }, 
        {
            "location": "/changelog/#v2180", 
            "text": "Add support for unlimited nesting for  routes()  blocks. Removed the raw  Route  object, which can be replaced with  Router  or  RoutingHttpHandler  where appropriate.  As part of above, rejigged route setup logic. Deprecated old routing structure, so now   \"/path\" to GET bind  is  \"/path\" bind GET to . To fix deprecation, simply switch the calls to \"to\" and \"bind\" in routing setup.   Rename of  bind()  in  http4k-contract  to be  bindContract()", 
            "title": "v2.18.0"
        }, 
        {
            "location": "/changelog/#v2172", 
            "text": "Added missing eclectic HTTP method. :)", 
            "title": "v2.17.2"
        }, 
        {
            "location": "/changelog/#v2171", 
            "text": "Added GZip filters to  http4k-core  to zip request and response bodies.", 
            "title": "v2.17.1"
        }, 
        {
            "location": "/changelog/#v2161", 
            "text": "Improved messages for  http4k-testing-hamkrest  matchers.", 
            "title": "v2.16.1"
        }, 
        {
            "location": "/changelog/#v2160", 
            "text": "Added  http4k-testing-hamkrest  which contains a set of Hamkrest matchers for Http4k objects.", 
            "title": "v2.16.0"
        }, 
        {
            "location": "/changelog/#v2150", 
            "text": "More features for  http4k-testing-webdriver . Cookie support added.", 
            "title": "v2.15.0"
        }, 
        {
            "location": "/changelog/#v2140", 
            "text": "More features for  http4k-testing-webdriver . We now support Form entry and submission.", 
            "title": "v2.14.0"
        }, 
        {
            "location": "/changelog/#v2130", 
            "text": "More features for  http4k-testing-webdriver .", 
            "title": "v2.13.0"
        }, 
        {
            "location": "/changelog/#v2120", 
            "text": "Added  http4k-testing-webdriver  module, an ultralight Selenium WebDriver for  http4k  apps", 
            "title": "v2.12.0"
        }, 
        {
            "location": "/changelog/#v2113", 
            "text": "Fix #26 - GenerateDataClasses does not recurse into nested object trees", 
            "title": "v2.11.3"
        }, 
        {
            "location": "/changelog/#v2112", 
            "text": "Fix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with  then(RoutingHttpHandler()", 
            "title": "v2.11.2"
        }, 
        {
            "location": "/changelog/#v2111", 
            "text": "Fix static routes not defaulting to index.html when in root context", 
            "title": "v2.11.1"
        }, 
        {
            "location": "/changelog/#v2110", 
            "text": "Added  SunHttp  server implementation (for development use only)", 
            "title": "v2.11.0"
        }, 
        {
            "location": "/changelog/#v2101", 
            "text": "Fix cookie parsing when value contains '='", 
            "title": "v2.10.1"
        }, 
        {
            "location": "/changelog/#v2100", 
            "text": "Add method to set form values in the request", 
            "title": "v2.10.0"
        }, 
        {
            "location": "/changelog/#v290", 
            "text": "Added PURGE HTTP method as it's used commonly by various caches.", 
            "title": "v2.9.0"
        }, 
        {
            "location": "/changelog/#v281", 
            "text": "Repackage AWS classes for consistency with rest of project", 
            "title": "v2.8.1"
        }, 
        {
            "location": "/changelog/#v271", 
            "text": "Alter AWS Auth filter creation. Now use  ClientFilters.AwsAuth", 
            "title": "v2.7.1"
        }, 
        {
            "location": "/changelog/#v270", 
            "text": "Add AWS module", 
            "title": "v2.7.0"
        }, 
        {
            "location": "/changelog/#v260", 
            "text": "Newly created Zipkin traces are now populated onto incoming request in ServerFilters.", 
            "title": "v2.6.0"
        }, 
        {
            "location": "/changelog/#v251", 
            "text": "Slight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling", 
            "title": "v2.5.1"
        }, 
        {
            "location": "/changelog/#v250", 
            "text": "Add  Thymeleaf  templating support", 
            "title": "v2.5.0"
        }, 
        {
            "location": "/changelog/#v240", 
            "text": "Add  Pebble  templating support", 
            "title": "v2.4.0"
        }, 
        {
            "location": "/changelog/#v230", 
            "text": "Make Route a Router so we can nest them together.", 
            "title": "v2.3.0"
        }, 
        {
            "location": "/changelog/#v221", 
            "text": "Remove excess \"charset\" from headers in Undertow.", 
            "title": "v2.2.1"
        }, 
        {
            "location": "/changelog/#v220", 
            "text": "Rename   by()  to  bind()  in routing for clarity.", 
            "title": "v2.2.0"
        }, 
        {
            "location": "/changelog/#v212", 
            "text": "Fix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex.", 
            "title": "v2.1.2"
        }, 
        {
            "location": "/changelog/#v210", 
            "text": "Added GSON full-auto functions to convert arbitary objects to/from JSON.", 
            "title": "v2.1.0"
        }, 
        {
            "location": "/changelog/#v205", 
            "text": "Fix #23. Contract now supports multi-part URL params (for hardcoded parts)", 
            "title": "v2.0.5"
        }, 
        {
            "location": "/changelog/#v204", 
            "text": "Fix #22. Uri template does not parse out correct path params when URL starts with a path part.", 
            "title": "v2.0.4"
        }, 
        {
            "location": "/changelog/#v203", 
            "text": "toString() implementations to aid debugging", 
            "title": "v2.0.3"
        }, 
        {
            "location": "/changelog/#v201", 
            "text": "Readded missing default parameter for  newRequest()  on RouteSpec", 
            "title": "v2.0.1"
        }, 
        {
            "location": "/changelog/#v200", 
            "text": "Breaking: Inversion of routing API.  GET to \"/someUri\"  is now  \"/someUri\" to GET  for consistency across the entire API.", 
            "title": "v2.0.0"
        }, 
        {
            "location": "/changelog/#v1331", 
            "text": "Reimplementation of  http4k-contract  API to match main routing API. Contracts are now nestable.", 
            "title": "v1.33.1"
        }, 
        {
            "location": "/changelog/#v1322", 
            "text": "Fix Filters being applied twice in  ContractRoutingHttpHandler", 
            "title": "v1.32.2"
        }, 
        {
            "location": "/changelog/#v1321", 
            "text": "More work on  http4k-contract  contract API", 
            "title": "v1.32.1"
        }, 
        {
            "location": "/changelog/#v1310", 
            "text": "Rework  http4k-contract  routing to be mounted in the same way as other  RoutingHttpHandlers", 
            "title": "v1.31.0"
        }, 
        {
            "location": "/changelog/#v1300", 
            "text": "Filters are now applied consistently to all Routers", 
            "title": "v1.30.0"
        }, 
        {
            "location": "/changelog/#v1290", 
            "text": "Tweak to DSL for defining StaticRouters", 
            "title": "v1.29.0"
        }, 
        {
            "location": "/changelog/#v1281", 
            "text": "Fix for #18: FollowRedirect will now work if location header includes charset information.", 
            "title": "v1.28.1"
        }, 
        {
            "location": "/changelog/#v1280", 
            "text": "New DSL for defining StaticRouters", 
            "title": "v1.28.0"
        }, 
        {
            "location": "/changelog/#v1270", 
            "text": "Merged StaticContent and StaticRouter and repackage of contract API into other packages", 
            "title": "v1.27.0"
        }, 
        {
            "location": "/changelog/#v1262", 
            "text": "Extend fix for #17 to request  Cookie  header.", 
            "title": "v1.26.2"
        }, 
        {
            "location": "/changelog/#v1261", 
            "text": "Fix for #17. Cookie can now parse a cookie without attributes and ending in semicolon.", 
            "title": "v1.26.1"
        }, 
        {
            "location": "/changelog/#v1260", 
            "text": "Added nestable Routers.  Merging of Modules and Routers.  Router  is the new  Module !  RouteModule  is now  ContractRouter , so rename in code will be required.", 
            "title": "v1.26.0"
        }, 
        {
            "location": "/changelog/#v1251", 
            "text": "Fix for #15. OkHttp client handling of POSTs with no body.", 
            "title": "v1.25.1"
        }, 
        {
            "location": "/changelog/#v1250", 
            "text": "Can add custom mime types to Static Content  GenerateDataClasses is capable of more complex object graphs", 
            "title": "v1.25.0"
        }, 
        {
            "location": "/changelog/#v1240", 
            "text": "Remove  HttpHandler.asServer  in favour of  HttpHandler.startServer  to avoid confusion.  Introduce  Status.description() .", 
            "title": "v1.24.0"
        }, 
        {
            "location": "/changelog/#v1230", 
            "text": "Netty sets content-length header.", 
            "title": "v1.23.0"
        }, 
        {
            "location": "/changelog/#v1222", 
            "text": "Fix for #12. Undertow not constructing response correctly.", 
            "title": "v1.22.2"
        }, 
        {
            "location": "/changelog/#v1220", 
            "text": "New module with Undertow.io support  http4k-server-undertow  Jackson implementation now ignores unknown properties in incoming messages  Netty implementation tidied up", 
            "title": "v1.22.0"
        }, 
        {
            "location": "/changelog/#v1211", 
            "text": "Fix for #11. Netty implementation returns incorrect status codes.", 
            "title": "v1.21.1"
        }, 
        {
            "location": "/changelog/#v1210", 
            "text": "Add synonym methods for Lenses to aid readability. We now have  invoke(IN)/extract(IN)  and `invoke(IN, TARGET)/inject(IN, TARGET)", 
            "title": "v1.21.0"
        }, 
        {
            "location": "/changelog/#v1200", 
            "text": "http4k-contracts : Add option to change the route of the module description route", 
            "title": "v1.20.0"
        }, 
        {
            "location": "/changelog/#v1191", 
            "text": "http4k-contracts : Fix for contract module description routes not being authenticated via security filter", 
            "title": "v1.19.1"
        }, 
        {
            "location": "/changelog/#v1190", 
            "text": "http4k-contracts : Add  Swagger  module rendering with JSON schema models for messages.", 
            "title": "v1.19.0"
        }, 
        {
            "location": "/changelog/#v1180", 
            "text": "Add  nonEmptyString()  lens type to all request parts.", 
            "title": "v1.18.0"
        }, 
        {
            "location": "/changelog/#v1170", 
            "text": "General rework", 
            "title": "v1.17.0"
        }, 
        {
            "location": "/changelog/#v1160", 
            "text": "Further work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios.", 
            "title": "v1.16.0"
        }, 
        {
            "location": "/changelog/#v1150", 
            "text": "Path lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc.  Routes can now create shell Requests for themselves, using  route.newRequest()", 
            "title": "v1.15.0"
        }, 
        {
            "location": "/changelog/#v1140", 
            "text": "Body is now non-nullable (use  Body.EMPTY  instead)  Rename methods  BodyLens  API for consistency and clarity.  required()  is now  toLens() .  to()' binding method is now of().", 
            "title": "v1.14.0"
        }, 
        {
            "location": "/changelog/#v1130", 
            "text": "New client module:  http4k-client-okhttp", 
            "title": "v1.13.0"
        }, 
        {
            "location": "/changelog/#v1120", 
            "text": "Tidying", 
            "title": "v1.12.0"
        }, 
        {
            "location": "/changelog/#v1110", 
            "text": "Added option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :)", 
            "title": "v1.11.0"
        }, 
        {
            "location": "/changelog/#v1100", 
            "text": "Moved  Credentials  to  org.http4k.core  package.  Add various filters, including  SetHostFrom  and  CatchAll .", 
            "title": "v1.10.0"
        }, 
        {
            "location": "/changelog/#v190", 
            "text": "Added  GenerateDataClasses  so you can generate Kotlin data classes from JSON messages.", 
            "title": "v1.9.0"
        }, 
        {
            "location": "/changelog/#v180", 
            "text": "Added CORs support", 
            "title": "v1.8.0"
        }, 
        {
            "location": "/changelog/#v170", 
            "text": "Added auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses", 
            "title": "v1.7.0"
        }, 
        {
            "location": "/changelog/#v160", 
            "text": "Added CachingFilters", 
            "title": "v1.6.0"
        }, 
        {
            "location": "/changelog/#v150", 
            "text": "Removed static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions.  Merge  org.http4k.core.Body  and  org.http4k.lens.Body .  Add Request/Response message parsers.", 
            "title": "v1.5.0"
        }, 
        {
            "location": "/changelog/#v140", 
            "text": "Turn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected.", 
            "title": "v1.4.0"
        }, 
        {
            "location": "/changelog/#v130", 
            "text": "Removed non-mandatory parameters from Request and Response constructors. This is aid API clarity.\nand force users to use the API methods for properly constructing the objects.  Regex Lens added.", 
            "title": "v1.3.0"
        }, 
        {
            "location": "/changelog/#v100", 
            "text": "Initial major release.", 
            "title": "v1.0.0"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributers' Guide\n\n\n\nThere are many ways in which you can contribute to the development of the library:\n\n\n\n\nGive us a Star on Github - you know you want to ;)\n\n\nQuestions can be directed towards the Gitter channel, or on Twitter \n@http4k\n\n\nFor issues, please describe giving as much detail as you can - including version and steps to recreate\n\n\n\n\npull requests\n\n\nIf there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR. \n\n\n\n\nJSON formats: create a new module with an implementation of \nJson\n by following the \nArgo\n example in the source.\n\n\nTemplating engines: create a new module with a \nTemplates\nimplementation by following the \nHandlebarsTemplates\n example in the source\n\n\n\n\ngeneral guidelines\n\n\n\n\nAt the moment, PRs should be sent to the master branch - this might change in future so check back everytime!\n\n\nSource/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions\n\n\nPR changes should have test coverage\n\n\nAll the PRs must pass the Travis CI jobs before merging them\n\n\n\n\nhttps://travis-ci.org/http4k/http4k\n\n\nTesting with default settings is required when push changes:\n\n\nsh\n./gradlew check\n\n\nFinancial contributions\n\n\nWe also welcome financial contributions in full transparency on our \nopen collective\n.\nAnyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.\n\n\nCredits\n\n\nContributors\n\n\nThank you to all the people who have already contributed to http4k!\n\n\n\nBackers\n\n\nThank you to all our backers! [\nBecome a backer\n]\n\n\n\n\nSponsors\n\n\nThank you to all our sponsors! (please ask your company to also support this open source project by \nbecoming a sponsor\n)", 
            "title": "Contribute/Support http4k"
        }, 
        {
            "location": "/contributing/#pull-requests", 
            "text": "If there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR.    JSON formats: create a new module with an implementation of  Json  by following the  Argo  example in the source.  Templating engines: create a new module with a  Templates implementation by following the  HandlebarsTemplates  example in the source", 
            "title": "pull requests"
        }, 
        {
            "location": "/contributing/#general-guidelines", 
            "text": "At the moment, PRs should be sent to the master branch - this might change in future so check back everytime!  Source/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions  PR changes should have test coverage  All the PRs must pass the Travis CI jobs before merging them   https://travis-ci.org/http4k/http4k  Testing with default settings is required when push changes:  sh\n./gradlew check", 
            "title": "general guidelines"
        }, 
        {
            "location": "/contributing/#financial-contributions", 
            "text": "We also welcome financial contributions in full transparency on our  open collective .\nAnyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.", 
            "title": "Financial contributions"
        }, 
        {
            "location": "/contributing/#credits", 
            "text": "", 
            "title": "Credits"
        }, 
        {
            "location": "/contributing/#contributors", 
            "text": "Thank you to all the people who have already contributed to http4k!", 
            "title": "Contributors"
        }, 
        {
            "location": "/contributing/#backers", 
            "text": "Thank you to all our backers! [ Become a backer ]", 
            "title": "Backers"
        }, 
        {
            "location": "/contributing/#sponsors", 
            "text": "Thank you to all our sponsors! (please ask your company to also support this open source project by  becoming a sponsor )", 
            "title": "Sponsors"
        }, 
        {
            "location": "/api/", 
            "text": "", 
            "title": "API docs"
        }, 
        {
            "location": "/faq/", 
            "text": "Find here answers to the most common questions that we get asked about \nhttp4k\n\n\nGeneral\n\n\nQ. Is http4k a library or a framework?\n\n\nA.\n Although it has many of the features of a framework, we consider http4k to be a library which adds a common HTTP routing layer. Is it incredibly unopinionated and has been designed to not enforce design decisions on the API user. We use http4k for applications both large and small, using no DI framework.\n\n\nQ. Is http4k currently used in production?\n\n\nA.\n Absolutely! The library is currently in use serving the global traffic for a large academic publisher (easily serving 10s of millions of requests per day on a few nodes) and is also being used in production in at least 2 global Investment Banks (that we know of). If you're running http4k in production and would like to be listed on the site as an adopter, please get in touch.\n\n\nQ. Does http4k support an Async model? I need webscale!\n\n\nA.\n Not at the moment. Adding Async support is a decision that we are thinking about carefully so that we don't end up complicating the API. When we do add it, it'll probably use co-routines and they're still marked as experimental which is another reason we are holding off. As for the scaling arguments, see the above answer relating to production usage.\n\n\nAPI\n\n\nQ. I'm attempting to build HTTP messages using the API, but changes don't affect the object (e.g. calling \nrequest.body(\"hello\")\n)?\n\n\nA.\n \nhttp4k\n HTTP message objects are \nimmutable\n, so you need to chain or reassign the value from the method call to get the updated version.\n\n\nQ. Where are all the useful Filters defined?\n\n\nA.\n Filters are all in the \nimport org.http4k.filter\n package and are located as methods on a singleton \nobject\n relevant to their use:\n\n\n\n\norg.http4k.filter.CachingFilters.Request\n \n \norg.http4k.filter.CachingFilters.Response\n \n\n\norg.http4k.filter.ClientFilters\n\n\norg.http4k.filter.DebuggingFilters\n\n\norg.http4k.filter.ServerFilters\n \n\n\norg.http4k.filter.TrafficFilters\n\n\n\n\nLenses \n Auto-Marshalling\n\n\nQ. Where is the \nBody.auto\n method defined?\n\n\nA.\n \nBody.auto\n is an extension method which is declared on the parent singleton \nobject\n for each of the message libraries that supports auto-marshalling - eg. \nJackson\n, \nGson\n, \nMoshi\n and \nXml\n. All of these objects are declared in the same package, so you need to add an import similar to:\n\nimport org.http4k.format.Jackson.auto\n\n\nQ. Declared with \nBody.auto\nList\nXXX\n().toLens()\n, my auto-marshalled List doesn't extract properly!\n\n\nA.\n This occurs in Jackson and Moshi when serialising bare lists to/from JSON and is to do with the underlying library being lazy in deserialising objects (using LinkedHashTreeMap) ()). Use \nBody.auto\nArray\nMyIntWrapper\n().toLens()\n instead. Yes, it's annoying but we haven't found a way to turn if off.\n\n\nQ. Using Jackson, the Data class auto-marshalling is not working correctly when my JSON fields start with capital letters\n\n\nA.\n Because of the way in which the Jackson library works, uppercase field names are NOT supported. Either switch out to use \nhttp4k-format-gson\n (which has the same API), or annotate your Data class fields with \n@JsonAlias\n to get the deserialisation to work correctly.\n\n\nQ. Using Gson, the data class auto-marshalling does not fail when a null is populated in a Kotlin non-nullable field\n\n\nA.\n This happens because http4k uses straight GSON demarshalling, of JVM objects with no-Kotlin library in the mix. The nullability generally gets checked at compile-type and the lack of a Kotlin sanity check library exposes this flaw. No current fix - apart from to use the Jackson demarshalling instead!\n\n\nQ. My application uses Lenses, but when they fail I get an HTTP 500 instead of the promised 400.\n\n\nA.\n You forgot to add the \nServerFilters.CatchLensFailure\n filter to your Server stack.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#general", 
            "text": "Q. Is http4k a library or a framework?  A.  Although it has many of the features of a framework, we consider http4k to be a library which adds a common HTTP routing layer. Is it incredibly unopinionated and has been designed to not enforce design decisions on the API user. We use http4k for applications both large and small, using no DI framework.  Q. Is http4k currently used in production?  A.  Absolutely! The library is currently in use serving the global traffic for a large academic publisher (easily serving 10s of millions of requests per day on a few nodes) and is also being used in production in at least 2 global Investment Banks (that we know of). If you're running http4k in production and would like to be listed on the site as an adopter, please get in touch.  Q. Does http4k support an Async model? I need webscale!  A.  Not at the moment. Adding Async support is a decision that we are thinking about carefully so that we don't end up complicating the API. When we do add it, it'll probably use co-routines and they're still marked as experimental which is another reason we are holding off. As for the scaling arguments, see the above answer relating to production usage.", 
            "title": "General"
        }, 
        {
            "location": "/faq/#api", 
            "text": "Q. I'm attempting to build HTTP messages using the API, but changes don't affect the object (e.g. calling  request.body(\"hello\") )?  A.   http4k  HTTP message objects are  immutable , so you need to chain or reassign the value from the method call to get the updated version.  Q. Where are all the useful Filters defined?  A.  Filters are all in the  import org.http4k.filter  package and are located as methods on a singleton  object  relevant to their use:   org.http4k.filter.CachingFilters.Request     org.http4k.filter.CachingFilters.Response    org.http4k.filter.ClientFilters  org.http4k.filter.DebuggingFilters  org.http4k.filter.ServerFilters    org.http4k.filter.TrafficFilters", 
            "title": "API"
        }, 
        {
            "location": "/faq/#lenses-auto-marshalling", 
            "text": "Q. Where is the  Body.auto  method defined?  A.   Body.auto  is an extension method which is declared on the parent singleton  object  for each of the message libraries that supports auto-marshalling - eg.  Jackson ,  Gson ,  Moshi  and  Xml . All of these objects are declared in the same package, so you need to add an import similar to: import org.http4k.format.Jackson.auto  Q. Declared with  Body.auto List XXX ().toLens() , my auto-marshalled List doesn't extract properly!  A.  This occurs in Jackson and Moshi when serialising bare lists to/from JSON and is to do with the underlying library being lazy in deserialising objects (using LinkedHashTreeMap) ()). Use  Body.auto Array MyIntWrapper ().toLens()  instead. Yes, it's annoying but we haven't found a way to turn if off.  Q. Using Jackson, the Data class auto-marshalling is not working correctly when my JSON fields start with capital letters  A.  Because of the way in which the Jackson library works, uppercase field names are NOT supported. Either switch out to use  http4k-format-gson  (which has the same API), or annotate your Data class fields with  @JsonAlias  to get the deserialisation to work correctly.  Q. Using Gson, the data class auto-marshalling does not fail when a null is populated in a Kotlin non-nullable field  A.  This happens because http4k uses straight GSON demarshalling, of JVM objects with no-Kotlin library in the mix. The nullability generally gets checked at compile-type and the lack of a Kotlin sanity check library exposes this flaw. No current fix - apart from to use the Jackson demarshalling instead!  Q. My application uses Lenses, but when they fail I get an HTTP 500 instead of the promised 400.  A.  You forgot to add the  ServerFilters.CatchLensFailure  filter to your Server stack.", 
            "title": "Lenses &amp; Auto-Marshalling"
        }, 
        {
            "location": "/support/", 
            "text": "In the first instance, try and see if there is a relevant example in the cookbook - more and more are being added all the time!\n\n\nFor issues, please describe giving as much detail as you can - including version and steps to recreate.\n\n\nSlack room:\n #http4k @ \nslack.kotlinlang.org\n \n-- PREFERRED\n\n\nGitter channel:\n http4k/http4k @ \ngitter.im\n \n\n\nTwitter:\n \n@http4k\n\n\n\n\nNote:\n As a general rule, you'll get a quicker response from the Slack channel.\n\n\nLogo usage\n\n\nThe http4k logo design and branding are copyright 2017 to http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant \nbranding guidelines\n.", 
            "title": "Help & Support"
        }, 
        {
            "location": "/support/#logo-usage", 
            "text": "The http4k logo design and branding are copyright 2017 to http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant  branding guidelines .", 
            "title": "Logo usage"
        }
    ]
}