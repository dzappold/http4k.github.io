{
    "docs": [
        {
            "location": "/", 
            "text": "http4k\n is an HTTP toolkit written in \nKotlin\n that enables the serving and consuming of HTTP services in a functional and consistent way.\n\n\nIt consists of a core library \nhttp4k-core\n providing a base HTTP implementation + a number of abstractions for various functionalities (such as \nservers, clients, templating etc) that are provided as optional add-on libraries.\n\n\nThe principles of the toolkit are:\n\n\n\n\nApplication as a Function:\n Based on the Twitter paper \n\"Your Server as a Function\"\n, all HTTP services can be composed \nof 2 types of simple function:\n\n\nHttpHandler:\n \n(Request) -\n Response\n - provides a remote call for processing a Request. \n\n\nFilter:\n \n(HttpHandler) -\n HttpHandler\n - adds Request/Response pre/post processing. These filters are composed to make stacks of reusable behaviour that can \nthen be applied to an \nHttpHandler\n.\n\n\n\n\n\n\nImmutablility:\n All entities in the library are immutable unless their function explicitly disallows this.\n\n\nSymmetric:\n The \nHttpHandler\n interface is identical for both HTTP services and clients. This allows for simple offline testability of applications, as well as \nplugging together of services without HTTP container being required.\n\n\nDependency-lite:\n The \nhttp4k-core\n module has ZERO dependencies. Add-on modules only have dependencies required for specific implementation.\n\n\nTestability\n Built by \nTDD\n enthusiasts, so supports \nsuper-easy\n mechanisms for both In and Out of Container testing of:\n\n\nindividual endpoints\n\n\napplications\n\n\nfull suites of microservices\n\n\n\n\n\n\nModularity:\n Common behaviours are abstracted into the \nhttp4k-core\n module. Current add-ons cover:\n\n\nPluggable HTTP client adapters for Apache and OkHttp\n\n\nPluggable Server backends: Single LOC Server spinup for Jetty, Netty and Undertow\n\n\nTypesafe, auto-validating, self-documenting (via Swagger) contracts for HTTP services\n\n\nHTTP message adapters for Argo JSON, Gson JSON and Jackson JSON (includes auto-marshalling)\n\n\nTemplating support: Caching and Hot-Reload engine support for Handlebars\n\n\nAWS request signing: super-simple interactions with AWS services.\n\n\n\n\n\n\n\n\nModule feature overview\n\n\n\n\nCore:\n \n\n\nBase HTTP handler and \nimmutable HTTP message\n objects, cookie handling. \n\n\nCommonly used HTTP functionalities provided as reusable Filters (caching, debugging, \nZipkin request tracing\n)\n\n\nPath-based routing\n, including nestable contexts\n\n\nTypesafe HTTP message construction/desconstruction\n using Lenses\n\n\nStatic file-serving\n capability with \nCaching and Hot-Reload\n \n\n\nServlet implementation to allow \nzero-dependency plugin to any Servlet container\n\n\nLaunch applications in \n1LOC\n with an embedded \nSunHttp\n server backend (recommended for development use only)\n\n\nCore abstraction APIs implemented by the other modules \n\n\n\n\n\n\nClient:\n \n\n\n1LOC\n HTTP client adapters \n\n\nApache\n\n\nOkHttp\n\n\n\n\n\n\n\n\n\n\nServer:\n\n\n1LOC\n server backend spinup for:\n\n\nJetty\n\n\nNetty\n\n\nUndertow\n\n\n\n\n\n\nAPI design allows for plugging into configurable instances of each\n\n\n\n\n\n\nContracts:\n \n\n\nDefinite \nTypesafe\n HTTP contracts, defining required and optional path/query/header/bodies\n\n\nTypesafe\n path matching\n\n\nAuto-validation\n of incoming requests == \nzero boilerplate validation code\n\n\nSelf-documenting for all routes - eg. Built in support for live \nSwagger\n description endpoints including \nJSON Schema\n model breakdown. \n\n\nTemplating:\n \n\n\nPluggable\n templating system support for:\n\n\nHandlebars\n \n\n\nPebble\n\n\nThymeleaf\n\n\n\n\n\n\nCaching and \nHot-Reload\n template support\n\n\n\n\n\n\nMessage formats:\n \n\n\nConsistent API provides first class support for marshalling JSON to/from HTTP messages for:\n\n\nJackson\n - includes support for \nfully \nautomatic marshalling\n of Data classes\n)\n\n\nGson\n - includes support for \nfully \nautomatic marshalling\n of Data classes\n)\n\n\nArgo\n\n\n\n\n\n\n\n\n\n\nAWS:\n \n\n\nClient filter to allow super-simple interaction with AWS services (via request signing)\n\n\n\n\n\n\n\n\nExample\n\n\nThis quick example is designed to convey the simplicity \n features of \nhttp4k\n. See also the \nquickstart\n for the simplest possible starting point.\n\n\nTo install, add these dependencies to your \nGradle\n file:\n\n\ndependencies\n \n{\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-core\n,\n \nversion:\n \n2.11.2\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-server-jetty\n,\n \nversion:\n \n2.11.2\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-client-okhttp\n,\n \nversion:\n \n2.11.2\n\n\n}\n\n\n\n\n\n\nThis \"Hello World\" style example demonstrates how to serve and consume HTTP services with dynamic routing:\n\n\npackage\n \ncookbook\n\n\n\nimport\n \norg.http4k.client.OkHttp\n\n\nimport\n \norg.http4k.core.Filter\n\n\nimport\n \norg.http4k.core.HttpHandler\n\n\nimport\n \norg.http4k.core.Method.GET\n\n\nimport\n \norg.http4k.core.Request\n\n\nimport\n \norg.http4k.core.Response\n\n\nimport\n \norg.http4k.core.Status.Companion.OK\n\n\nimport\n \norg.http4k.core.then\n\n\nimport\n \norg.http4k.filter.CachingFilters\n\n\nimport\n \norg.http4k.routing.bind\n\n\nimport\n \norg.http4k.routing.path\n\n\nimport\n \norg.http4k.routing.routes\n\n\nimport\n \norg.http4k.server.Jetty\n\n\nimport\n \norg.http4k.server.asServer\n\n\n\nfun\n \nmain\n(\nargs\n:\n \nArray\nString\n)\n \n{\n\n    \n// we can bind HttpHandlers (which are just functions from  Request -\n Response) to paths/methods to create a Route,\n\n    \n// then combine many Routes together to make another HttpHandler\n\n    \nval\n \napp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n        \n/ping\n \nto\n \nGET\n \nbind\n \n{\n \n_\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\npong!\n)\n \n},\n\n        \n/greet/{name}\n \nto\n \nGET\n \nbind\n \n{\n \nreq\n:\n \nRequest\n \n-\n\n            \nval\n \npath\n:\n \nString\n?\n \n=\n \nreq\n.\npath\n(\nname\n)\n\n            \nResponse\n(\nOK\n).\nbody\n(\nhello ${path ?: \nanon\n!\n}\n)\n\n        \n}\n\n    \n)\n\n\n    \n// call the handler in-memory without spinning up a server\n\n    \nval\n \ninMemoryResponse\n:\n \nResponse\n \n=\n \napp\n(\nRequest\n(\nGET\n,\n \n/greet/Bob\n))\n\n    \nprintln\n(\ninMemoryResponse\n)\n\n\n\n// Produces:\n\n\n//    HTTP/1.1 200 OK\n\n\n//\n\n\n//\n\n\n//    hello Bob\n\n\n    \n// this is a Filter - it performs pre/post processing on a request or response\n\n    \nval\n \ntimingFilter\n \n=\n \nFilter\n \n{\n\n        \nnext\n:\n \nHttpHandler\n \n-\n\n        \n{\n\n            \nrequest\n:\n \nRequest\n \n-\n\n            \nval\n \nstart\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n\n            \nval\n \nresponse\n \n=\n \nnext\n(\nrequest\n)\n\n            \nval\n \nlatency\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n \n-\n \nstart\n\n            \nprintln\n(\nRequest to ${request.uri} took ${latency}ms\n)\n\n            \nresponse\n\n        \n}\n\n    \n}\n\n\n    \n// we can \nstack\n filters to create reusable units, and then apply them to an HttpHandler\n\n    \nval\n \ncompositeFilter\n \n=\n \nCachingFilters\n.\nResponse\n.\nNoCache\n().\nthen\n(\ntimingFilter\n)\n\n    \nval\n \nfilteredApp\n:\n \nHttpHandler\n \n=\n \ncompositeFilter\n.\nthen\n(\napp\n)\n\n\n    \n// only 1 LOC to mount an app and start it in a container\n\n    \nfilteredApp\n.\nasServer\n(\nJetty\n(\n9000\n)).\nstart\n()\n\n\n    \n// HTTP clients are also HttpHandlers!\n\n    \nval\n \nclient\n:\n \nHttpHandler\n \n=\n \nOkHttp\n()\n\n\n    \nval\n \nnetworkResponse\n:\n \nResponse\n \n=\n \nclient\n(\nRequest\n(\nGET\n,\n \nhttp://localhost:9000/greet/Bob\n))\n\n    \nprintln\n(\nnetworkResponse\n)\n\n\n\n// Produces:\n\n\n//    Request to /api/greet/Bob took 1ms\n\n\n//    HTTP/1.1 200\n\n\n//    cache-control: private, must-revalidate\n\n\n//    content-length: 9\n\n\n//    date: Thu, 08 Jun 2017 13:01:13 GMT\n\n\n//    expires: 0\n\n\n//    server: Jetty(9.3.16.v20170120)\n\n\n//\n\n\n//    hello Bob\n\n\n}\n\n\n\n\n\n\nAcknowledgments\n\n\n\n\nDan Bodart\n's \nutterlyidle\n\n\nIvan Moore\n for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\"", 
            "title": "Introduction"
        }, 
        {
            "location": "/#module-feature-overview", 
            "text": "Core:    Base HTTP handler and  immutable HTTP message  objects, cookie handling.   Commonly used HTTP functionalities provided as reusable Filters (caching, debugging,  Zipkin request tracing )  Path-based routing , including nestable contexts  Typesafe HTTP message construction/desconstruction  using Lenses  Static file-serving  capability with  Caching and Hot-Reload    Servlet implementation to allow  zero-dependency plugin to any Servlet container  Launch applications in  1LOC  with an embedded  SunHttp  server backend (recommended for development use only)  Core abstraction APIs implemented by the other modules     Client:    1LOC  HTTP client adapters   Apache  OkHttp      Server:  1LOC  server backend spinup for:  Jetty  Netty  Undertow    API design allows for plugging into configurable instances of each    Contracts:    Definite  Typesafe  HTTP contracts, defining required and optional path/query/header/bodies  Typesafe  path matching  Auto-validation  of incoming requests ==  zero boilerplate validation code  Self-documenting for all routes - eg. Built in support for live  Swagger  description endpoints including  JSON Schema  model breakdown.   Templating:    Pluggable  templating system support for:  Handlebars    Pebble  Thymeleaf    Caching and  Hot-Reload  template support    Message formats:    Consistent API provides first class support for marshalling JSON to/from HTTP messages for:  Jackson  - includes support for  fully  automatic marshalling  of Data classes )  Gson  - includes support for  fully  automatic marshalling  of Data classes )  Argo      AWS:    Client filter to allow super-simple interaction with AWS services (via request signing)", 
            "title": "Module feature overview"
        }, 
        {
            "location": "/#example", 
            "text": "This quick example is designed to convey the simplicity   features of  http4k . See also the  quickstart  for the simplest possible starting point.  To install, add these dependencies to your  Gradle  file:  dependencies   { \n     compile   group:   org.http4k ,   name:   http4k-core ,   version:   2.11.2 \n     compile   group:   org.http4k ,   name:   http4k-server-jetty ,   version:   2.11.2 \n     compile   group:   org.http4k ,   name:   http4k-client-okhttp ,   version:   2.11.2  }   This \"Hello World\" style example demonstrates how to serve and consume HTTP services with dynamic routing:  package   cookbook  import   org.http4k.client.OkHttp  import   org.http4k.core.Filter  import   org.http4k.core.HttpHandler  import   org.http4k.core.Method.GET  import   org.http4k.core.Request  import   org.http4k.core.Response  import   org.http4k.core.Status.Companion.OK  import   org.http4k.core.then  import   org.http4k.filter.CachingFilters  import   org.http4k.routing.bind  import   org.http4k.routing.path  import   org.http4k.routing.routes  import   org.http4k.server.Jetty  import   org.http4k.server.asServer  fun   main ( args :   Array String )   { \n     // we can bind HttpHandlers (which are just functions from  Request -  Response) to paths/methods to create a Route, \n     // then combine many Routes together to make another HttpHandler \n     val   app :   HttpHandler   =   routes ( \n         /ping   to   GET   bind   {   _ :   Request   -   Response ( OK ). body ( pong! )   }, \n         /greet/{name}   to   GET   bind   {   req :   Request   - \n             val   path :   String ?   =   req . path ( name ) \n             Response ( OK ). body ( hello ${path ?:  anon ! } ) \n         } \n     ) \n\n     // call the handler in-memory without spinning up a server \n     val   inMemoryResponse :   Response   =   app ( Request ( GET ,   /greet/Bob )) \n     println ( inMemoryResponse )  // Produces:  //    HTTP/1.1 200 OK  //  //  //    hello Bob \n\n     // this is a Filter - it performs pre/post processing on a request or response \n     val   timingFilter   =   Filter   { \n         next :   HttpHandler   - \n         { \n             request :   Request   - \n             val   start   =   System . currentTimeMillis () \n             val   response   =   next ( request ) \n             val   latency   =   System . currentTimeMillis ()   -   start \n             println ( Request to ${request.uri} took ${latency}ms ) \n             response \n         } \n     } \n\n     // we can  stack  filters to create reusable units, and then apply them to an HttpHandler \n     val   compositeFilter   =   CachingFilters . Response . NoCache (). then ( timingFilter ) \n     val   filteredApp :   HttpHandler   =   compositeFilter . then ( app ) \n\n     // only 1 LOC to mount an app and start it in a container \n     filteredApp . asServer ( Jetty ( 9000 )). start () \n\n     // HTTP clients are also HttpHandlers! \n     val   client :   HttpHandler   =   OkHttp () \n\n     val   networkResponse :   Response   =   client ( Request ( GET ,   http://localhost:9000/greet/Bob )) \n     println ( networkResponse )  // Produces:  //    Request to /api/greet/Bob took 1ms  //    HTTP/1.1 200  //    cache-control: private, must-revalidate  //    content-length: 9  //    date: Thu, 08 Jun 2017 13:01:13 GMT  //    expires: 0  //    server: Jetty(9.3.16.v20170120)  //  //    hello Bob  }", 
            "title": "Example"
        }, 
        {
            "location": "/#acknowledgments", 
            "text": "Dan Bodart 's  utterlyidle  Ivan Moore  for pairing on \"BarelyMagical\", a 50-line wrapper around utterlyidle to allow \"Server as a Function\"", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/rationale/", 
            "text": "http4k\n is the distillation of 15 years worth of experience of using various server-side libraries and we've stolen good ideas from everywhere we can. For instance - \nthe routing module is inspired by \nUtterlyIdle\n, the \"Server as a function\" and filter model is stolen from \n\nFinagle\n, and the contract module/Swagger generator is ported from \nFintrospect\n. With the growing \nadoption of Kotlin, we wanted something that would fully leverage the features of the language and it felt like a good time to start something from scratch.\n\n\nFor our purposes, we needed something that:\n\n\n\n\nStarts/stops ultra quickly.\n\n\nEasily testable outside of an HTTP container, and testing should require little to no custom infrastructure.\n\n\nProvides typesafe HTTP message deconstruction/construction (in this case via Lenses).\n\n\nAutomatically deals with contract breaches (missing/invalid params etc) to remove boilerplate.\n\n\nAbsolutely no magic involved: No reflection. No annotations.\n\n\nMinimal dependencies (\nhttp4k-core\n has zero).\n\n\nAutomatic generation of Swagger documentation (including JSON Schema models).\n\n\nHas a symmetric server/client API (\nHttpHandler\n should just be \nRequest -\n Response\n).\n\n\nHas immutable Request/Response objects.\n\n\n\n\nhttp4k\n ticks all of these boxes. \n\n\nIt allow us to construct entire suites of services which can be tested either wired together without HTTP, or spun up in containers \nin 1 LOC. The symmetric HTTP API also allows filter chains (often called interceptors in other frameworks) to be constructed into reusable units/stacks for both \nserver and client sides (eg. logging/metrics/caching...) since they can be composed together for later use. \n\n\nAs a bonus, we can also easily create simple Fake servers for any HTTP contract, which means (in combination with CDC suites) you can end-to-end test micro-services in an outside-in way (using GOOS-style acceptance tests).\n\n\nScenarios such as \"what happens if this HTTP dependency continually takes \n 5 seconds to respond?\" are easily modelled - answers you can't easily get if you're faking out your dependencies inside the HTTP boundary.\n\n\nConcepts\n\n\n\n\nAll incoming and outgoing HTTP services are modelled as \nHttpHandler\n, which is modelled as \n(Request) -\n Response\n:\n\n\n\n\nval\n \nhandler\n:\n \nHttpHandler\n \n=\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n)\n \n}\n\n\n\n\n\n\n\n\nPre/post processing is done using a \nFilter\n, which is modelled as \n(HttpHandler) -\n HttpHandler\n. Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating \nHttpHandler\n - to yield \na decorated \nHttpHander\n:\n\n\n\n\n    \nval\n \nfilter\n:\n \nFilter\n \n=\n \nFilter\n \n{\n \nnext\n:\n \nHttpHandler\n \n-\n \nrequest\n:\n \nRequest\n \n-\n \nnext\n(\nrequest\n).\nheader\n(\nmy response header\n,\n \nvalue\n)}\n \n}\n\n    \nval\n \ndecorated\n:\n \nHttpHandler\n \n=\n \nfilter\n.\nthen\n(\nhandler\n)\n\n\n\n\n\n\n\n\nBinding an \nHttpHandler\n to a path and HTTP verb yields a \nRoute\n:\n\n\n\n\nval\n \nroute\n:\n \nRoute\n \n=\n \n/path\n \nto\n \nGET\n \nbind\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou GET bob\n)\n \n}\n\n\n\n\n\n\n\n\nRoutes\n can be combined together into a \nRoutingHttpHandler\n, which is both an \nHttpHandler\n and a\nRouter\n:\n\n\n\n\nval\n \napp\n:\n \nRoutingHttpHandler\n \n=\n \nroutes\n(\n\n    \nbob\n \nto\n \nGET\n \nbind\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou GET bob\n)\n \n},\n\n    \nrita\n \nto\n \nPOST\n \nbind\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou POST rita\n)\n \n},\n\n    \nsue\n \nto\n \nDELETE\n \nbind\n \n{\n \nResponse\n(\nOK\n).\nbody\n(\nyou DELETE sue\n)\n \n}\n\n\n)\n\n\n\n\n\n\n\n\nA \nRouter\n is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next \nRouter\n in the list.\n\n\nRouters\n can be combined together to form another \nHttpHandler\n:\n\n\n\n\nval\n \nbigApp\n:\n \nHttpHandler\n \n=\n \nroutes\n(\n\n    \n/this\n \nbind\n \napp\n,\n \n    \n/other\n \nbind\n \napp\n\n\n)\n\n\n\n\n\n\n\n\nHttpHandlers\n can be bound to a container (to create an \nHttp4kServer\n) with 1 LOC. The decouples the server implementation from the business logic:\n\n\n\n\nval\n \njettyServer\n \n=\n \napp\n.\nasServer\n(\nJetty\n(\n9000\n)).\nstart\n()\n\n\n\n\n\n\n\n\nAn Http client is also a \nHttpHandler\n:\n\n\n\n\nval\n \nclient\n:\n \nHttpHandler\n \n=\n \nApacheClient\n()\n\n\n\n\n\n\n\n\nBecause the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other:\n\n\n\n\n    \nval\n \napp1\n:\n \nHttpHandler\n \n=\n \nMyApp1\n()\n\n    \nval\n \napp2\n:\n \nHttpHandler\n \n=\n \nMyApp2\n(\napp1\n)", 
            "title": "Rationale & Concepts"
        }, 
        {
            "location": "/rationale/#concepts", 
            "text": "All incoming and outgoing HTTP services are modelled as  HttpHandler , which is modelled as  (Request) -  Response :   val   handler :   HttpHandler   =   {   request :   Request   -   Response ( OK )   }    Pre/post processing is done using a  Filter , which is modelled as  (HttpHandler) -  HttpHandler . Filters can therefore be composed together to make reusable \"stacks\" of behaviour which can be applied to a terminating  HttpHandler  - to yield \na decorated  HttpHander :        val   filter :   Filter   =   Filter   {   next :   HttpHandler   -   request :   Request   -   next ( request ). header ( my response header ,   value )}   } \n     val   decorated :   HttpHandler   =   filter . then ( handler )    Binding an  HttpHandler  to a path and HTTP verb yields a  Route :   val   route :   Route   =   /path   to   GET   bind   {   Response ( OK ). body ( you GET bob )   }    Routes  can be combined together into a  RoutingHttpHandler , which is both an  HttpHandler  and a Router :   val   app :   RoutingHttpHandler   =   routes ( \n     bob   to   GET   bind   {   Response ( OK ). body ( you GET bob )   }, \n     rita   to   POST   bind   {   Response ( OK ). body ( you POST rita )   }, \n     sue   to   DELETE   bind   {   Response ( OK ). body ( you DELETE sue )   }  )    A  Router  is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next  Router  in the list.  Routers  can be combined together to form another  HttpHandler :   val   bigApp :   HttpHandler   =   routes ( \n     /this   bind   app ,  \n     /other   bind   app  )    HttpHandlers  can be bound to a container (to create an  Http4kServer ) with 1 LOC. The decouples the server implementation from the business logic:   val   jettyServer   =   app . asServer ( Jetty ( 9000 )). start ()    An Http client is also a  HttpHandler :   val   client :   HttpHandler   =   ApacheClient ()    Because the client and server interfaces are the same, apps can simply be plugged together out-of-container by just injecting one into the other:        val   app1 :   HttpHandler   =   MyApp1 () \n     val   app2 :   HttpHandler   =   MyApp2 ( app1 )", 
            "title": "Concepts"
        }, 
        {
            "location": "/installation/", 
            "text": "All \nhttp4k\n libraries are available on Maven Central and JCenter and are released under a single version. For the core module, add the following to your Gradle file:\n\n\ncompile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.11.2", 
            "title": "Installation"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quickstart\n\n\nThis simple example demonstates how to serve and consume HTTP services using \nhttp4k\n. \n\n\nTo install, add these dependencies to your \nGradle\n file:\n\n\ndependencies\n \n{\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-core\n,\n \nversion:\n \n2.11.2\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-server-jetty\n,\n \nversion:\n \n2.11.2\n\n    \ncompile\n \ngroup:\n \norg.http4k\n,\n \nname:\n \nhttp4k-client-apache\n,\n \nversion:\n \n2.11.2\n\n\n}\n\n\n\n\n\n\nThe following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it.", 
            "title": "Getting started"
        }, 
        {
            "location": "/quickstart/#quickstart", 
            "text": "This simple example demonstates how to serve and consume HTTP services using  http4k .   To install, add these dependencies to your  Gradle  file:  dependencies   { \n     compile   group:   org.http4k ,   name:   http4k-core ,   version:   2.11.2 \n     compile   group:   org.http4k ,   name:   http4k-server-jetty ,   version:   2.11.2 \n     compile   group:   org.http4k ,   name:   http4k-client-apache ,   version:   2.11.2  }   The following creates a simple endpoint, binds it to a Jetty server then starts, queries, and stops it.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/guide/modules/core/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-core\", version: \"2.11.2\"\n\n\nAbout\n\n\nThe core module has ZERO dependencies and provides the following:\n\n\n\n\nImmutable versions of the HTTP spec objects (Request, Response, Cookies etc).\n\n\nHTTP handler and filter abstractions which models services as simple, composable functions.\n\n\nSimple routing implementation, plus \nHttpHandlerServlet\n to enable plugging into any Servlet engine. \n\n\nLens\n mechanism for typesafe destructuring and construction of HTTP messages.\n\n\nAbstractions for Servers, Clients, JSON Message formats, Templating etc.\n\n\nSunHttp\n Single-LOC development Server-backend \n\n\n\n\nHttpHandlers\n\n\nIn \nhttp4k\n, an HTTP service is just a typealias of a simple function:\n\n\ntypealias\n \nHttpHandler\n \n=\n \n(\nRequest\n)\n \n-\n \nResponse\n\n\n\n\n\n\nFirst described in this Twitter paper \n\"Your Server as a Function\"\n, this abstraction allows us lots of \nflexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an \nHttpHandler\n, neither do we \nneed to launch a real HTTP container to exercise it:\n\n\nval\n \nhandler\n \n=\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello, ${request.query(\nname\n)}!\n)\n \n}\n\n\nval\n \nget\n \n=\n \nRequest\n(\nMethod\n.\nGET\n,\n \n/\n).\nquery\n(\nname\n,\n \nJohn Doe\n)\n\n\nval\n \nresponse\n \n=\n \napp\n(\nget\n)\n\n\n\nprintln\n(\nresponse\n.\nstatus\n)\n\n\nprintln\n(\nresponse\n.\nbodyString\n())\n\n\n\n\n\n\nTo mount the \nHttpHandler\n in a container, the can simply be converted to a Servlet by calling \nhandler.asServlet()\n\n\nFilters\n\n\nFilters add extra processing to either the Request or Response. In \nhttp4k\n, they are modelled as:\n\n\ninterface\n \nFilter\n \n:\n \n(\nHttpHandler\n)\n \n-\n \nHttpHandler\n\n\n\n\n\n\nFilters are designed to simply compose together (using \nthen()\n) , creating reusable stacks of behaviour which can then be applied to any \nHttpHandler\n. \nFor example, to add Basic Auth and latency reporting to a service:\n\n\nval\n \nhandler\n \n=\n \n{\n \n_\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n)\n \n}\n\n\n\nval\n \nmyFilter\n \n=\n \nFilter\n \n{\n\n    \nnext\n:\n \nHttpHandler\n \n-\n \n{\n\n        \nrequest\n:\n \nRequest\n \n-\n \n            \nval\n \nstart\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n\n            \nval\n \nresponse\n \n=\n \nnext\n(\nit\n)\n\n            \nval\n \nlatency\n \n=\n \nSystem\n.\ncurrentTimeMillis\n()\n \n-\n \nstart\n\n            \nprintln\n(\nI took $latency ms\n)\n\n            \nresponse\n\n    \n}\n\n\n}\n\n\nval\n \nlatencyAndBasicAuth\n:\n \nHttpHandler\n \n=\n \nServerFilters\n.\nBasicAuth\n(\nmy realm\n,\n \nuser\n,\n \npassword\n).\nthen\n(\nmyFilter\n)\n\n\nval\n \napp\n:\n \nHttpHandler\n \n=\n \nlatencyAndBasicAuth\n.\nthen\n(\nhandler\n)\n\n\n\n\n\n\nThe \nhttp4k-core\n module comes with a set of handy Filters for application to both Server and Client \nHttpHandlers\n, covering common things like:\n\n\n\n\nRequest tracing headers (x-b3-traceid etc)\n\n\nBasic Auth\n\n\nCache Control\n\n\nCORS\n\n\nCookie handling\n\n\nDebugging request and responses\n\n\n\n\nCheck out the \norg.http4k.filter\n package for the exact list.\n\n\nSimple Routing\n\n\nBasic routing for mapping a URL pattern to an \nHttpHandler\n:\n\n\nroutes\n(\n\n    \n/hello/{name:*}\n \nto\n \nGET\n \nbind\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello, ${request.path(\nname\n)}!\n)\n \n},\n\n    \n/fail\n \nto\n \nPOST\n \nbind\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nINTERNAL_SERVER_ERROR\n)\n \n}\n\n\n).\nasServer\n(\nJetty\n(\n8000\n)).\nstart\n()\n\n\n\n\n\n\nNote that the \nhttp4k-contract\n module contains a more typesafe implementation of routing functionality.\n\n\nTypesafe parameter destructuring/construction of HTTP messages with Lenses\n\n\nGetting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. \nFor this purpose, we can use a \nLens\n. \n\n\nA Lens is a bi-directional entity which can be used to either \nget\n or \nset\n a particular value from/onto an HTTP message. \nhttp4k\n provides a DSL \nto configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional). \n\n\nTo utilise a lens, first you have to declare it with the form \nLocation\n.\nconfiguration and mapping operations\n.\nterminator\n.\n\n\nThere is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location:\n\n\n\n\n\n\n\n\nLocation\n\n\nStarting type\n\n\nApplicable to\n\n\nMultiplicity\n\n\nRequirement terminator\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nQuery\n\n\nString\n\n\nRequest\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nQuery.optional(\"name\")\nQuery.required(\"name\")\nQuery.int().required(\"name\")\nQuery.localDate().multi.required(\"name\")\nQuery.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nHeader\n\n\nString\n\n\nRequest\n or \nResponse\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nHeader.optional(\"name\")\nHeader.required(\"name\")\nHeader.int().required(\"name\")\nHeader.localDate().multi.required(\"name\")\nHeader.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nPath\n\n\nString\n\n\nRequest\n\n\nSingular\n\n\nRequired\n\n\nPath.of(\"name\")\nPath.int().of(\"name\")\nPath.map(::CustomType, { it.value }).of(\"name\")\n\n\n\n\n\n\nFormField\n\n\nString\n\n\nWebForm\n\n\nSingular or multiple\n\n\nOptional or Required\n\n\nFormField.optional(\"name\")\nFormField.required(\"name\")\nFormField.int().required(\"name\")\nFormField.localDate().multi.required(\"name\")\nFormField.map(::CustomType, { it.value }).required(\"name\")\n\n\n\n\n\n\nBody\n\n\nByteBuffer\n\n\nRequest\n or \nResponse\n\n\nSingular\n\n\nRequired\n\n\nBody.string(ContentType.TEXT_PLAIN).toLens()\nBody.json().toLens()\nBody.webForm(FormValidator.Strict, FormField.required(\"name\")).toLens()\n\n\n\n\n\n\n\n\nOnce the lens is declared, you can use it on a target object to either get or set the value:\n\n\n\n\nRetrieving a value: use \nlens\n.extract(\ntarget\n)\n, or the more concise invoke form: \nlens\n(\ntarget\n)\n\n\nSetting a value: use \nlens\n.inject(\ntarget\n)\n, or the more concise invoke form: \nlens\n(\nvalue\n, \ntarget\n)\n\n\n\n\nval\n \npathLocalDate\n \n=\n \nPath\n.\nlocalDate\n().\nof\n(\ndate\n)\n\n\nval\n \nrequiredQuery\n \n=\n \nQuery\n.\nrequired\n(\nmyQueryName\n)\n\n\nval\n \nnonEmptyQuery\n \n=\n \nQuery\n.\nnonEmptyString\n().\nrequired\n(\nmyNonEmptyQuery\n)\n\n\nval\n \noptionalHeader\n \n=\n \nHeader\n.\nint\n().\noptional\n(\nContent-Length\n)\n\n\nval\n \nresponseBody\n \n=\n \nBody\n.\nstring\n(\nPLAIN_TEXT\n).\ntoLens\n()\n\n\n\n// Most of the useful common JDK types are covered. However, if we want to use our own types, we can just use `map()`\n\n\ndata\n \nclass\n \nCustomType\n(\nval\n \nvalue\n:\n \nString\n)\n\n\nval\n \nrequiredCustomQuery\n \n=\n \nQuery\n.\nmap\n(\n::\nCustomType\n,\n \n{\n \nit\n.\nvalue\n \n}).\nrequired\n(\nmyCustomType\n)\n\n\n\n//To use the Lens, simply `invoke() or extract()` it using an HTTP message to extract the value, or alternatively `invoke() or inject()` it with the value if we are modifying (via copy) the message:\n\n\nval\n \nhandler\n \n=\n \nroutes\n(\n\n    \n/hello/{date:*}\n \nto\n \nGET\n \nbind\n \n{\n \nrequest\n:\n \nRequest\n \n-\n \n         \nval\n \npathDate\n:\n \nLocalDate\n \n=\n \npathLocalDate\n(\nrequest\n)\n \n         \n// SAME AS: \n\n         \n// val pathDate: LocalDate = pathLocalDate.extract(request)\n\n\n         \nval\n \ncustomType\n:\n \nCustomType\n \n=\n \nrequiredCustomQuery\n(\nrequest\n)\n\n         \nval\n \nanIntHeader\n:\n \nInt\n?\n \n=\n \noptionalHeader\n(\nrequest\n)\n\n\n         \nval\n \nbaseResponse\n \n=\n \nResponse\n(\nOK\n)\n\n         \nval\n \nresponseWithHeader\n \n=\n \noptionalHeader\n(\nanIntHeader\n,\n \nbaseResponse\n)\n\n         \n// SAME AS:\n\n         \n// val responseWithHeader = optionalHeader.inject(anIntHeader, baseResponse)\n\n\n         \nresponseBody\n(\nyou sent $pathDate and $customType\n,\n \nresponseWithHeader\n)\n \n      \n}\n\n\n)\n\n\n\nval\n \napp\n \n=\n \nServerFilters\n.\nCatchLensFailure\n.\nthen\n(\nhandler\n(\nRequest\n(\nMethod\n.\nGET\n,\n \n/hello/2000-01-01?myCustomType=someValue\n)))\n\n\n//With the addition of the `CatchLensFailure` filter, no other validation is required when using Lenses, as **http4k** will handle invalid requests by returning a BAD_REQUEST (400) response.\n\n\n\n//More convieniently for construction of HTTP messages, multiple lenses can be used at once to modify a message, which is useful for properly building both requests and responses in a typesafe way without resorting to string values (especially in \n\n\nURLs\n \nwhich\n \nshould\n \nnever\n \nbe\n \nconstructed\n \nusing\n \nString\n \nconcatenation\n):\n\n\n\nval\n \nmodifiedRequest\n:\n \nRequest\n \n=\n \nRequest\n(\nMethod\n.\nGET\n,\n \nhttp://google.com/{pathLocalDate}\n).\nwith\n(\n\n    \npathLocalDate\n \nof\n \nLocalDate\n.\nnow\n(),\n\n    \nrequiredQuery\n \nof\n \nmyAmazingString\n,\n\n    \noptionalHeader\n \nof\n \n123\n\n\n)\n\n\n\n\n\n\nOther features\n\n\nCreates \ncurl\n command for a given request:\n\n\nval\n \ncurl\n \n=\n \nRequest\n(\nPOST\n,\n \nhttp://httpbin.org/post\n).\nbody\n(\nlistOf\n(\nfoo\n \nto\n \nbar\n).\ntoBody\n()).\ntoCurl\n()\n\n\n// curl -X POST --data \nfoo=bar\n \nhttp://httpbin.org/post", 
            "title": "Core"
        }, 
        {
            "location": "/guide/modules/core/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-core\", version: \"2.11.2\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/core/#about", 
            "text": "The core module has ZERO dependencies and provides the following:   Immutable versions of the HTTP spec objects (Request, Response, Cookies etc).  HTTP handler and filter abstractions which models services as simple, composable functions.  Simple routing implementation, plus  HttpHandlerServlet  to enable plugging into any Servlet engine.   Lens  mechanism for typesafe destructuring and construction of HTTP messages.  Abstractions for Servers, Clients, JSON Message formats, Templating etc.  SunHttp  Single-LOC development Server-backend", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/core/#httphandlers", 
            "text": "In  http4k , an HTTP service is just a typealias of a simple function:  typealias   HttpHandler   =   ( Request )   -   Response   First described in this Twitter paper  \"Your Server as a Function\" , this abstraction allows us lots of \nflexibility in a language like Kotlin, since the conceptual barrier to service construction is reduced to effectively nil. Here is the simplest example - note that we don't need any special infrastructure to create an  HttpHandler , neither do we \nneed to launch a real HTTP container to exercise it:  val   handler   =   {   request :   Request   -   Response ( OK ). body ( Hello, ${request.query( name )}! )   }  val   get   =   Request ( Method . GET ,   / ). query ( name ,   John Doe )  val   response   =   app ( get )  println ( response . status )  println ( response . bodyString ())   To mount the  HttpHandler  in a container, the can simply be converted to a Servlet by calling  handler.asServlet()", 
            "title": "HttpHandlers"
        }, 
        {
            "location": "/guide/modules/core/#filters", 
            "text": "Filters add extra processing to either the Request or Response. In  http4k , they are modelled as:  interface   Filter   :   ( HttpHandler )   -   HttpHandler   Filters are designed to simply compose together (using  then() ) , creating reusable stacks of behaviour which can then be applied to any  HttpHandler . \nFor example, to add Basic Auth and latency reporting to a service:  val   handler   =   {   _ :   Request   -   Response ( OK )   }  val   myFilter   =   Filter   { \n     next :   HttpHandler   -   { \n         request :   Request   -  \n             val   start   =   System . currentTimeMillis () \n             val   response   =   next ( it ) \n             val   latency   =   System . currentTimeMillis ()   -   start \n             println ( I took $latency ms ) \n             response \n     }  }  val   latencyAndBasicAuth :   HttpHandler   =   ServerFilters . BasicAuth ( my realm ,   user ,   password ). then ( myFilter )  val   app :   HttpHandler   =   latencyAndBasicAuth . then ( handler )   The  http4k-core  module comes with a set of handy Filters for application to both Server and Client  HttpHandlers , covering common things like:   Request tracing headers (x-b3-traceid etc)  Basic Auth  Cache Control  CORS  Cookie handling  Debugging request and responses   Check out the  org.http4k.filter  package for the exact list.", 
            "title": "Filters"
        }, 
        {
            "location": "/guide/modules/core/#simple-routing", 
            "text": "Basic routing for mapping a URL pattern to an  HttpHandler :  routes ( \n     /hello/{name:*}   to   GET   bind   {   request :   Request   -   Response ( OK ). body ( Hello, ${request.path( name )}! )   }, \n     /fail   to   POST   bind   {   request :   Request   -   Response ( INTERNAL_SERVER_ERROR )   }  ). asServer ( Jetty ( 8000 )). start ()   Note that the  http4k-contract  module contains a more typesafe implementation of routing functionality.", 
            "title": "Simple Routing"
        }, 
        {
            "location": "/guide/modules/core/#typesafe-parameter-destructuringconstruction-of-http-messages-with-lenses", 
            "text": "Getting values from HTTP messages is one thing, but we want to ensure that those values are both present and valid. \nFor this purpose, we can use a  Lens .   A Lens is a bi-directional entity which can be used to either  get  or  set  a particular value from/onto an HTTP message.  http4k  provides a DSL \nto configure these lenses to target particular parts of the message, whilst at the same time specifying the requirement for those parts (i.e. mandatory or optional).   To utilise a lens, first you have to declare it with the form  Location . configuration and mapping operations . terminator .  There is one \"location\" type for each part of the message, each with config/mapping operations which are specific to that location:     Location  Starting type  Applicable to  Multiplicity  Requirement terminator  Examples      Query  String  Request  Singular or multiple  Optional or Required  Query.optional(\"name\") Query.required(\"name\") Query.int().required(\"name\") Query.localDate().multi.required(\"name\") Query.map(::CustomType, { it.value }).required(\"name\")    Header  String  Request  or  Response  Singular or multiple  Optional or Required  Header.optional(\"name\") Header.required(\"name\") Header.int().required(\"name\") Header.localDate().multi.required(\"name\") Header.map(::CustomType, { it.value }).required(\"name\")    Path  String  Request  Singular  Required  Path.of(\"name\") Path.int().of(\"name\") Path.map(::CustomType, { it.value }).of(\"name\")    FormField  String  WebForm  Singular or multiple  Optional or Required  FormField.optional(\"name\") FormField.required(\"name\") FormField.int().required(\"name\") FormField.localDate().multi.required(\"name\") FormField.map(::CustomType, { it.value }).required(\"name\")    Body  ByteBuffer  Request  or  Response  Singular  Required  Body.string(ContentType.TEXT_PLAIN).toLens() Body.json().toLens() Body.webForm(FormValidator.Strict, FormField.required(\"name\")).toLens()     Once the lens is declared, you can use it on a target object to either get or set the value:   Retrieving a value: use  lens .extract( target ) , or the more concise invoke form:  lens ( target )  Setting a value: use  lens .inject( target ) , or the more concise invoke form:  lens ( value ,  target )   val   pathLocalDate   =   Path . localDate (). of ( date )  val   requiredQuery   =   Query . required ( myQueryName )  val   nonEmptyQuery   =   Query . nonEmptyString (). required ( myNonEmptyQuery )  val   optionalHeader   =   Header . int (). optional ( Content-Length )  val   responseBody   =   Body . string ( PLAIN_TEXT ). toLens ()  // Most of the useful common JDK types are covered. However, if we want to use our own types, we can just use `map()`  data   class   CustomType ( val   value :   String )  val   requiredCustomQuery   =   Query . map ( :: CustomType ,   {   it . value   }). required ( myCustomType )  //To use the Lens, simply `invoke() or extract()` it using an HTTP message to extract the value, or alternatively `invoke() or inject()` it with the value if we are modifying (via copy) the message:  val   handler   =   routes ( \n     /hello/{date:*}   to   GET   bind   {   request :   Request   -  \n          val   pathDate :   LocalDate   =   pathLocalDate ( request )  \n          // SAME AS:  \n          // val pathDate: LocalDate = pathLocalDate.extract(request) \n\n          val   customType :   CustomType   =   requiredCustomQuery ( request ) \n          val   anIntHeader :   Int ?   =   optionalHeader ( request ) \n\n          val   baseResponse   =   Response ( OK ) \n          val   responseWithHeader   =   optionalHeader ( anIntHeader ,   baseResponse ) \n          // SAME AS: \n          // val responseWithHeader = optionalHeader.inject(anIntHeader, baseResponse) \n\n          responseBody ( you sent $pathDate and $customType ,   responseWithHeader )  \n       }  )  val   app   =   ServerFilters . CatchLensFailure . then ( handler ( Request ( Method . GET ,   /hello/2000-01-01?myCustomType=someValue )))  //With the addition of the `CatchLensFailure` filter, no other validation is required when using Lenses, as **http4k** will handle invalid requests by returning a BAD_REQUEST (400) response.  //More convieniently for construction of HTTP messages, multiple lenses can be used at once to modify a message, which is useful for properly building both requests and responses in a typesafe way without resorting to string values (especially in   URLs   which   should   never   be   constructed   using   String   concatenation ):  val   modifiedRequest :   Request   =   Request ( Method . GET ,   http://google.com/{pathLocalDate} ). with ( \n     pathLocalDate   of   LocalDate . now (), \n     requiredQuery   of   myAmazingString , \n     optionalHeader   of   123  )", 
            "title": "Typesafe parameter destructuring/construction of HTTP messages with Lenses"
        }, 
        {
            "location": "/guide/modules/core/#other-features", 
            "text": "Creates  curl  command for a given request:  val   curl   =   Request ( POST ,   http://httpbin.org/post ). body ( listOf ( foo   to   bar ). toBody ()). toCurl ()  // curl -X POST --data  foo=bar   http://httpbin.org/post", 
            "title": "Other features"
        }, 
        {
            "location": "/guide/modules/servers/", 
            "text": "Installation (Gradle)\n\n\nSunHttp (for development only):\n \ncompile group: \"org.http4k\", name: \"http4k-server-core\", version: \"2.11.2\"\n\n\nJetty:\n \ncompile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"2.11.2\"\n\n\nNetty:\n \ncompile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"2.11.2\"\n\n\nUndertow:\n \ncompile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"2.11.2\"\n\n\nAbout\n\n\nServer-backend modules provide a consistent API mount HttpHandlers into the specified container in 1 LOC, by simply passing a \nServerConfig\n implementation (in this case \nJetty\n):\n\n\n{\n \nrequest\n:\n \nRequest\n \n-\n \nResponse\n(\nOK\n).\nbody\n(\nHello World\n)\n \n}.\nasServer\n(\nJetty\n(\n8000\n)).\nstart\n().\nblock\n()\n\n\n\n\n\n\nAlteratively, all server-backend modules allow for plugging \nhttp4k\n handlers into the relevant server API, which allows for custom Server configuration.", 
            "title": "Server Backend"
        }, 
        {
            "location": "/guide/modules/servers/#installation-gradle", 
            "text": "SunHttp (for development only):   compile group: \"org.http4k\", name: \"http4k-server-core\", version: \"2.11.2\"  Jetty:   compile group: \"org.http4k\", name: \"http4k-server-jetty\", version: \"2.11.2\"  Netty:   compile group: \"org.http4k\", name: \"http4k-server-netty\", version: \"2.11.2\"  Undertow:   compile group: \"org.http4k\", name: \"http4k-server-undertow\", version: \"2.11.2\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/servers/#about", 
            "text": "Server-backend modules provide a consistent API mount HttpHandlers into the specified container in 1 LOC, by simply passing a  ServerConfig  implementation (in this case  Jetty ):  {   request :   Request   -   Response ( OK ). body ( Hello World )   }. asServer ( Jetty ( 8000 )). start (). block ()   Alteratively, all server-backend modules allow for plugging  http4k  handlers into the relevant server API, which allows for custom Server configuration.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/clients/", 
            "text": "Installation (Gradle)\n\n\nApache:\n \ncompile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"2.11.2\"\n\n\nOkHttp:\n \ncompile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"2.11.2\"\n\n\nAbout\n\n\nSupported HTTP client adapter APIs are wrapped to provide an \nHttpHandler\n interface in 1 LOC:\n\n\nval\n \nclient\n \n=\n \nApacheClient\n()\n\n\nval\n \nrequest\n \n=\n \nRequest\n(\nMethod\n.\nGET\n,\n \nhttp://httpbin.org/get\n).\nquery\n(\nlocation\n,\n \nJohn Doe\n)\n\n\nval\n \nresponse\n \n=\n \nclient\n(\nrequest\n)\n\n\nprintln\n(\nresponse\n.\nstatus\n)\n\n\nprintln\n(\nresponse\n.\nbodyString\n())\n\n\n\n\n\n\nAlternatively, all client adapter modules allow for custom configuration of the relevant Client configuration.", 
            "title": "HTTP Client"
        }, 
        {
            "location": "/guide/modules/clients/#installation-gradle", 
            "text": "Apache:   compile group: \"org.http4k\", name: \"http4k-client-apache\", version: \"2.11.2\"  OkHttp:   compile group: \"org.http4k\", name: \"http4k-client-okhttp\", version: \"2.11.2\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/clients/#about", 
            "text": "Supported HTTP client adapter APIs are wrapped to provide an  HttpHandler  interface in 1 LOC:  val   client   =   ApacheClient ()  val   request   =   Request ( Method . GET ,   http://httpbin.org/get ). query ( location ,   John Doe )  val   response   =   client ( request )  println ( response . status )  println ( response . bodyString ())   Alternatively, all client adapter modules allow for custom configuration of the relevant Client configuration.", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/message_formats/", 
            "text": "Installation (Gradle)\n\n\nArgo:\n  \ncompile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"2.11.2\"\n\n\nGson:\n  \ncompile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"2.11.2\"\n\n\nJackson:\n \ncompile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"2.11.2\"\n\n\nAbout\n\n\nThese modules add the ability to use JSON as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of \nstandard methods and extension methods for converting common types into native JSON objects, including custom Lens methods for each library so that \nJSON node objects can be written and read directly from HTTP messages:\n\n\n\n\n\nAuto-marshalling capabilities\n\n\nSome of the JSON message libraries (eg. GSON and Jackson) provide the mechanism to automatically marshall data objects to/from JSON using reflection.\n\n\nWe can use this facility in \nhttp4k\n to automatically marshall objects to/from HTTP message bodies using *\nLenses\n:\n\n\n\n\n\nImportant note regarding JSON arrays\n\n\nWhen handling raw JSON array messages, such as: \n[123, 456, 567]\n, there is a slight gotcha when auto-marshalling messages from JSON.\n\n\nThis is demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list.\n\n\nAs shown, a workaround to this is to use \nBody.auto\nArray\nMyIntWrapper\n().toLens()\n instead, and then compare using \nArrays.equal()", 
            "title": "Message Formats"
        }, 
        {
            "location": "/guide/modules/message_formats/#installation-gradle", 
            "text": "Argo:    compile group: \"org.http4k\", name: \"http4k-format-argo\", version: \"2.11.2\"  Gson:    compile group: \"org.http4k\", name: \"http4k-format-gson\", version: \"2.11.2\"  Jackson:   compile group: \"org.http4k\", name: \"http4k-format-jackson\", version: \"2.11.2\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/message_formats/#about", 
            "text": "These modules add the ability to use JSON as a first-class citizen when reading from and to HTTP messages. Each implementation adds a set of \nstandard methods and extension methods for converting common types into native JSON objects, including custom Lens methods for each library so that \nJSON node objects can be written and read directly from HTTP messages:", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/message_formats/#auto-marshalling-capabilities", 
            "text": "Some of the JSON message libraries (eg. GSON and Jackson) provide the mechanism to automatically marshall data objects to/from JSON using reflection.  We can use this facility in  http4k  to automatically marshall objects to/from HTTP message bodies using * Lenses :", 
            "title": "Auto-marshalling capabilities"
        }, 
        {
            "location": "/guide/modules/message_formats/#important-note-regarding-json-arrays", 
            "text": "When handling raw JSON array messages, such as:  [123, 456, 567] , there is a slight gotcha when auto-marshalling messages from JSON.  This is demonstrated by the following, where you can see that the output of the auto-unmarshalling a naked JSON is NOT the same as a native Kotlin list of objects. This can make tests break as the unmarshalled list is NOT equal to the native list.  As shown, a workaround to this is to use  Body.auto Array MyIntWrapper ().toLens()  instead, and then compare using  Arrays.equal()", 
            "title": "Important note regarding JSON arrays"
        }, 
        {
            "location": "/guide/modules/templating/", 
            "text": "Installation (Gradle)\n\n\nHandlebars:\n \ncompile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"2.11.2\"\n\n\nPebble:\n \ncompile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"2.11.2\"\n\n\nThymeleaf:\n \ncompile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"2.11.2\"\n\n\nAbout\n\n\nThe pluggable \nhttp4k\n templating API adds \nViewModel\n rendering for common templating libraries. The implementations provide the a number of renderers for views:\n\n Cached on the classpath\n\n Cached from the filesystem\n* Hot-Reloading from the filesystem\n\n\ndata\n \nclass\n \nPerson\n(\nval\n \nname\n:\n \nString\n,\n \nval\n \nage\n:\n \nInt\n)\n \n:\n \nViewModel\n\n\n\nval\n \nrenderer\n \n=\n \nHandlebarsTemplates\n().\nHotReload\n(\nsrc/test/resources\n)\n\n\n\nval\n \napp\n:\n \nHttpHandler\n \n=\n \n{\n\n    \nval\n \nviewModel\n \n=\n \nPerson\n(\nBob\n,\n \n45\n)\n\n    \nval\n \nrenderedView\n \n=\n \nrenderer\n(\nviewModel\n)\n\n    \nResponse\n(\nOK\n).\nbody\n(\nrenderedView\n)\n\n\n}\n\n\n\nprintln\n(\napp\n(\nRequest\n(\nMethod\n.\nGET\n,\n \n/someUrl\n)))", 
            "title": "Templating"
        }, 
        {
            "location": "/guide/modules/templating/#installation-gradle", 
            "text": "Handlebars:   compile group: \"org.http4k\", name: \"http4k-template-handlebars\", version: \"2.11.2\"  Pebble:   compile group: \"org.http4k\", name: \"http4k-template-pebble\", version: \"2.11.2\"  Thymeleaf:   compile group: \"org.http4k\", name: \"http4k-template-thymeleaf\", version: \"2.11.2\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/templating/#about", 
            "text": "The pluggable  http4k  templating API adds  ViewModel  rendering for common templating libraries. The implementations provide the a number of renderers for views:  Cached on the classpath  Cached from the filesystem\n* Hot-Reloading from the filesystem  data   class   Person ( val   name :   String ,   val   age :   Int )   :   ViewModel  val   renderer   =   HandlebarsTemplates (). HotReload ( src/test/resources )  val   app :   HttpHandler   =   { \n     val   viewModel   =   Person ( Bob ,   45 ) \n     val   renderedView   =   renderer ( viewModel ) \n     Response ( OK ). body ( renderedView )  }  println ( app ( Request ( Method . GET ,   /someUrl )))", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/contracts/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-contract\", version: \"2.11.2\"\n\n\nAbout\n\n\nThe \nhttp4k-contract\n module adds a much more sophisticated routing mechanism to that available in \nhttp4k-core\n. It adds the facility \nto declare server-side \nRoutes\n in a completely typesafe way, leveraging the Lens functionality from the core. These \nRoutes\n are \ncombined into \nRouteModules\n, which have the following features:\n\n\n\n\nAuto-validating\n - the \nRoute\n contract is automatically validated on each call for required-fields and type conversions, removing the requirement  for any validation code to be written by the API user. Invalid calls result in a \nHTTP 400\n (BAD_REQUEST)\n response.     \n\n\nSelf-describing:\n - a generated endpoint is provided which describes all of the \nRoutes\n in that module. Implementations  include \nSwagger/OpenAPI\n documentation, including generation of [JSON schema]\n(http://json-schema.org/) models for messages.\n\n\nSecurity:\n to secure the \nRoutes\n  against unauthorised access. Current implementations include \nApiKey\n.\n\n\n\n\n\n\n\nWhen launched, Swagger format documentation (including JSON schema models) can be found at the route of the module.\n\n\nFor a more extended example, see the following example apps: \n\n\n\n\nTodo backend (typesafe contract version)\n\n\nTDD'd example application", 
            "title": "Typesafe Contracts"
        }, 
        {
            "location": "/guide/modules/contracts/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-contract\", version: \"2.11.2\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/contracts/#about", 
            "text": "The  http4k-contract  module adds a much more sophisticated routing mechanism to that available in  http4k-core . It adds the facility \nto declare server-side  Routes  in a completely typesafe way, leveraging the Lens functionality from the core. These  Routes  are \ncombined into  RouteModules , which have the following features:   Auto-validating  - the  Route  contract is automatically validated on each call for required-fields and type conversions, removing the requirement  for any validation code to be written by the API user. Invalid calls result in a  HTTP 400\n (BAD_REQUEST)  response.       Self-describing:  - a generated endpoint is provided which describes all of the  Routes  in that module. Implementations  include  Swagger/OpenAPI  documentation, including generation of [JSON schema]\n(http://json-schema.org/) models for messages.  Security:  to secure the  Routes   against unauthorised access. Current implementations include  ApiKey .    When launched, Swagger format documentation (including JSON schema models) can be found at the route of the module.  For a more extended example, see the following example apps:    Todo backend (typesafe contract version)  TDD'd example application", 
            "title": "About"
        }, 
        {
            "location": "/guide/modules/aws/", 
            "text": "Installation (Gradle)\n\n\ncompile group: \"org.http4k\", name: \"http4k-aws\", version: \"2.11.2\"\n\n\nAbout\n\n\nThis module provides super-simple AWS request signing functionality for talking to AWS services. This is implemented as a standard \nFilter\n which can be used to wrap a standard \nHttpHandler\n client:", 
            "title": "AWS"
        }, 
        {
            "location": "/guide/modules/aws/#installation-gradle", 
            "text": "compile group: \"org.http4k\", name: \"http4k-aws\", version: \"2.11.2\"", 
            "title": "Installation (Gradle)"
        }, 
        {
            "location": "/guide/modules/aws/#about", 
            "text": "This module provides super-simple AWS request signing functionality for talking to AWS services. This is implemented as a standard  Filter  which can be used to wrap a standard  HttpHandler  client:", 
            "title": "About"
        }, 
        {
            "location": "/guide/testing/", 
            "text": "The creators of \nhttp4k\n takes testing very seriously - so seriously that there really isn't that much to say here! \nThe API has been designed to make it as simple as possible to test both individual endpoints and entire applications in a consistent fashion, which is aided by remembering that:\n\n\n\n\nThe input and output \nRequest/Response\n objects are immutable.\n\n\nHttpHandlers\n are just functions.\n\n\nAn entire \nhttp4k\n application is \njust\n an \nHttpHandler\n.\n\n\n\n\nBecause of the above, there really isn't much required in the way of \"testing infrastructure\" - no magic containers or test fixtures that you might find in other frameworks. \nTesting is just matter of calling the correct function! Additionally, because the server and client HttpHandler interfaces are symmetrical - moving between in and out of container contexts \n(or indeed even to another HTTP framework entirely) is just a matter of switching out the HttpHandler implementation from the constructed app (out of container) to an HTTP client (in-container).\n\n\nThat said, possibly the most useful thing is to demonstrate the process that we have developed to test micro-services. A simple example of the development process can be found \n\nhere\n.", 
            "title": "Application Testing"
        }, 
        {
            "location": "/guide/example/", 
            "text": "Application Design\n\n\nWhat follows is a guide to \nhow\n we build \nhttp4k\n applications test first to provide excellent test coverage driven by decoupled tests. \n\n\nFor this example, we will use an example of a Maths app with the following requirements:\n\n The app must add 2 numbers together via an HTTP call\n\n The app must multiply 2 numbers together via an HTTP call\n* Answers generated by the service will be logged (via HTTP POST) to another server - the Recorder.\n\n\nApps can generally be split into 3 tiers:\n\n\n\n\nEndpoint: \nHttpHandlers\n are constructed individually, by providing a builder function which takes the business-level dependencies. \n\n\nApplication: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier.\n\n\nServer: Builder function which takes the configuration for environmental concerns such as ports and downstream urls.", 
            "title": "Introduction"
        }, 
        {
            "location": "/guide/example/#application-design", 
            "text": "What follows is a guide to  how  we build  http4k  applications test first to provide excellent test coverage driven by decoupled tests.   For this example, we will use an example of a Maths app with the following requirements:  The app must add 2 numbers together via an HTTP call  The app must multiply 2 numbers together via an HTTP call\n* Answers generated by the service will be logged (via HTTP POST) to another server - the Recorder.  Apps can generally be split into 3 tiers:   Endpoint:  HttpHandlers  are constructed individually, by providing a builder function which takes the business-level dependencies.   Application: Builder function which takes the transport-level dependencies, and converts them into business-level dependencies. All routes are constructed and collected in this tier.  Server: Builder function which takes the configuration for environmental concerns such as ports and downstream urls.", 
            "title": "Application Design"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/", 
            "text": "Until we have an application that can be deployed, we cannot create any business value. The Walking Skeleton\nmodel dictates that putting the most trivial endpoint into a production environment will prove our deployment\npipeline is sound, and helps to set the direction for the testing strategy that we will use going forward.\n\n\nWe start with in ICT (In-Container-Test), which have the job of testing server-level concerns such as monitoring,\ndocumentation, and checking in a high-level way that the business endpoints are wired correctly.\n\n\nRequirements:\n\n\n\n\nThe service can be pinged over HTTP to prove that is still alive.\n\n\n\n\nProduction:\n\n\n\n\nTests:", 
            "title": "1. Building a walking skeleton"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#requirements", 
            "text": "The service can be pinged over HTTP to prove that is still alive.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_1_building_a_walking_skeleton/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/", 
            "text": "Starting with another EndToEnd test, we can then drill-down into the functional behaviour of the system by introducing\nOCT (Out of Container) tests and converting the e2e test to just test endpoint wiring (so far). The common assertions have\nalso been converted to reusable extension methods on Response.\n\n\nRequirements:\n\n\n\n\nImplement an \"add\" service, which will sum a number of integer values.\n\n\n\n\nProduction:\n\n\n\n\nTests:", 
            "title": "2. Adding an endpoint"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#requirements", 
            "text": "Implement an \"add\" service, which will sum a number of integer values.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_2_adding_the_first_endpoint/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/", 
            "text": "Requirements:\n\n\n\n\nImplement a \"multiply\" service, which will find the product of a number of integer values.\n\n\n\n\nProduction:\n\n\n\n\nTests:", 
            "title": "3. Adding another endpoint"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#requirements", 
            "text": "Implement a \"multiply\" service, which will find the product of a number of integer values.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_3_adding_the_second_endpoint/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/", 
            "text": "At this point, the separation of the layers starts to become clear:\n- The server layer is responsible for taking external configuration and instantiating the app layer.\n- The application layer API is only in terms of HTTP transports - it constructs business level abstractions\nwhich are passed down into to the individual endpoints\n\n\nThe process here is to create fake versions of the dependency which can be tested against through the business interface.\nThis requires another style of testing, CDCs (Consumer Driven Contracts), to be created. These contract tests ensure that our\ninteractions with the external service are valid.\n\n\nRequirements:\n\n\n\n\nResults from calculations should be POSTed via HTTP to another \"answer recording\" service.\n\n\n\n\nImplementation Notes:\n\n\nThe following process is followed to us to the final state, whilst always allowing us to keep the build green:\n\n\n\n\nDetermine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer}\n\n\nCreate RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder\n\n\nCreate FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement\n\n\nInclude the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything)\n\n\nPass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler\n\n\nFactor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done\n\n\nIntroduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment\n\n\nAlter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp\n\n\nIn MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record()\n\n\n\n\nProduction:\n\n\n\n\nTests:", 
            "title": "4. An external dependency"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#requirements", 
            "text": "Results from calculations should be POSTed via HTTP to another \"answer recording\" service.", 
            "title": "Requirements:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#implementation-notes", 
            "text": "The following process is followed to us to the final state, whilst always allowing us to keep the build green:   Determine the HTTP contract required by the Recorder (in this case an HTTP POST to /{answer}  Create RecorderCdc and RealRecorderTest and make it pass for the real dependency by implementing the Recorder  Create FakeRecorderTest and FakeRecorderHttp and make it pass for the fake. We can now use the Fake to implement our requirement  Include the FakeRecorderHttp in the setup of EndToEndTest, starting and stopping the server (even though it's not doing anything)  Pass the configuration of the Recorder (baseUri) into the MyMathServer, which uses it to create the recorder HttpHandler  Factor AppEnvironment out of the functional tests. This is where all the setup of the functional testing environment will be done  Introduce the recorder HttpHandler to MyMathApp, creating a FakeRecorderHttp in the AppEnvironment  Alter the AddFunctionalTest and MultiplyFunctionalTest to set the expectations on the interactions recorder in FakeRecorderHttp  In MyMathApp, create the Recorder business implementation (Recorder) and pass it to calculate(), then implement the call to record()", 
            "title": "Implementation Notes:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#production", 
            "text": "", 
            "title": "Production:"
        }, 
        {
            "location": "/guide/example/_4_adding_an_external_dependency/#tests", 
            "text": "", 
            "title": "Tests:"
        }, 
        {
            "location": "/cookbook/server_as_a_function/", 
            "text": "This example is the simplest possible \"server\" implementation. Note that we are not spinning up a server-backend here - but the entire application(!) is testable but firing HTTP requests at it as if it were. \n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.11.2\n\n\n\n\n\n\nCode", 
            "title": "Server as a function"
        }, 
        {
            "location": "/cookbook/server_as_a_function/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.11.2", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/server_as_a_function/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/client_as_a_function/", 
            "text": "This example demonstrates a client module (in this case the Apache Client). A client is just another HttpHandler.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.11.2\n\n    compile group: \norg.http4k\n, name: \nhttp4k-apache\n, version: \n2.11.2\n\n\n\n\n\n\nCode", 
            "title": "Client as a function"
        }, 
        {
            "location": "/cookbook/client_as_a_function/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.11.2 \n    compile group:  org.http4k , name:  http4k-apache , version:  2.11.2", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/client_as_a_function/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/container_integration/", 
            "text": "This example shows how to both how to serve an application HttpHandler using an embedded an HTTP server and to query it using an HTTP client. All server-backend implementations are launched in an identical manner (in 1LOC). Additionally, server instances can be customised using classes available in the implementation JARs - in the case of Jetty, the application is mounted using the \nasServlet()\n extension method into the Jetty container.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.11.2\n\n    compile group: \norg.http4k\n, name: \nhttp4k-apache\n, version: \n2.11.2\n\n    compile group: \norg.http4k\n, name: \nhttp4k-jetty\n, version: \n2.11.2\n\n\n\n\n\n\nCode", 
            "title": "Container integration"
        }, 
        {
            "location": "/cookbook/container_integration/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.11.2 \n    compile group:  org.http4k , name:  http4k-apache , version:  2.11.2 \n    compile group:  org.http4k , name:  http4k-jetty , version:  2.11.2", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/container_integration/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/simple_routing/", 
            "text": "This example shows how to use the simple routing functionality to bind several routes", 
            "title": "Simple routing"
        }, 
        {
            "location": "/cookbook/nestable_routes/", 
            "text": "This is a fairly comprehensive example of the core-routing logic available:\n\n\n\n\nIndividual HTTP endpoints are represented as \nHttpHandlers\n.\n\n\nBinding an \nHttpHandler\n to a path and HTTP verb yields a \nRoute\n.\n\n\nRoutes\n can be combined together into a \nRoutingHttpHandler\n, which is both an \nHttpHandler\n and a\nRouter\n.\n\n\nA \nRouter\n is a selective request handler, which attempts to match a request. If it cannot, processing falls through to the next \nRouter\n in the list.\n\n\nRouters can be combined together to form another \nHttpHandler\n\n\nUsage of supplied core library \nFilters\n\n\nServing of static content using a \nClasspath\n resource loader\n\n\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.11.2\n\n\n\n\n\n\nCode", 
            "title": "Nestable routes"
        }, 
        {
            "location": "/cookbook/nestable_routes/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.11.2", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/nestable_routes/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/using_json/", 
            "text": "Example of how to use the JSON library API wrappers, in this case the module used is Jackson. \nhttp4k\n provides an identical interface for all JSON implementations.\n\n\nGradle setup\n\n\n    compile group: \norg.http4k\n, name: \nhttp4k-core\n, version: \n2.11.2\n\n    compile group: \norg.http4k\n, name: \nhttp4k-jackson\n, version: \n2.11.2\n\n\n\n\n\n\nCode", 
            "title": "Using JSON"
        }, 
        {
            "location": "/cookbook/using_json/#gradle-setup", 
            "text": "compile group:  org.http4k , name:  http4k-core , version:  2.11.2 \n    compile group:  org.http4k , name:  http4k-jackson , version:  2.11.2", 
            "title": "Gradle setup"
        }, 
        {
            "location": "/cookbook/using_json/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/using_templates/", 
            "text": "Example showing how to use the Templating modules - in this case Handlebars, both by standard response manipulation and via a typesafe view lens", 
            "title": "Using templates"
        }, 
        {
            "location": "/cookbook/generating_data_classes_from_json/", 
            "text": "This example show the usage of the GenerateDataClasses to generate Kotlin data class code for JSON messages from an endpoint", 
            "title": "Generating data classes from JSON"
        }, 
        {
            "location": "/cookbook/typesafe_http_contracts/", 
            "text": "This contract example shows:\n\n\n\n\n2 endpoints with typesafe contracts (marshalling of path parameters and bodies)\n\n\nCustom filters (reporting latency)\n\n\nAPI key security via a typesafe Query parameter (this can be a header or a body parameter as well)\n\n\nSwagger API documentation - Run this example and point a browser at http://petstore.swagger.io/?url=http://localhost:8000/context/swagger.json", 
            "title": "Typesafe HTTP contracts"
        }, 
        {
            "location": "/cookbook/typesafe_http_requests_with_lenses/", 
            "text": "Example showing how to create and apply lenses to requests and responses.", 
            "title": "Typesafe HTTP requests with lenses"
        }, 
        {
            "location": "/cookbook/test_driven_apps/", 
            "text": "This example shows the various styles of testing endpoints", 
            "title": "Test driven apps"
        }, 
        {
            "location": "/performance/", 
            "text": "The \nhttp4k\n server-backend modules provide a very thin adapter layer over the raw APIs of the underlying servers, so \nshould perform at a very low overhead compared to the raw server.\n\n\nTech Empower Benchmarks\n\n\nWe have entered \nhttp4k\n into the prominent \nTech Empower Framework Benchmarks\n \nproject, which assesses frameworks over a series of realistic tests, including:\n\n\n\n\nJSON response processing\n\n\nRandom data-updates (database)\n\n\nRandom data reads (database)\n\n\nTemplate-rendering (HTML)\n\n\nPlain-text pipelining\n\n\n\n\nFor this benchmark, no customisation or performance tuning of the underlying servers was done - the default Server \nconstruction mechanic was used, as below:\n\n\nfun\n \nmain\n(\nargs\n:\n \nArray\nString\n)\n \n{\n\n    \nHttp4kBenchmarkServer\n.\nstart\n(\nNetty\n(\n9000\n))\n\n\n}\n\n\n\n\n\n\nCommand-line JVM options, however, were tuned for the test to take advantage of various JVM features.\n\n\nThe full implementation of the benchmark can be found \nhere\n.\n\n\nResults\n\n\nResults and analysis will be posted here when the next round (R15) of the benchmarks is published.", 
            "title": "Performance"
        }, 
        {
            "location": "/performance/#tech-empower-benchmarks", 
            "text": "We have entered  http4k  into the prominent  Tech Empower Framework Benchmarks  \nproject, which assesses frameworks over a series of realistic tests, including:   JSON response processing  Random data-updates (database)  Random data reads (database)  Template-rendering (HTML)  Plain-text pipelining   For this benchmark, no customisation or performance tuning of the underlying servers was done - the default Server \nconstruction mechanic was used, as below:  fun   main ( args :   Array String )   { \n     Http4kBenchmarkServer . start ( Netty ( 9000 ))  }   Command-line JVM options, however, were tuned for the test to take advantage of various JVM features.  The full implementation of the benchmark can be found  here .", 
            "title": "Tech Empower Benchmarks"
        }, 
        {
            "location": "/performance/#results", 
            "text": "Results and analysis will be posted here when the next round (R15) of the benchmarks is published.", 
            "title": "Results"
        }, 
        {
            "location": "/in_action/", 
            "text": "See http4k in action in these external projects:\n\n\n\n\nTodo backend (simple version)\n\n\nTodo backend (typesafe contract version)\n\n\nTDD'd example application\n\n\nStage-by-stage example of development process (London TDD style)", 
            "title": "In action"
        }, 
        {
            "location": "/in_action/#see-http4k-in-action-in-these-external-projects", 
            "text": "Todo backend (simple version)  Todo backend (typesafe contract version)  TDD'd example application  Stage-by-stage example of development process (London TDD style)", 
            "title": "See http4k in action in these external projects:"
        }, 
        {
            "location": "/changelog/", 
            "text": "Changelog\n\n\n\nThis list is not currently intended to be all-encompassing - it will document major and breaking API changes with their rationale when appropriate:\n\n\nv2.11.2\n\n\n\n\nFix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with \nthen(RoutingHttpHandler()\n\n\n\n\nv2.11.1\n\n\n\n\nFix static routes not defaulting to index.html when in root context\n\n\n\n\nv2.11.0\n\n\n\n\nAdded \nSunHttp\n server implementation (for development use only)\n\n\n\n\nv2.10.1\n\n\n\n\nFix cookie parsing when value contains '='\n\n\n\n\nv2.10.0\n\n\n\n\nAdd method to set form values in the request\n\n\n\n\nv2.9.0\n\n\n\n\nAdded PURGE HTTP method as it's used commonly by various caches.\n\n\n\n\nv2.8.1\n\n\n\n\nRepackage AWS classes for consistency with rest of project\n\n\n\n\nv2.7.1\n\n\n\n\nAlter AWS Auth filter creation. Now use \nClientFilters.AwsAuth\n\n\n\n\nv2.7.0\n\n\n\n\nAdd AWS module\n\n\n\n\nv2.6.0\n\n\n\n\nNewly created Zipkin traces are now populated onto incoming request in ServerFilters.\n\n\n\n\nv2.5.1\n\n\n\n\nSlight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling\n\n\n\n\nv2.5.0\n\n\n\n\nAdd \nThymeleaf\n templating support\n\n\n\n\nv2.4.0\n\n\n\n\nAdd \nPebble\n templating support\n\n\n\n\nv2.3.0\n\n\n\n\nMake Route a Router so we can nest them together.\n\n\n\n\nv2.2.1\n\n\n\n\nRemove excess \"charset\" from headers in Undertow.\n\n\n\n\nv2.2.0\n\n\n\n\nRename  \nby()\n to \nbind()\n in routing for clarity. \n\n\n\n\nv2.1.2\n\n\n\n\nFix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex.\n\n\n\n\nv2.1.0\n\n\n\n\nAdded GSON full-auto functions to convert arbitary objects to/from JSON.\n\n\n\n\nv2.0.5\n\n\n\n\nFix #23. Contract now supports multi-part URL params (for hardcoded parts)\n\n\n\n\nv2.0.4\n\n\n\n\nFix #22. Uri template does not parse out correct path params when URL starts with a path part.\n\n\n\n\nv2.0.3\n\n\n\n\ntoString() implementations to aid debugging\n\n\n\n\nv2.0.1\n\n\n\n\nReadded missing default parameter for \nnewRequest()\n on RouteSpec\n\n\n\n\nv2.0.0\n\n\n\n\nBreaking: Inversion of routing API. \nGET to \"/someUri\"\n is now \n\"/someUri\" to GET\n for consistency across the entire API.\n\n\n\n\nv1.33.1\n\n\n\n\nReimplementation of \nhttp4k-contract\n API to match main routing API. Contracts are now nestable.\n\n\n\n\nv1.32.2\n\n\n\n\nFix Filters being applied twice in \nContractRoutingHttpHandler\n\n\n\n\nv1.32.1\n\n\n\n\nMore work on \nhttp4k-contract\n contract API\n\n\n\n\nv1.31.0\n\n\n\n\nRework \nhttp4k-contract\n routing to be mounted in the same way as other \nRoutingHttpHandlers\n\n\n\n\nv1.30.0\n\n\n\n\nFilters are now applied consistently to all Routers\n\n\n\n\nv1.29.0\n\n\n\n\nTweak to DSL for defining StaticRouters\n\n\n\n\nv1.28.1\n\n\n\n\nFix for #18: FollowRedirect will now work if location header includes charset information.  \n\n\n\n\nv1.28.0\n\n\n\n\nNew DSL for defining StaticRouters\n\n\n\n\nv1.27.0\n\n\n\n\nMerged StaticContent and StaticRouter and repackage of contract API into other packages\n\n\n\n\nv1.26.2\n\n\n\n\nExtend fix for #17 to request \nCookie\n header.\n\n\n\n\nv1.26.1\n\n\n\n\nFix for #17. Cookie can now parse a cookie without attributes and ending in semicolon.\n\n\n\n\nv1.26.0\n\n\n\n\nAdded nestable Routers.\n\n\nMerging of Modules and Routers. \nRouter\n is the new \nModule\n! \nRouteModule\n is now \nContractRouter\n, so rename in code will be required.\n\n\n\n\nv1.25.1\n\n\n\n\nFix for #15. OkHttp client handling of POSTs with no body.\n\n\n\n\nv1.25.0\n\n\n\n\nCan add custom mime types to Static Content\n\n\nGenerateDataClasses is capable of more complex object graphs\n\n\n\n\nv1.24.0\n\n\n\n\nRemove \nHttpHandler.asServer\n in favour of \nHttpHandler.startServer\n to avoid confusion.\n\n\nIntroduce \nStatus.description()\n.\n\n\n\n\nv1.23.0\n\n\n\n\nNetty sets content-length header.\n\n\n\n\nv1.22.2\n\n\n\n\nFix for #12. Undertow not constructing response correctly.\n\n\n\n\nv1.22.0\n\n\n\n\nNew module with Undertow.io support \nhttp4k-server-undertow\n\n\nJackson implementation now ignores unknown properties in incoming messages\n\n\nNetty implementation tidied up\n\n\n\n\nv1.21.1\n\n\n\n\nFix for #11. Netty implementation returns incorrect status codes.\n\n\n\n\nv1.21.0\n\n\n\n\nAdd synonym methods for Lenses to aid readability. We now have \ninvoke(IN)/extract(IN)\n and `invoke(IN, TARGET)/inject(IN, TARGET)\n\n\n\n\nv1.20.0\n\n\n\n\nhttp4k-contracts\n: Add option to change the route of the module description route\n\n\n\n\nv1.19.1\n\n\n\n\nhttp4k-contracts\n: Fix for contract module description routes not being authenticated via security filter\n\n\n\n\nv1.19.0\n\n\n\n\nhttp4k-contracts\n: Add \nSwagger\n module rendering with JSON schema models for messages.\n\n\n\n\nv1.18.0\n\n\n\n\nAdd \nnonEmptyString()\n lens type to all request parts.\n\n\n\n\nv1.17.0\n\n\n\n\nGeneral rework\n\n\n\n\nv1.16.0\n\n\n\n\nFurther work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios.\n\n\n\n\nv1.15.0\n\n\n\n\nPath lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc.\n\n\nRoutes can now create shell Requests for themselves, using \nroute.newRequest()\n\n\n\n\nv1.14.0\n\n\n\n\nBody is now non-nullable (use \nBody.EMPTY\n instead)\n\n\nRename methods \nBodyLens\n API for consistency and clarity. \nrequired()\n is now \ntoLens()\n. \nto()' binding method is now\nof().\n\n\n\n\nv1.13.0\n\n\n\n\nNew client module: \nhttp4k-client-okhttp\n\n\n\n\nv1.12.0\n\n\n\n\nTidying\n\n\n\n\nv1.11.0\n\n\n\n\nAdded option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :)\n\n\n\n\nv1.10.0\n\n\n\n\nMoved \nCredentials\n to \norg.http4k.core\n package.\n\n\nAdd various filters, including \nSetHostFrom\n and \nCatchAll\n.\n\n\n\n\nv1.9.0\n\n\n\n\nAdded \nGenerateDataClasses\n so you can generate Kotlin data classes from JSON messages.\n\n\n\n\nv1.8.0\n\n\n\n\nAdded CORs support\n\n\n\n\nv1.7.0\n\n\n\n\nAdded auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses\n\n\n\n\nv1.6.0\n\n\n\n\nAdded CachingFilters\n\n\n\n\nv1.5.0\n\n\n\n\nRemoved static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions.\n\n\nMerge \norg.http4k.core.Body\n and \norg.http4k.lens.Body\n.\n\n\nAdd Request/Response message parsers.\n\n\n\n\nv1.4.0\n\n\n\n\nTurn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected.\n\n\n\n\nv1.3.0\n\n\n\n\nRemoved non-mandatory parameters from Request and Response constructors. This is aid API clarity.\nand force users to use the API methods for properly constructing the objects.\n\n\nRegex Lens added.\n\n\n\n\nv1.0.0\n\n\n\n\nInitial major release.", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#v2112", 
            "text": "Fix filter application on GroupRoutingHttpHandler to apply the filter when it is applied with  then(RoutingHttpHandler()", 
            "title": "v2.11.2"
        }, 
        {
            "location": "/changelog/#v2111", 
            "text": "Fix static routes not defaulting to index.html when in root context", 
            "title": "v2.11.1"
        }, 
        {
            "location": "/changelog/#v2110", 
            "text": "Added  SunHttp  server implementation (for development use only)", 
            "title": "v2.11.0"
        }, 
        {
            "location": "/changelog/#v2101", 
            "text": "Fix cookie parsing when value contains '='", 
            "title": "v2.10.1"
        }, 
        {
            "location": "/changelog/#v2100", 
            "text": "Add method to set form values in the request", 
            "title": "v2.10.0"
        }, 
        {
            "location": "/changelog/#v290", 
            "text": "Added PURGE HTTP method as it's used commonly by various caches.", 
            "title": "v2.9.0"
        }, 
        {
            "location": "/changelog/#v281", 
            "text": "Repackage AWS classes for consistency with rest of project", 
            "title": "v2.8.1"
        }, 
        {
            "location": "/changelog/#v271", 
            "text": "Alter AWS Auth filter creation. Now use  ClientFilters.AwsAuth", 
            "title": "v2.7.1"
        }, 
        {
            "location": "/changelog/#v270", 
            "text": "Add AWS module", 
            "title": "v2.7.0"
        }, 
        {
            "location": "/changelog/#v260", 
            "text": "Newly created Zipkin traces are now populated onto incoming request in ServerFilters.", 
            "title": "v2.6.0"
        }, 
        {
            "location": "/changelog/#v251", 
            "text": "Slight tweak to GSON auto-marshalling to allow for use of raw Arrays with auto-marshalling", 
            "title": "v2.5.1"
        }, 
        {
            "location": "/changelog/#v250", 
            "text": "Add  Thymeleaf  templating support", 
            "title": "v2.5.0"
        }, 
        {
            "location": "/changelog/#v240", 
            "text": "Add  Pebble  templating support", 
            "title": "v2.4.0"
        }, 
        {
            "location": "/changelog/#v230", 
            "text": "Make Route a Router so we can nest them together.", 
            "title": "v2.3.0"
        }, 
        {
            "location": "/changelog/#v221", 
            "text": "Remove excess \"charset\" from headers in Undertow.", 
            "title": "v2.2.1"
        }, 
        {
            "location": "/changelog/#v220", 
            "text": "Rename   by()  to  bind()  in routing for clarity.", 
            "title": "v2.2.0"
        }, 
        {
            "location": "/changelog/#v212", 
            "text": "Fix for #24 - UriTemplate captures query parameters when the trailing path parameter is a regex.", 
            "title": "v2.1.2"
        }, 
        {
            "location": "/changelog/#v210", 
            "text": "Added GSON full-auto functions to convert arbitary objects to/from JSON.", 
            "title": "v2.1.0"
        }, 
        {
            "location": "/changelog/#v205", 
            "text": "Fix #23. Contract now supports multi-part URL params (for hardcoded parts)", 
            "title": "v2.0.5"
        }, 
        {
            "location": "/changelog/#v204", 
            "text": "Fix #22. Uri template does not parse out correct path params when URL starts with a path part.", 
            "title": "v2.0.4"
        }, 
        {
            "location": "/changelog/#v203", 
            "text": "toString() implementations to aid debugging", 
            "title": "v2.0.3"
        }, 
        {
            "location": "/changelog/#v201", 
            "text": "Readded missing default parameter for  newRequest()  on RouteSpec", 
            "title": "v2.0.1"
        }, 
        {
            "location": "/changelog/#v200", 
            "text": "Breaking: Inversion of routing API.  GET to \"/someUri\"  is now  \"/someUri\" to GET  for consistency across the entire API.", 
            "title": "v2.0.0"
        }, 
        {
            "location": "/changelog/#v1331", 
            "text": "Reimplementation of  http4k-contract  API to match main routing API. Contracts are now nestable.", 
            "title": "v1.33.1"
        }, 
        {
            "location": "/changelog/#v1322", 
            "text": "Fix Filters being applied twice in  ContractRoutingHttpHandler", 
            "title": "v1.32.2"
        }, 
        {
            "location": "/changelog/#v1321", 
            "text": "More work on  http4k-contract  contract API", 
            "title": "v1.32.1"
        }, 
        {
            "location": "/changelog/#v1310", 
            "text": "Rework  http4k-contract  routing to be mounted in the same way as other  RoutingHttpHandlers", 
            "title": "v1.31.0"
        }, 
        {
            "location": "/changelog/#v1300", 
            "text": "Filters are now applied consistently to all Routers", 
            "title": "v1.30.0"
        }, 
        {
            "location": "/changelog/#v1290", 
            "text": "Tweak to DSL for defining StaticRouters", 
            "title": "v1.29.0"
        }, 
        {
            "location": "/changelog/#v1281", 
            "text": "Fix for #18: FollowRedirect will now work if location header includes charset information.", 
            "title": "v1.28.1"
        }, 
        {
            "location": "/changelog/#v1280", 
            "text": "New DSL for defining StaticRouters", 
            "title": "v1.28.0"
        }, 
        {
            "location": "/changelog/#v1270", 
            "text": "Merged StaticContent and StaticRouter and repackage of contract API into other packages", 
            "title": "v1.27.0"
        }, 
        {
            "location": "/changelog/#v1262", 
            "text": "Extend fix for #17 to request  Cookie  header.", 
            "title": "v1.26.2"
        }, 
        {
            "location": "/changelog/#v1261", 
            "text": "Fix for #17. Cookie can now parse a cookie without attributes and ending in semicolon.", 
            "title": "v1.26.1"
        }, 
        {
            "location": "/changelog/#v1260", 
            "text": "Added nestable Routers.  Merging of Modules and Routers.  Router  is the new  Module !  RouteModule  is now  ContractRouter , so rename in code will be required.", 
            "title": "v1.26.0"
        }, 
        {
            "location": "/changelog/#v1251", 
            "text": "Fix for #15. OkHttp client handling of POSTs with no body.", 
            "title": "v1.25.1"
        }, 
        {
            "location": "/changelog/#v1250", 
            "text": "Can add custom mime types to Static Content  GenerateDataClasses is capable of more complex object graphs", 
            "title": "v1.25.0"
        }, 
        {
            "location": "/changelog/#v1240", 
            "text": "Remove  HttpHandler.asServer  in favour of  HttpHandler.startServer  to avoid confusion.  Introduce  Status.description() .", 
            "title": "v1.24.0"
        }, 
        {
            "location": "/changelog/#v1230", 
            "text": "Netty sets content-length header.", 
            "title": "v1.23.0"
        }, 
        {
            "location": "/changelog/#v1222", 
            "text": "Fix for #12. Undertow not constructing response correctly.", 
            "title": "v1.22.2"
        }, 
        {
            "location": "/changelog/#v1220", 
            "text": "New module with Undertow.io support  http4k-server-undertow  Jackson implementation now ignores unknown properties in incoming messages  Netty implementation tidied up", 
            "title": "v1.22.0"
        }, 
        {
            "location": "/changelog/#v1211", 
            "text": "Fix for #11. Netty implementation returns incorrect status codes.", 
            "title": "v1.21.1"
        }, 
        {
            "location": "/changelog/#v1210", 
            "text": "Add synonym methods for Lenses to aid readability. We now have  invoke(IN)/extract(IN)  and `invoke(IN, TARGET)/inject(IN, TARGET)", 
            "title": "v1.21.0"
        }, 
        {
            "location": "/changelog/#v1200", 
            "text": "http4k-contracts : Add option to change the route of the module description route", 
            "title": "v1.20.0"
        }, 
        {
            "location": "/changelog/#v1191", 
            "text": "http4k-contracts : Fix for contract module description routes not being authenticated via security filter", 
            "title": "v1.19.1"
        }, 
        {
            "location": "/changelog/#v1190", 
            "text": "http4k-contracts : Add  Swagger  module rendering with JSON schema models for messages.", 
            "title": "v1.19.0"
        }, 
        {
            "location": "/changelog/#v1180", 
            "text": "Add  nonEmptyString()  lens type to all request parts.", 
            "title": "v1.18.0"
        }, 
        {
            "location": "/changelog/#v1170", 
            "text": "General rework", 
            "title": "v1.17.0"
        }, 
        {
            "location": "/changelog/#v1160", 
            "text": "Further work on Path Lenses. They are now fully supported and consistent for both simple and contract routing scenarios.", 
            "title": "v1.16.0"
        }, 
        {
            "location": "/changelog/#v1150", 
            "text": "Path lenses are now bidirectional, so can be used to populate requests as well as bodies an headers etc.  Routes can now create shell Requests for themselves, using  route.newRequest()", 
            "title": "v1.15.0"
        }, 
        {
            "location": "/changelog/#v1140", 
            "text": "Body is now non-nullable (use  Body.EMPTY  instead)  Rename methods  BodyLens  API for consistency and clarity.  required()  is now  toLens() .  to()' binding method is now of().", 
            "title": "v1.14.0"
        }, 
        {
            "location": "/changelog/#v1130", 
            "text": "New client module:  http4k-client-okhttp", 
            "title": "v1.13.0"
        }, 
        {
            "location": "/changelog/#v1120", 
            "text": "Tidying", 
            "title": "v1.12.0"
        }, 
        {
            "location": "/changelog/#v1110", 
            "text": "Added option for Body content-negotiation to be strict or non-strict (the default). Always be strict in what you send, relaxed in what you will accept. :)", 
            "title": "v1.11.0"
        }, 
        {
            "location": "/changelog/#v1100", 
            "text": "Moved  Credentials  to  org.http4k.core  package.  Add various filters, including  SetHostFrom  and  CatchAll .", 
            "title": "v1.10.0"
        }, 
        {
            "location": "/changelog/#v190", 
            "text": "Added  GenerateDataClasses  so you can generate Kotlin data classes from JSON messages.", 
            "title": "v1.9.0"
        }, 
        {
            "location": "/changelog/#v180", 
            "text": "Added CORs support", 
            "title": "v1.8.0"
        }, 
        {
            "location": "/changelog/#v170", 
            "text": "Added auto() to Jackson, so you can auto convert body objects into and out of Requests/Responses", 
            "title": "v1.7.0"
        }, 
        {
            "location": "/changelog/#v160", 
            "text": "Added CachingFilters", 
            "title": "v1.6.0"
        }, 
        {
            "location": "/changelog/#v150", 
            "text": "Removed static factory methods for Request/Response. They were confusing/incomplete and users can easily recreate them via extension functions.  Merge  org.http4k.core.Body  and  org.http4k.lens.Body .  Add Request/Response message parsers.", 
            "title": "v1.5.0"
        }, 
        {
            "location": "/changelog/#v140", 
            "text": "Turn Body into ByteBuffer wrapper rather than typealias. That should make .toString() behave as most people would expected.", 
            "title": "v1.4.0"
        }, 
        {
            "location": "/changelog/#v130", 
            "text": "Removed non-mandatory parameters from Request and Response constructors. This is aid API clarity.\nand force users to use the API methods for properly constructing the objects.  Regex Lens added.", 
            "title": "v1.3.0"
        }, 
        {
            "location": "/changelog/#v100", 
            "text": "Initial major release.", 
            "title": "v1.0.0"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributers' Guide\n\n\n\nThere are many ways in which you can contribute to the development of the library:\n\n\n\n\nGive us a Star on Github - you know you want to ;)\n\n\nQuestions can be directed towards the Gitter channel, or on Twitter \n@http4k\n\n\nFor issues, please describe giving as much detail as you can - including version and steps to recreate\n\n\n\n\npull requests\n\n\nIf there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR. \n\n\n\n\nJSON formats: create a new module with an implementation of \nJson\n by following the \nArgo\n example in the source.\n\n\nTemplating engines: create a new module with a \nTemplates\nimplementation by following the \nHandlebarsTemplates\n example in the source\n\n\n\n\ngeneral guidelines\n\n\n\n\nAt the moment, PRs should be sent to the master branch - this might change in future so check back everytime!\n\n\nSource/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions\n\n\nPR changes should have test coverage\n\n\nAll the PRs must pass the Travis CI jobs before merging them\n\n\n\n\nhttps://travis-ci.org/http4k/http4k\n\n\nTesting with default settings is required when push changes:\n\n\nsh\n./gradlew check", 
            "title": "Contributers' Guide"
        }, 
        {
            "location": "/contributing/#pull-requests", 
            "text": "If there are any message format library or templating engine bindings that you'd like to see supported, then please feel free to suggest them or provide a PR.    JSON formats: create a new module with an implementation of  Json  by following the  Argo  example in the source.  Templating engines: create a new module with a  Templates implementation by following the  HandlebarsTemplates  example in the source", 
            "title": "pull requests"
        }, 
        {
            "location": "/contributing/#general-guidelines", 
            "text": "At the moment, PRs should be sent to the master branch - this might change in future so check back everytime!  Source/binary compatibility always must be kept as far as possible - this is a must for minor and patch versions  PR changes should have test coverage  All the PRs must pass the Travis CI jobs before merging them   https://travis-ci.org/http4k/http4k  Testing with default settings is required when push changes:  sh\n./gradlew check", 
            "title": "general guidelines"
        }, 
        {
            "location": "/support/", 
            "text": "In the first instance, try and see if there is a relevant example in the cookbook - more and more are being added all the time!\n\n\nFor issues, please describe giving as much detail as you can - including version and steps to recreate\n\n\nSlack room:\n #http4k @ \nkotlinlang.slack.com\n\n\nGitter channel:\n http4k/http4k @ \ngitter.im\n\n\nTwitter:\n \n@http4k\n\n\n\n\nLogo usage\n\n\nThe http4k logo design and branding are copyright 2017 to http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant \nbranding guidelines\n.", 
            "title": "Help & Support"
        }, 
        {
            "location": "/support/#logo-usage", 
            "text": "The http4k logo design and branding are copyright 2017 to http4k.org. If you'd like to use the http4k logo in a presentation or for other purposes, it's probably fine, but please reach out to let know first on the channels above that you'd like to do so and we can provide the relevant high-quality asset files. Here are the relevant  branding guidelines .", 
            "title": "Logo usage"
        }
    ]
}